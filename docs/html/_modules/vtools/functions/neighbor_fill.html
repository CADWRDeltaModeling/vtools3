<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>vtools.functions.neighbor_fill &#8212; vtools 3.9.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script src="../../../_static/documentation_options.js?v=f2050116"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
            </a></p>
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo" />
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Introduction and concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daylight_savings.html">Daylight Savings conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html">Averging, Filtering and Low Passing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html#Filters">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/tidal_envelope.html">Tidal Envelope Extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/climatology.html">Fitting and using a climatology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/merge_splice.html">Merging, Splicing and Blending Time Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/merge_splice.html#ts_merge:-strict-priority-option"><code class="docutils literal notranslate"><span class="pre">ts_merge</span></code>: strict priority option</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/extrapolation.html">Extrapolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/transition.html">Transitioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/neighbor_fill.html">Filling Series Based on a Neighbor (like series)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for vtools.functions.neighbor_fill</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Neighbor-based time-series gap filling.</span>

<span class="sd">This module provides a single high-level API, :func:`fill_from_neighbor`,</span>
<span class="sd">with pluggable backends for common algorithms used to infer a target series</span>
<span class="sd">from one or more nearby stations. It is designed for operational use in</span>
<span class="sd">Delta/Bay hydrodynamics workflows, but is intentionally general.</span>

<span class="sd">Highlights</span>
<span class="sd">----------</span>
<span class="sd">- Robust time alignment and optional resampling.</span>
<span class="sd">- Multiple modeling strategies: OLS/robust, rolling regression, lagged elastic-net, and state-space/Kalman.</span>
<span class="sd">- Forward-chaining (temporal) cross-validation utilities.</span>
<span class="sd">- Optional regime stratification (e.g., barrier in/out, season).</span>
<span class="sd">- Uncertainty estimates where available (analytic or residual-based).</span>
<span class="sd">- Clear return structure with diagnostics for auditability.</span>

<span class="sd">Example</span>
<span class="sd">-------</span>
<span class="sd">&gt;&gt;&gt; res = fill_from_neighbor(</span>
<span class="sd">...     target=y, neighbor=x, method=&quot;state_space&quot;, lags=range(0, 4),</span>
<span class="sd">...     bounds=(0.0, None), regime=regime_series</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; filled = res[&quot;filled&quot;]</span>
<span class="sd">&gt;&gt;&gt; info = res[&quot;model_info&quot;]</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">- &quot;Neighbor&quot; can be one series or multiple (as a DataFrame); both are supported.</span>
<span class="sd">- Missing data in the target are left as-is where the model cannot reasonably infer a value (e.g.no</span>
<span class="sd">  overlapping neighbor data). Where predictions exist, they are merged into the target to produce `filled`.</span>
<span class="sd">  DFM methods can carry through a gap in the neighbor.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">asdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">statsmodels.nonparametric.smoothers_lowess</span> <span class="kn">import</span> <span class="n">lowess</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace.mlemodel</span> <span class="kn">import</span> <span class="n">MLEModel</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">expit</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>


<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fill_from_neighbor&quot;</span><span class="p">,</span> <span class="s2">&quot;FillResult&quot;</span><span class="p">,</span><span class="s2">&quot;dfm_pack_params&quot;</span><span class="p">,</span><span class="s2">&quot;load_dfm_params&quot;</span><span class="p">,</span><span class="s2">&quot;save_dfm_params&quot;</span><span class="p">]</span>

<span class="c1"># Optional heavy dependencies</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
    <span class="kn">import</span> <span class="nn">statsmodels.formula.api</span> <span class="k">as</span> <span class="nn">smf</span>  <span class="c1"># noqa: F401</span>
    <span class="kn">from</span> <span class="nn">statsmodels.robust.robust_linear_model</span> <span class="kn">import</span> <span class="n">RLM</span>
    <span class="kn">from</span> <span class="nn">statsmodels.robust.norms</span> <span class="kn">import</span> <span class="n">HuberT</span>

    <span class="n">HAVE_SM</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">HAVE_SM</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNetCV</span>
    <span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
    <span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>

    <span class="n">HAVE_SK</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">HAVE_SK</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="FillResult">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.FillResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">FillResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for gap-filling outputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filled : pd.Series</span>
<span class="sd">        Target series with gaps filled where possible.</span>

<span class="sd">    yhat : pd.Series</span>
<span class="sd">        Model predictions aligned to the union index used for fitting/prediction.</span>

<span class="sd">    pi_lower, pi_upper : Optional[pd.Series]</span>
<span class="sd">        Prediction interval bounds where available; otherwise ``None``.</span>

<span class="sd">    model_info : dict</span>
<span class="sd">        Method, parameters, chosen lags, training window, etc.</span>

<span class="sd">    metrics : dict</span>
<span class="sd">        Holdout scores (MAE/RMSE/R^2) using forward-chaining CV where configured.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filled</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span>
    <span class="n">yhat</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span>
    <span class="n">pi_lower</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span>
    <span class="n">pi_upper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span>
    <span class="n">model_info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">metrics</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>

<div class="viewcode-block" id="FillResult.to_dict">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.FillResult.to_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Convert series to a serialization-friendly form if desired</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<span class="c1"># ---------------------------- Utilities ------------------------------------ #</span>

<span class="n">_DEF_FREQ_ERR</span> <span class="o">=</span> <span class="s2">&quot;Target and neighbor must arrive on the same regular time grid (same step and phase). &quot;</span>


<div class="viewcode-block" id="_assert_same_regular_grid">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._assert_same_regular_grid">[docs]</a>
<span class="k">def</span> <span class="nf">_assert_same_regular_grid</span><span class="p">(</span><span class="n">idx_y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">idx_x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raise if the two indices are not on the same regular grid (same step &amp; phase).&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="n">idx_y</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span> <span class="n">idx_x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">idx_y</span><span class="o">.</span><span class="n">tz</span> <span class="o">!=</span> <span class="n">idx_x</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mixed timezones between target and neighbor are not allowed.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># trivially OK (we&#39;ll fail later if there is no overlap)</span>
        <span class="c1"># check monotone and constant step</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> index must be sorted/monotonic increasing.&quot;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> index is not equally spaced.&quot;</span><span class="p">)</span>
    <span class="c1"># compare steps</span>
    <span class="k">if</span> <span class="n">idx_y</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">idx_x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">step_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">step_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">step_y</span> <span class="o">!=</span> <span class="n">step_x</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">_DEF_FREQ_ERR</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; (step mismatch: </span><span class="si">{</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">step_y</span><span class="p">)</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">step_x</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="c1"># compare phase relative to a fixed epoch</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s2">&quot;1970-01-01&quot;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">idx_y</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">rem_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">to_timedelta64</span><span class="p">()</span> <span class="o">%</span> <span class="n">step_y</span>
        <span class="n">rem_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">to_timedelta64</span><span class="p">()</span> <span class="o">%</span> <span class="n">step_x</span>
        <span class="k">if</span> <span class="n">rem_y</span> <span class="o">!=</span> <span class="n">rem_x</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">_DEF_FREQ_ERR</span> <span class="o">+</span> <span class="s2">&quot; (phase mismatch: grids are offset in time)&quot;</span>
            <span class="p">)</span></div>



<div class="viewcode-block" id="_as_series_like">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._as_series_like">[docs]</a>
<span class="k">def</span> <span class="nf">_as_series_like</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;x&quot;</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">x</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;neighbor must be a Series or DataFrame&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="_align">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._align">[docs]</a>
<span class="k">def</span> <span class="nf">_align</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
    <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;inner&quot;</span><span class="p">,</span>
    <span class="n">allow_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Align target and neighbor(s) on a common DatetimeIndex.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;target index must be a DatetimeIndex&quot;</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">_as_series_like</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;neighbor index must be a DatetimeIndex&quot;</span><span class="p">)</span>

    <span class="n">_assert_same_regular_grid</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">y_al</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">X_al</span> <span class="o">=</span> <span class="n">X</span>

    <span class="n">y2</span><span class="p">,</span> <span class="n">X2</span> <span class="o">=</span> <span class="n">y_al</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">X_al</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">X2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No overlap between target and neighbor after alignment&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y2</span><span class="p">,</span> <span class="n">X2</span></div>



<div class="viewcode-block" id="_mask_overlap">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._mask_overlap">[docs]</a>
<span class="k">def</span> <span class="nf">_mask_overlap</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Keep only timestamps where both y and ALL X columns are non-NaN.&quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">&amp;=</span> <span class="n">X</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">m</span><span class="p">]</span></div>



<div class="viewcode-block" id="_suggest_lags">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._suggest_lags">[docs]</a>
<span class="k">def</span> <span class="nf">_suggest_lags</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">max_lag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Suggest non-negative lags (in steps) by cross-correlation peak.</span>

<span class="sd">    Returns a list of lags sorted by decreasing absolute correlation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_lag</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">corrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">:</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">corrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">corrs</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">lags</span><span class="p">[</span><span class="n">order</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>



<div class="viewcode-block" id="_add_lagged_X">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._add_lagged_X">[docs]</a>
<span class="k">def</span> <span class="nf">_add_lagged_X</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">lags</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="n">Xlags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">:</span>
            <span class="n">Xlags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">_lag</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">Xlags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="_forward_chain_splits">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._forward_chain_splits">[docs]</a>
<span class="k">def</span> <span class="nf">_forward_chain_splits</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_splits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">min_train</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate forward-chaining train/test index splits for time series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of samples.</span>
<span class="sd">    n_splits : int</span>
<span class="sd">        How many folds.</span>
<span class="sd">    min_train : int</span>
<span class="sd">        Minimum size of the initial training window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">min_train</span> <span class="o">+</span> <span class="n">n_splits</span><span class="p">:</span>
        <span class="c1"># fall back to single split in the tail</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_train</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cut</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">n</span><span class="p">))]</span>
    <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">min_train</span><span class="p">)</span> <span class="o">//</span> <span class="n">n_splits</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_splits</span><span class="p">):</span>
        <span class="n">end_train</span> <span class="o">=</span> <span class="n">min_train</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step</span>
        <span class="n">test_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_train</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">train_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_train</span><span class="p">)</span>
        <span class="n">test_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">end_train</span><span class="p">,</span> <span class="n">test_end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">splits</span></div>



<div class="viewcode-block" id="_compute_metrics">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._compute_metrics">[docs]</a>
<span class="k">def</span> <span class="nf">_compute_metrics</span><span class="p">(</span><span class="n">y_true</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span>
        <span class="n">mae</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">resid</span><span class="p">)))</span>
        <span class="n">rmse</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="c1"># Simple R^2 (may be negative on holdout)</span>
        <span class="n">ss_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ss_tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">((</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">y_true</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ss_res</span> <span class="o">/</span> <span class="n">ss_tot</span><span class="p">)</span> <span class="k">if</span> <span class="n">ss_tot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;MAE&quot;</span><span class="p">:</span> <span class="n">mae</span><span class="p">,</span> <span class="s2">&quot;RMSE&quot;</span><span class="p">:</span> <span class="n">rmse</span><span class="p">,</span> <span class="s2">&quot;R2&quot;</span><span class="p">:</span> <span class="n">r2</span><span class="p">}</span></div>



<span class="c1"># ------------------------- Model Backends ---------------------------------- #</span>


<div class="viewcode-block" id="_fit_substitute">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_substitute">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_substitute</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="n">X</span>

    <span class="c1"># Use ONLY target timestamps; no need for union alignment here</span>
    <span class="n">x_on_y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Start from target and fill only its gaps from neighbor</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gap_mask</span> <span class="o">=</span> <span class="n">yhat</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">x_on_y</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gap_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_on_y</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gap_mask</span><span class="p">]</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;substitute&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_filled&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">gap_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
        <span class="s2">&quot;coverage_all&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">yhat</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span>
        <span class="s2">&quot;note&quot;</span><span class="p">:</span> <span class="s2">&quot;Filled target gaps with neighbor where available; kept original data elsewhere.&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="_fit_ols">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_ols">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_ols</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAVE_SM</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;statsmodels is required for OLS&quot;</span><span class="p">)</span>
    <span class="n">y_fit</span><span class="p">,</span> <span class="n">X_fit</span> <span class="o">=</span> <span class="n">_mask_overlap</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">X1</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X_fit</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y_fit</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">X1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s2">&quot;drop&quot;</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="c1"># Predict where X is present (not necessarily y)</span>
    <span class="n">X1_all</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">X1_all</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>
    <span class="n">conf</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">conf</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_lower&quot;</span><span class="p">)</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">conf</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_upper&quot;</span><span class="p">)</span>
    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;ols&quot;</span><span class="p">,</span>
        <span class="s2">&quot;params&quot;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;param_names&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;const&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_fit</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
        <span class="s2">&quot;rsquared&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">rsquared</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="_fit_huber">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_huber">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_huber</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAVE_SM</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;statsmodels is required for robust regression&quot;</span><span class="p">)</span>
    <span class="n">y_fit</span><span class="p">,</span> <span class="n">X_fit</span> <span class="o">=</span> <span class="n">_mask_overlap</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">X1</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X_fit</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
    <span class="n">rlm</span> <span class="o">=</span> <span class="n">RLM</span><span class="p">(</span><span class="n">y_fit</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">X1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">HuberT</span><span class="p">())</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">rlm</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="n">X1_all</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X1_all</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>
    <span class="c1"># Approximate PI using residual std (not exact for Huber)</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">y_fit</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X1</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;huber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;params&quot;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;param_names&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;const&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_fit</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
        <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">scale</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="_fit_rolling_regression">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_rolling_regression">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_rolling_regression</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAVE_SM</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;statsmodels is required for rolling regression&quot;</span><span class="p">)</span>
    <span class="c1"># Rolling fits only where full window is available</span>
    <span class="c1"># Rolling fits only where full window is available</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>
    <span class="n">beta_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Xc</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Xc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">window</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
        <span class="n">Xi</span> <span class="o">=</span> <span class="n">Xc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
        <span class="n">yi2</span><span class="p">,</span> <span class="n">Xi2</span> <span class="o">=</span> <span class="n">_mask_overlap</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">Xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">Xc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">yi2</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">Xi2</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="c1"># predict at the last row of this window</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">Xc</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># &lt;- fixed</span>
        <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
        <span class="n">beta_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="c1"># PI via rolling residual std (rough)</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;rolling_regression&quot;</span><span class="p">,</span>
        <span class="s2">&quot;window&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="p">),</span>
        <span class="s2">&quot;center&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">center</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">beta_list</span><span class="p">:</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">&quot;beta_summary&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">beta_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;std&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">beta_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="_fit_lagged_elasticnet">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_lagged_elasticnet">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_lagged_elasticnet</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">alphas</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">l1_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">n_splits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">HAVE_SK</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;scikit-learn is required for elastic-net&quot;</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">_add_lagged_X</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span>
    <span class="n">y_fit</span><span class="p">,</span> <span class="n">Z_fit</span> <span class="o">=</span> <span class="n">_mask_overlap</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alphas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;scaler&quot;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">(</span><span class="n">with_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
            <span class="p">(</span>
                <span class="s2">&quot;enet&quot;</span><span class="p">,</span>
                <span class="n">ElasticNetCV</span><span class="p">(</span>
                    <span class="n">l1_ratio</span><span class="o">=</span><span class="n">l1_ratio</span><span class="p">,</span> <span class="n">alphas</span><span class="o">=</span><span class="n">alphas</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">n_splits</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">5000</span>
                <span class="p">),</span>
            <span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Z_fit</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">y_fit</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># Predict only where all lagged features exist (no NaNs)</span>
    <span class="n">mask_pred</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">Z</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask_pred</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_pred</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="c1"># PI via residual std (analytic PI isn&#39;t native to EN)</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">y_fit</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Z_fit</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">Z</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_lower&quot;</span><span class="p">)</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">Z</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_upper&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask_pred</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">pi_lower</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_pred</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="n">pi_upper</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_pred</span><span class="p">]</span> <span class="o">=</span> <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask_pred</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;lagged_elasticnet&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lags&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">lags</span><span class="p">)),</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">named_steps</span><span class="p">[</span><span class="s2">&quot;enet&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">alpha_</span><span class="p">),</span>
        <span class="s2">&quot;l1_ratio&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">l1_ratio</span><span class="p">),</span>
        <span class="s2">&quot;n_features&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="fit_loess_time_value">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.fit_loess_time_value">[docs]</a>
<span class="k">def</span> <span class="nf">fit_loess_time_value</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">frac_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>  <span class="c1"># fraction of available points as neighbors</span>
    <span class="n">min_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>  <span class="c1"># floor on neighbors</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Two-dimensional LOESS-like smoother: y(t) ~ f(x(t), t), implemented as</span>
<span class="sd">    distance-weighted KNN in (time, value) space.</span>

<span class="sd">    - Avoids Series&amp;DataFrame boolean broadcasting by reducing XSeries first.</span>
<span class="sd">    - Scales time and value so distances are comparable.</span>
<span class="sd">    - Predicts wherever neighbor is present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure X is a DataFrame; pick the first neighbor column as driver</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;X has no columns&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Align y and x to the same index BEFORE making masks (avoids huge align ops)</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">)</span>

    <span class="n">good</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">x</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>  <span class="c1">#  Series &amp; Series (safe)</span>
    <span class="k">if</span> <span class="n">good</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient overlap for loess2d fit.&quot;</span><span class="p">)</span>

    <span class="c1"># Build (time, value) features and scale them</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">t_mu</span><span class="p">,</span> <span class="n">t_sd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">x_mu</span><span class="p">,</span> <span class="n">x_sd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="n">t_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">t_mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">t_sd</span>
    <span class="n">x_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_sd</span>

    <span class="c1"># Train KNN with distance weights on observed points</span>
    <span class="n">n_train</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_neighbors</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">frac_time</span> <span class="o">*</span> <span class="n">n_train</span><span class="p">))</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>

    <span class="n">TX_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">t_s</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="n">x_s</span><span class="p">[</span><span class="n">good</span><span class="p">]])</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">good</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">TX_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1"># Predict wherever neighbor exists (even if y is NaN in gaps)</span>
    <span class="n">pred_mask</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="n">TX_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">t_s</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">],</span> <span class="n">x_s</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">]])</span>

    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>
    <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">TX_pred</span><span class="p">)</span>

    <span class="c1"># Simple PI via residual std on training points</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">y_train</span> <span class="o">-</span> <span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">TX_train</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;loess2d&quot;</span><span class="p">,</span>
        <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
        <span class="s2">&quot;frac_time&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">frac_time</span><span class="p">),</span>
        <span class="s2">&quot;min_neighbors&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_neighbors</span><span class="p">),</span>
        <span class="s2">&quot;scaled&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="_fit_loess">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_loess">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_loess</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">frac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Locally weighted regression (LOESS) smoother for neighbor fill.&quot;&quot;&quot;</span>
    <span class="c1"># For univariate neighbor only</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LOESS currently supports one neighbor column.&quot;</span><span class="p">)</span>
    <span class="n">y_fit</span><span class="p">,</span> <span class="n">X_fit</span> <span class="o">=</span> <span class="n">_mask_overlap</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_fit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient overlap for LOESS fit.&quot;</span><span class="p">)</span>

    <span class="n">xvals</span> <span class="o">=</span> <span class="n">X_fit</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">y_fit</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="n">smoothed</span> <span class="o">=</span> <span class="n">lowess</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">xvals</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="n">frac</span><span class="p">,</span> <span class="n">return_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xvals</span><span class="p">,</span> <span class="n">smoothed</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span>
    <span class="p">)</span>

    <span class="c1"># No rigorous PI, but you can provide a rough one via residual std</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">y_fit</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">X_fit</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xvals</span><span class="p">,</span> <span class="n">smoothed</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;loess&quot;</span><span class="p">,</span> <span class="s2">&quot;frac&quot;</span><span class="p">:</span> <span class="n">frac</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="n">sigma</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<span class="c1"># -------------------- Configurable DFM (factor/anomaly options) -------------------- #</span>
<span class="c1"># --- helpers (add near your _DFM2) ------------------------------------------</span>
<div class="viewcode-block" id="_logit">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._logit">[docs]</a>
<span class="k">def</span> <span class="nf">_logit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-9</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span></div>



<div class="viewcode-block" id="_inv_logit">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._inv_logit">[docs]</a>
<span class="k">def</span> <span class="nf">_inv_logit</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span></div>



<div class="viewcode-block" id="_phi_from_logit">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._phi_from_logit">[docs]</a>
<span class="k">def</span> <span class="nf">_phi_from_logit</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_inv_logit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># in (0,1)</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span>  <span class="c1"># map to (-1,1)</span></div>



<span class="c1"># --- variable-size DFM ------------------------------------------------------</span>


<div class="viewcode-block" id="_opt_debug">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._opt_debug">[docs]</a>
<span class="k">def</span> <span class="nf">_opt_debug</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print start vs fitted params (both transformed &amp; constrained).&quot;&quot;&quot;</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">start_params</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">param_names</span>

    <span class="k">def</span> <span class="nf">_constrained</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
        <span class="c1"># map transformed  constrained dict, in the models own way</span>
        <span class="k">return</span> <span class="n">mod</span><span class="o">.</span><span class="n">_constrain</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

    <span class="n">cs</span> <span class="o">=</span> <span class="n">_constrained</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">ce</span> <span class="o">=</span> <span class="n">_constrained</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>

    <span class="c1"># print(&quot;\n=== Optimization summary ===&quot;)</span>
    <span class="c1"># print(&quot;converged:&quot;, getattr(res, &quot;mle_retvals&quot;, {}).get(&quot;converged&quot;))</span>
    <span class="c1"># print(&quot;niter:&quot;, getattr(res, &quot;mle_retvals&quot;, {}).get(&quot;nit&quot;) or getattr(res, &quot;mle_retvals&quot;, {}).get(&quot;niter&quot;))</span>
    <span class="c1"># print(f&quot;{&#39;name&#39;:&lt;14} {&#39;start&#39;:&gt;12} {&#39;fitted&#39;:&gt;12}   {&#39;constrained(start)&#39;:&gt;20} {&#39;constrained(fitted)&#39;:&gt;20}&quot;)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">e</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># show key constrained entries if present; else blank</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;log_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;logit_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">cs_v</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">))</span>
        <span class="n">ce_v</span> <span class="o">=</span> <span class="n">ce</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">&lt;14</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s2">12.4g</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">e</span><span class="si">:</span><span class="s2">12.4g</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">cs_v</span><span class="si">:</span><span class="s2">20.6g</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">ce_v</span><span class="si">:</span><span class="s2">20.6g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;============================</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="_fit_resid_interp">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_resid_interp">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_resid_interp</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>  <span class="c1"># &quot;linear&quot; | &quot;pchip&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill y using neighbor via interpolated residuals.</span>

<span class="sd">    Steps:</span>
<span class="sd">      1) Fit baseline y  a + b x on overlap (OLS; falls back to ratio if needed).</span>
<span class="sd">      2) Residuals r = y - (a + b x) on overlap.</span>
<span class="sd">      3) Interpolate r only inside gaps (bounded on both sides) using &#39;linear&#39; or &#39;pchip&#39;.</span>
<span class="sd">      4) Reconstruct yhat = (a + b x) + r_interp wherever x is available.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reduce to one neighbor</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="n">X</span>

    <span class="c1"># Align to common index; keep outer so we can predict everywhere x is present</span>
    <span class="n">y_al</span><span class="p">,</span> <span class="n">x_al</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    <span class="n">m_fit</span> <span class="o">=</span> <span class="n">y_al</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">x_al</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">m_fit</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># fall back: simple scaling</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Insufficient overlap to fit residual-interp baseline (need 3 points).&quot;</span>
        <span class="p">)</span>

    <span class="c1"># --- 1) Fit baseline y  a + b x on overlap</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>  <span class="c1"># prefer stable OLS if available</span>

        <span class="n">X1</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">x_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s2">&quot;drop&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">a_hat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">b_hat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># Ratio fallback if statsmodels not present</span>
        <span class="n">b_hat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">((</span><span class="n">y_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">]</span> <span class="o">/</span> <span class="n">x_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">b_hat</span><span class="p">):</span>
            <span class="n">b_hat</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">a_hat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">y_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">]</span> <span class="o">-</span> <span class="n">b_hat</span> <span class="o">*</span> <span class="n">x_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">]))</span>

    <span class="c1"># Base prediction everywhere x exists</span>
    <span class="n">y_base</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">y_al</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat_base&quot;</span><span class="p">)</span>
    <span class="n">y_base</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x_al</span><span class="o">.</span><span class="n">notna</span><span class="p">()]</span> <span class="o">=</span> <span class="n">a_hat</span> <span class="o">+</span> <span class="n">b_hat</span> <span class="o">*</span> <span class="n">x_al</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">x_al</span><span class="o">.</span><span class="n">notna</span><span class="p">()]</span>

    <span class="c1"># --- 2) Residuals on overlap</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">y_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">a_hat</span> <span class="o">+</span> <span class="n">b_hat</span> <span class="o">*</span> <span class="n">x_al</span><span class="p">[</span><span class="n">m_fit</span><span class="p">])</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

    <span class="c1"># --- 3) Interpolate residuals inside gaps only</span>
    <span class="c1"># We&#39;ll interpolate in time; no extrapolation past the first/last observed residual.</span>
    <span class="n">r_all</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">y_al</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;r_interp&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;pchip&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">PchipInterpolator</span>

            <span class="c1"># Numeric time in seconds for monotonic grid</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Need strictly increasing unique t; drop duplicates if any</span>
            <span class="n">t_unique</span><span class="p">,</span> <span class="n">idx_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">r_unique</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx_unique</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">t_unique</span><span class="p">,</span> <span class="n">r_unique</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">t_all</span> <span class="o">=</span> <span class="n">y_al</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span>
            <span class="n">r_interp</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">t_all</span><span class="p">)</span>
            <span class="n">r_all</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">r_interp</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Graceful fallback to linear</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span>
            <span class="c1"># continue into linear branch below</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="c1"># Pandas &#39;time&#39; interpolation uses the DatetimeIndex and stays inside by default with limit_area=&#39;inside&#39;</span>
        <span class="n">r_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">y_al</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">r_series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">resid</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">values</span>
        <span class="n">r_all</span> <span class="o">=</span> <span class="n">r_series</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">limit_area</span><span class="o">=</span><span class="s2">&quot;inside&quot;</span><span class="p">)</span>

    <span class="c1"># We only want residuals where the gap is bounded AND neighbor exists</span>
    <span class="n">pred_mask</span> <span class="o">=</span> <span class="n">x_al</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="c1"># yhat = base + interpolated residual (where available)</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">y_al</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>
    <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_base</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pred_mask</span><span class="p">]</span>
    <span class="c1"># add residuals where we have an interpolated value</span>
    <span class="n">ok_r</span> <span class="o">=</span> <span class="n">pred_mask</span> <span class="o">&amp;</span> <span class="n">r_all</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="n">yhat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ok_r</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_base</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ok_r</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_all</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ok_r</span><span class="p">]</span>

    <span class="c1"># --- 4) Simple PI: constant residual sigma from overlap</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">resid</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="k">if</span> <span class="n">resid</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
        <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">yhat</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pi_lower</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pi_upper</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;resid_interp_&quot;</span> <span class="o">+</span> <span class="n">kind</span><span class="p">,</span>
        <span class="s2">&quot;baseline&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">a_hat</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="n">b_hat</span><span class="p">},</span>
        <span class="s2">&quot;sigma_resid&quot;</span><span class="p">:</span> <span class="n">sigma</span><span class="p">,</span>
        <span class="s2">&quot;n_overlap&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">m_fit</span><span class="o">.</span><span class="n">sum</span><span class="p">()),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<div class="viewcode-block" id="DFMFill">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.DFMFill">[docs]</a>
<span class="k">class</span> <span class="nc">DFMFill</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bivariate DFM with level+slope common factor and optional anomalies.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DFMFill.__init__">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.DFMFill.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">endog</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">factor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>  <span class="c1"># {&quot;default&quot;,&quot;trimbur&quot;}</span>
        <span class="n">anomaly_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ar&quot;</span><span class="p">,</span>  <span class="c1"># {&quot;ar&quot;,&quot;rw&quot;}</span>
        <span class="n">anom_var</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>  <span class="c1"># {&quot;target&quot;,&quot;neighbor&quot;,&quot;both&quot;}</span>
        <span class="n">rx_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]]</span>
        <span class="k">assert</span> <span class="n">factor</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="s2">&quot;trimbur&quot;</span><span class="p">}</span>
        <span class="k">assert</span> <span class="n">anomaly_mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;ar&quot;</span><span class="p">,</span> <span class="s2">&quot;rw&quot;</span><span class="p">}</span>
        <span class="k">assert</span> <span class="n">anom_var</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}</span>

        <span class="c1"># Decide which anomaly slots exist and index layout</span>
        <span class="n">have_ay</span> <span class="o">=</span> <span class="n">anom_var</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}</span>
        <span class="n">have_ax</span> <span class="o">=</span> <span class="n">anom_var</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mu&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">have_ay</span><span class="p">:</span>
            <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ay&quot;</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">have_ax</span><span class="p">:</span>
            <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_have_ay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ax</span> <span class="o">=</span> <span class="n">have_ay</span><span class="p">,</span> <span class="n">have_ax</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">initialization</span><span class="o">=</span><span class="s2">&quot;approximate_diffuse&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anomaly_mode</span> <span class="o">=</span> <span class="n">anomaly_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anom_var</span> <span class="o">=</span> <span class="n">anom_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rx_scale</span><span class="p">)</span>

        <span class="c1"># Parameter list (only what we truly estimate)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;log_q_mu&quot;</span><span class="p">,</span> <span class="s2">&quot;log_q_beta&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># trimbur: q_mu is fixed to 0</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;log_q_beta&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">have_ay</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;log_q_ay&quot;</span><span class="p">,</span> <span class="s2">&quot;logit_phi_y&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">anomaly_mode</span> <span class="o">==</span> <span class="s2">&quot;ar&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;log_q_ay&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">have_ax</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;log_q_ax&quot;</span><span class="p">,</span> <span class="s2">&quot;logit_phi_x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">anomaly_mode</span> <span class="o">==</span> <span class="s2">&quot;ar&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;log_q_ax&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;log_r_y&quot;</span><span class="p">,</span> <span class="s2">&quot;log_r_x&quot;</span><span class="p">,</span> <span class="s2">&quot;load&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">anom_var</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="c1"># drop &#39;load&#39;  fix at 1.0</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="s2">&quot;load&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Allocate system matrices with correct size</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># local-linear trend</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;transition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;selection&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;state_cov&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;design&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;obs_cov&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># factor starts per spec</span>
        <span class="k">if</span> <span class="s2">&quot;log_q_mu&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="s2">&quot;log_q_mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">)</span>  <span class="c1"># default: nonzero</span>
        <span class="c1"># Trimbur has no q_mu param; it will be set to 0.0 in update()</span>
        <span class="k">if</span> <span class="s2">&quot;log_q_beta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="s2">&quot;log_q_beta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">)</span>

        <span class="c1"># anomaly roughness</span>
        <span class="k">if</span> <span class="s2">&quot;log_q_ay&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="s2">&quot;log_q_ay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-7</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;log_q_ax&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="s2">&quot;log_q_ax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-7</span><span class="p">)</span>
        <span class="c1"># AR phis (if any)</span>
        <span class="k">if</span> <span class="s2">&quot;logit_phi_y&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="s2">&quot;logit_phi_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_logit</span><span class="p">(</span><span class="mf">0.98</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;logit_phi_x&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="s2">&quot;logit_phi_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_logit</span><span class="p">(</span><span class="mf">0.98</span><span class="p">)</span>

        <span class="c1"># measurement &amp; loading</span>
        <span class="n">st</span><span class="p">[</span><span class="s2">&quot;log_r_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="n">st</span><span class="p">[</span><span class="s2">&quot;log_r_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="n">st</span><span class="p">[</span><span class="s2">&quot;load&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">st</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<div class="viewcode-block" id="DFMFill._constrain">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.DFMFill._constrain">[docs]</a>
    <span class="k">def</span> <span class="nf">_constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="c1"># Ensure real (avoids ComplexWarning)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">real</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># exp-map variances safely</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;log_q_mu&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_q_beta&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_q_ay&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_q_ax&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_r_y&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_r_x&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;log_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">)))</span>

        <span class="c1"># phis</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;logit_phi_y&quot;</span><span class="p">,</span> <span class="s2">&quot;logit_phi_x&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;logit_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">_phi_from_logit</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="o">-</span><span class="mf">0.995</span><span class="p">,</span> <span class="mf">0.995</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># loading</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;load&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DFMFill.update">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.DFMFill.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span>

        <span class="c1"># --- Transition T ---</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;transition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># anomalies AR(1) or RW phi on diagonal only if present</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ay</span><span class="p">:</span>
            <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ay&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ay&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anomaly_mode</span> <span class="o">==</span> <span class="s2">&quot;rw&quot;</span> <span class="k">else</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phi_y&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ax</span><span class="p">:</span>
            <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anomaly_mode</span> <span class="o">==</span> <span class="s2">&quot;rw&quot;</span> <span class="k">else</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phi_x&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># --- State covariance Q ---</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q_mu&quot;</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>  <span class="c1"># nonzero</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q_beta&quot;</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Trimbur: level has no shock; slope has small roughness</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q_beta&quot;</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ay</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ay&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ay&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q_ay&quot;</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ax</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q_ax&quot;</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">)</span>

        <span class="c1"># --- Design Z ---</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># target: loads 1*mu + ay(if present)</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ay</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ay&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="c1"># neighbor: loads load*mu + ax(if present)</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_ax</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="s2">&quot;ax&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># --- Obs covariance H (inflate x by rx_scale) ---</span>
        <span class="n">r_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;r_y&quot;</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">),</span> <span class="mf">1e-5</span><span class="p">)</span>
        <span class="n">r_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;r_x&quot;</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">),</span> <span class="mf">1e-5</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rx_scale</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">r_y</span><span class="p">,</span> <span class="n">r_x</span><span class="p">])</span>

        <span class="c1"># Commit</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;transition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;state_cov&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;design&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;obs_cov&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span></div>
</div>



<span class="c1"># --- DFM parameter helpers (no side effects) -------------------</span>
<span class="c1"># --- YAML-first DFM param helpers (public API) -------------------------------</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">import</span> <span class="nn">os</span>


<div class="viewcode-block" id="dfm_pack_params">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.dfm_pack_params">[docs]</a>
<span class="k">def</span> <span class="nf">dfm_pack_params</span><span class="p">(</span><span class="n">model_info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a portable blob of fitted DFM params.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_info : dict</span>
<span class="sd">        Model info dictionary, typically from `fill_from_neighbor`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary containing fitted DFM parameters with the following keys:</span>
<span class="sd">        - &#39;param_names&#39;: list of parameter names.</span>
<span class="sd">        - &#39;transformed&#39;: list of transformed parameter values.</span>
<span class="sd">        - &#39;constrained&#39;: dictionary of constrained parameter values.</span>
<span class="sd">        - &#39;mle&#39;: dictionary with optimizer info (optional).</span>
<span class="sd">        - &#39;reused&#39;: bool indicating if parameters were reused (optional).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `model_info` is not a dictionary.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no fitted parameters are found in `model_info`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;model_info must be a dict (from fill_from_neighbor).&quot;</span><span class="p">)</span>

    <span class="n">blob</span> <span class="o">=</span> <span class="n">model_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fitted_params&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;param_names&quot;</span> <span class="ow">in</span> <span class="n">blob</span> <span class="ow">and</span> <span class="s2">&quot;transformed&quot;</span> <span class="ow">in</span> <span class="n">blob</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">blob</span>

    <span class="c1"># ---- legacy fallback: older code returned only param_names + params ----</span>
    <span class="k">if</span> <span class="s2">&quot;param_names&quot;</span> <span class="ow">in</span> <span class="n">model_info</span> <span class="ow">and</span> <span class="s2">&quot;params&quot;</span> <span class="ow">in</span> <span class="n">model_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;param_names&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">model_info</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">])),</span>
            <span class="s2">&quot;transformed&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">model_info</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])),</span>
            <span class="s2">&quot;constrained&quot;</span><span class="p">:</span> <span class="p">{},</span>  <span class="c1"># unknown in legacy</span>
            <span class="s2">&quot;mle&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;converged&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>  <span class="c1"># best-effort</span>
            <span class="s2">&quot;reused&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;No fitted params found. You may be importing an older neighbor_fill &quot;</span>
        <span class="s2">&quot;that does not populate model_info[&#39;fitted_params&#39;] for DFM.&quot;</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="save_dfm_params">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.save_dfm_params">[docs]</a>
<span class="k">def</span> <span class="nf">save_dfm_params</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save a DFM parameter blob to YAML (preferred for this codebase).</span>
<span class="sd">    File extension may be .yaml or .yml. Other extensions raise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;.yaml&quot;</span><span class="p">,</span> <span class="s2">&quot;.yml&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please use a .yaml or .yml filename for DFM params.&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">yaml</span>  <span class="c1"># type: ignore</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;PyYAML is required to save YAML. Install &#39;pyyaml&#39;.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">yaml</span><span class="o">.</span><span class="n">safe_dump</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="load_dfm_params">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.load_dfm_params">[docs]</a>
<span class="k">def</span> <span class="nf">load_dfm_params</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a DFM parameter blob from YAML and validate minimal schema.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;.yaml&quot;</span><span class="p">,</span> <span class="s2">&quot;.yml&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected a .yaml or .yml file for DFM params.&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">yaml</span>  <span class="c1"># type: ignore</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;PyYAML is required to load YAML. Install &#39;pyyaml&#39;.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">blob</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Loaded DFM params are not a dict.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="s2">&quot;param_names&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blob</span>
        <span class="ow">or</span> <span class="s2">&quot;transformed&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blob</span>
        <span class="ow">or</span> <span class="s2">&quot;constrained&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blob</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;DFM params missing &#39;param_names&#39;, &#39;transformed&#39;, or &#39;constrained&#39;.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">blob</span></div>



<span class="c1"># ---------------------------------------------------------------------------</span>


<div class="viewcode-block" id="_dfm_params_to_vector">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._dfm_params_to_vector">[docs]</a>
<span class="k">def</span> <span class="nf">_dfm_params_to_vector</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build transformed vector in the exact order of mod.param_names from either:</span>
<span class="sd">      - {&#39;transformed&#39;: [...], &#39;param_names&#39;: [...]}, or</span>
<span class="sd">      - a constrained dict {&#39;q_beta&#39;:..., &#39;q_ax&#39;:..., &#39;r_y&#39;:..., &#39;r_x&#39;:..., &#39;phi_x&#39;:..., &#39;load&#39;:...}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;params is empty; pass a saved blob or constrained dict.&quot;</span><span class="p">)</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

    <span class="c1"># Case A: transformed vector given</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;transformed&quot;</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;transformed&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Length of transformed vector does not match model param_names.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">vec</span>

    <span class="c1"># Case B: constrained dict -&gt; transformed in correct order</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">_logpos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All variances must be &gt; 0 in constrained dict.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_phi_to_logit</span><span class="p">(</span><span class="n">phi</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-9</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log_q_&quot;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_logpos</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;log_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]))</span>
        <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log_r_&quot;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_logpos</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;log_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]))</span>
        <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;logit_phi_&quot;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_phi_to_logit</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;logit_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]))</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;load&quot;</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized parameter &#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&#39; in model param_names.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>



<span class="c1"># ---------------------------------------------------------------</span>
<div class="viewcode-block" id="_fit_dfm">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill._fit_dfm">[docs]</a>
<span class="k">def</span> <span class="nf">_fit_dfm</span><span class="p">(</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">factor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
    <span class="n">anomaly_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ar&quot;</span><span class="p">,</span>
    <span class="n">anom_var</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
    <span class="n">rx_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">disp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># &lt;-- ONLY control now</span>
<span class="p">):</span>
    <span class="c1"># 1) align + standardize</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="k">else</span> <span class="n">X</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">x</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">y_mu</span><span class="p">,</span> <span class="n">y_sd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">x_mu</span><span class="p">,</span> <span class="n">x_sd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y_mu</span><span class="p">,</span> <span class="n">y_sd</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">x_mu</span><span class="p">,</span> <span class="n">x_sd</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_sd</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_sd</span><span class="p">})</span>

    <span class="c1"># 2) build model</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">DFMFill</span><span class="p">(</span>
        <span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span>
        <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span>
        <span class="n">anomaly_mode</span><span class="o">=</span><span class="n">anomaly_mode</span><span class="p">,</span>
        <span class="n">anom_var</span><span class="o">=</span><span class="n">anom_var</span><span class="p">,</span>
        <span class="n">rx_scale</span><span class="o">=</span><span class="n">rx_scale</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># 3) reuse OR fit; always produce fitted_params</span>
    <span class="n">reused</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># treat {} as None</span>

    <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">_dfm_params_to_vector</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>  <span class="c1"># transformed in model order</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>  <span class="c1"># no optimizer</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">_constrain</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">transformed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">mle</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;converged&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;nit&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">reused</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">)</span>  <span class="c1"># optimizer runs</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">_constrain</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">transformed</span> <span class="o">=</span> <span class="n">vec</span>
        <span class="n">mr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;mle_retvals&quot;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">mle</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;converged&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">mr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;converged&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)),</span>
            <span class="s2">&quot;nit&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">mr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;niter&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="c1"># 4) back-transform yhat + PI</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">mod</span><span class="p">[</span><span class="s2">&quot;design&quot;</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">mod</span><span class="p">[</span><span class="s2">&quot;obs_cov&quot;</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state_cov</span>
    <span class="n">Zy</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yhat_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">Zy</span> <span class="o">@</span> <span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">yhat_s</span> <span class="o">*</span> <span class="n">y_sd</span> <span class="o">+</span> <span class="n">y_mu</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>

    <span class="n">nobs</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">var_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>
        <span class="n">var_y</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Zy</span> <span class="o">@</span> <span class="n">P</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">@</span> <span class="n">Zy</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">var_y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
        <span class="n">yhat</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">se</span> <span class="o">*</span> <span class="n">y_sd</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">yhat</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_lower&quot;</span>
    <span class="p">)</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
        <span class="n">yhat</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">se</span> <span class="o">*</span> <span class="n">y_sd</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">yhat</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_upper&quot;</span>
    <span class="p">)</span>

    <span class="c1"># 5) prints (unchanged)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Z(y):&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">4</span><span class="p">),</span> <span class="s2">&quot; Z(x):&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;diag(T):&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="s2">&quot;transition&quot;</span><span class="p">]),</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;diag(Q):&quot;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="s2">&quot;state_cov&quot;</span><span class="p">]),</span> <span class="mi">8</span><span class="p">),</span>
        <span class="s2">&quot; diag(H):&quot;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;modes:&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;factor=</span><span class="si">{</span><span class="n">factor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;anom_mode=</span><span class="si">{</span><span class="n">anomaly_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;anom_var=</span><span class="si">{</span><span class="n">anom_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;active params:&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

    <span class="c1"># 6) always-populated param blob</span>
    <span class="n">fitted_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;param_names&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span>
        <span class="s2">&quot;transformed&quot;</span><span class="p">:</span> <span class="n">transformed</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;constrained&quot;</span><span class="p">:</span> <span class="n">constrained</span><span class="p">,</span>
        <span class="s2">&quot;mle&quot;</span><span class="p">:</span> <span class="n">mle</span><span class="p">,</span>
        <span class="s2">&quot;reused&quot;</span><span class="p">:</span> <span class="n">reused</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;dfm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;factor&quot;</span><span class="p">:</span> <span class="n">factor</span><span class="p">,</span>
        <span class="s2">&quot;anomaly_mode&quot;</span><span class="p">:</span> <span class="n">anomaly_mode</span><span class="p">,</span>
        <span class="s2">&quot;anom_var&quot;</span><span class="p">:</span> <span class="n">anom_var</span><span class="p">,</span>
        <span class="s2">&quot;rx_scale&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">rx_scale</span><span class="p">),</span>
        <span class="s2">&quot;param_names&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span>
        <span class="s2">&quot;fitted_params&quot;</span><span class="p">:</span> <span class="n">fitted_params</span><span class="p">,</span>  <span class="c1"># &lt;- keep this!</span>
        <span class="s2">&quot;scaling&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;y_mu&quot;</span><span class="p">:</span> <span class="n">y_mu</span><span class="p">,</span> <span class="s2">&quot;y_sd&quot;</span><span class="p">:</span> <span class="n">y_sd</span><span class="p">,</span> <span class="s2">&quot;x_mu&quot;</span><span class="p">:</span> <span class="n">x_mu</span><span class="p">,</span> <span class="s2">&quot;x_sd&quot;</span><span class="p">:</span> <span class="n">x_sd</span><span class="p">},</span>
        <span class="s2">&quot;llf&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;llf&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
        <span class="s2">&quot;aic&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;aic&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
        <span class="s2">&quot;bic&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;bic&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">)</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>  <span class="c1"># ensure matrices reflect constrained params</span>
    <span class="c1"># _opt_debug(mod, res)</span>

    <span class="c1"># Smoothed y = Z_y  E[state|all]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">mod</span><span class="p">[</span><span class="s2">&quot;design&quot;</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">mod</span><span class="p">[</span><span class="s2">&quot;obs_cov&quot;</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state_cov</span>
    <span class="n">Zy</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yhat_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">Zy</span> <span class="o">@</span> <span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">yhat_s</span> <span class="o">*</span> <span class="n">y_sd</span> <span class="o">+</span> <span class="n">y_mu</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yhat&quot;</span><span class="p">)</span>

    <span class="c1"># 95% PI with state covariance</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">var_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>
        <span class="n">var_y</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Zy</span> <span class="o">@</span> <span class="n">P</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">@</span> <span class="n">Zy</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">se</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">var_y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
    <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
        <span class="n">yhat</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">se</span> <span class="o">*</span> <span class="n">y_sd</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">yhat</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_lower&quot;</span>
    <span class="p">)</span>
    <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
        <span class="n">yhat</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">se</span> <span class="o">*</span> <span class="n">y_sd</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">yhat</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pi_upper&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Diagnostics similar to your prints</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Z(y):&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">4</span><span class="p">),</span> <span class="s2">&quot; Z(x):&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;diag(T):&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="s2">&quot;transition&quot;</span><span class="p">]),</span> <span class="mi">4</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;diag(Q):&quot;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mod</span><span class="p">[</span><span class="s2">&quot;state_cov&quot;</span><span class="p">]),</span> <span class="mi">8</span><span class="p">),</span>
        <span class="s2">&quot; diag(H):&quot;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="mi">8</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;modes:&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;factor=</span><span class="si">{</span><span class="n">factor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;anom_mode=</span><span class="si">{</span><span class="n">anomaly_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;anom_var=</span><span class="si">{</span><span class="n">anom_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;active params:&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;dfm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;factor&quot;</span><span class="p">:</span> <span class="n">factor</span><span class="p">,</span>
        <span class="s2">&quot;anomaly_mode&quot;</span><span class="p">:</span> <span class="n">anomaly_mode</span><span class="p">,</span>
        <span class="s2">&quot;anom_var&quot;</span><span class="p">:</span> <span class="n">anom_var</span><span class="p">,</span>
        <span class="s2">&quot;param_names&quot;</span><span class="p">:</span> <span class="n">mod</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span>
        <span class="s2">&quot;params&quot;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s2">&quot;llf&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">llf</span><span class="p">),</span>
        <span class="s2">&quot;aic&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;aic&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
        <span class="s2">&quot;bic&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;bic&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span>
    <span class="p">}</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># ... your existing fields ...</span>
    <span class="p">}</span>
    <span class="c1"># If we actually fit, return the fitted params for persistence.</span>
    <span class="k">if</span> <span class="n">fit</span> <span class="ow">and</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;params&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;fitted_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_dfm_pack_params</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span></div>



<span class="c1"># ----------------------------- Orchestrator -------------------------------- #</span>


<div class="viewcode-block" id="fill_from_neighbor">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.fill_from_neighbor">[docs]</a>
<span class="k">def</span> <span class="nf">fill_from_neighbor</span><span class="p">(</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">neighbor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;substitute&quot;</span><span class="p">,</span>
    <span class="n">regime</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill gaps in ``target`` using information from ``neighbor``.</span>

<span class="sd">    This is a high-level wrapper with multiple method backends (OLS/robust,</span>
<span class="sd">    rolling regression, lagged regression, LOESS-in-time, Trimbur-style DFM</span>
<span class="sd">    variants, residual-interpolation baselines, or simple substitution).</span>
<span class="sd">    Inputs must already lie on the **same regular time grid** (same step and phase);</span>
<span class="sd">    this function does **not** resample.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target : pandas.Series</span>
<span class="sd">        Target time series with a ``DatetimeIndex`` on a regular grid. Values may be NaN.</span>

<span class="sd">    neighbor : pandas.Series or pandas.DataFrame</span>
<span class="sd">        One or more neighbor series with a ``DatetimeIndex`` on the **same grid**</span>
<span class="sd">        as ``target`` (same step and phase). Values may be NaN.</span>

<span class="sd">    method : {&#39;substitute&#39;, &#39;ols&#39;, &#39;huber&#39;, &#39;rolling&#39;, &#39;lagged_reg&#39;,</span>
<span class="sd">            &#39;loess&#39;, &#39;dfm_trimbur_rw&#39;, &#39;dfm_trimbur_ar&#39;,</span>
<span class="sd">            &#39;resid_interp_linear&#39;, &#39;resid_interp_pchip&#39;}</span>
<span class="sd">        Algorithm to use:</span>

<span class="sd">        - ``&#39;substitute&#39;``: pass-through neighbor after mean/scale alignment.</span>
<span class="sd">        - ``&#39;ols&#39;``: ordinary least squares on overlap (optionally with lags).</span>
<span class="sd">        - ``&#39;huber&#39;``: robust regression with Huber loss (optionally with lags).</span>
<span class="sd">        - ``&#39;rolling&#39;``: rolling-window OLS in *sample* units (not time offsets).</span>
<span class="sd">        - ``&#39;lagged_reg&#39;``: multivariate regression on specified neighbor lags.</span>
<span class="sd">        - ``&#39;loess&#39;``: LOESS (time  value) smoothing using neighbor as scaffold.</span>
<span class="sd">        - ``&#39;dfm_trimbur_rw&#39;``: dynamic factor model (Trimbur factor) with</span>
<span class="sd">        random-walk anomaly for the target.</span>
<span class="sd">        - ``&#39;dfm_trimbur_ar&#39;``: dynamic factor model (Trimbur factor) with AR anomaly</span>
<span class="sd">        on the neighbor.</span>
<span class="sd">        - ``&#39;resid_interp_linear&#39;`` / ``&#39;resid_interp_pchip&#39;``: baseline ya+bx fit</span>
<span class="sd">        on overlap, then interpolate residuals (linear or PCHIP) across gaps.</span>

<span class="sd">    regime : pandas.Series, optional</span>
<span class="sd">        Optional categorical series indexed like ``target`` to stratify fits</span>
<span class="sd">        (e.g., barrier in/out). If provided, models are fit per category and</span>
<span class="sd">        stitched back together.</span>

<span class="sd">    bounds : (float or None, float or None)</span>
<span class="sd">        Lower/upper bounds to clip the final filled values (applied at the end).</span>

<span class="sd">    params : dict, optional</span>
<span class="sd">        Pre-fitted/packed parameter blob for methods that support parameter reuse</span>
<span class="sd">        (e.g., the DFM backends). If provided, fitting is skipped and the supplied</span>
<span class="sd">        parameters are used directly.</span>

<span class="sd">    **kwargs</span>
<span class="sd">        Method-specific optional arguments. Unsupported keys are ignored unless</span>
<span class="sd">        otherwise noted. Typical extras by method:</span>

<span class="sd">        Common</span>
<span class="sd">            lags : int or Sequence[int], optional</span>
<span class="sd">                Non-negative lags (in samples) for neighbor features. If an int m is</span>
<span class="sd">                provided, implementations may expand to range(0, m+1). Default behavior</span>
<span class="sd">                varies by method (often no lags or a small heuristic set).</span>
<span class="sd">            seed : int, optional</span>
<span class="sd">                Random seed for any stochastic initializations (where applicable).</span>

<span class="sd">        &#39;ols&#39;</span>
<span class="sd">            lags : int or Sequence[int], optional</span>
<span class="sd">            add_const : bool, default True</span>
<span class="sd">                Include an intercept term.</span>
<span class="sd">            fit_intercept : bool, alias of ``add_const``.</span>

<span class="sd">        &#39;huber&#39;</span>
<span class="sd">            lags : int or Sequence[int], optional</span>
<span class="sd">            huber_t : float, default 1.35</span>
<span class="sd">                Huber threshold (in residual  units).</span>
<span class="sd">            maxiter : int, default 200</span>
<span class="sd">            tol : float, default 1e-6</span>

<span class="sd">        &#39;rolling&#39;</span>
<span class="sd">            window : int, required</span>
<span class="sd">                Rolling window length **in samples** (integer). Time-offset strings</span>
<span class="sd">                (e.g., &#39;14D&#39;) are **not** supported here.</span>
<span class="sd">            min_periods : int, optional</span>
<span class="sd">                Minimum non-NaN samples required inside each window (default = window).</span>
<span class="sd">            center : bool, default False</span>
<span class="sd">                Whether to center the rolling window.</span>
<span class="sd">            lags : int or Sequence[int], optional</span>
<span class="sd">                If provided, each regression uses lagged neighbor columns inside</span>
<span class="sd">                the window.</span>

<span class="sd">        &#39;lagged_reg&#39;</span>
<span class="sd">            lags : int or Sequence[int], recommended</span>
<span class="sd">            alpha : float, optional</span>
<span class="sd">                Ridge/L2 penalty (if the backend supports it).</span>
<span class="sd">            l1_ratio : float, optional</span>
<span class="sd">                Elastic-net mixing (if the backend supports it).</span>
<span class="sd">            standardize : bool, default True</span>
<span class="sd">                Standardize columns before regression.</span>

<span class="sd">        &#39;loess&#39;</span>
<span class="sd">            frac : float, default 0.25</span>
<span class="sd">                LOESS span as a fraction of the data length (used in timevalue smoothing).</span>
<span class="sd">            it : int, default 0</span>
<span class="sd">                Number of robustifying reweighting iterations.</span>
<span class="sd">            degree : int, default 1</span>
<span class="sd">                Local polynomial degree.</span>

<span class="sd">        &#39;dfm_trimbur_rw&#39; / &#39;dfm_trimbur_ar&#39;</span>
<span class="sd">            rx_scale : float, default 1.0</span>
<span class="sd">                Relative scale factor for neighbor measurement noise.</span>
<span class="sd">            maxiter : int, default 80</span>
<span class="sd">                Maximum optimizer iterations during parameter fitting.</span>
<span class="sd">            disp : int, default 0</span>
<span class="sd">                Optimizer verbosity (0 = silent).</span>
<span class="sd">            anom_var : {&#39;target&#39;,&#39;neighbor&#39;}, optional</span>
<span class="sd">                Which series carries the anomaly/noise term (fixed by the variant,</span>
<span class="sd">                but may be overridden).</span>
<span class="sd">            ar_order : int, optional</span>
<span class="sd">                AR order for the anomaly in the ``&#39;_ar&#39;`` variant (default may be 1).</span>
<span class="sd">            param_names : list[str], optional</span>
<span class="sd">                For advanced users: explicit parameter naming (used when packing).</span>
<span class="sd">            # Note: DFM backends accept ``params=...`` at the top level for reuse.</span>

<span class="sd">        &#39;resid_interp_linear&#39; / &#39;resid_interp_pchip&#39;</span>
<span class="sd">            min_overlap : int, default 3</span>
<span class="sd">                Minimum overlapping samples required to fit the baseline ya+bx.</span>
<span class="sd">            clip_residuals_sigma : float, optional</span>
<span class="sd">                Winsorize residuals before interpolation ( units).</span>
<span class="sd">            enforce_monotone : bool, default False</span>
<span class="sd">                For PCHIP path only: enforce monotonic segments where applicable.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary with the following keys:</span>

<span class="sd">        yhat : pandas.Series</span>
<span class="sd">            Filled series on the same index as ``target``.</span>
<span class="sd">        pi_lower : pandas.Series or None</span>
<span class="sd">            Lower uncertainty band (if the method provides one), otherwise None.</span>
<span class="sd">        pi_upper : pandas.Series or None</span>
<span class="sd">            Upper uncertainty band (if the method provides one), otherwise None.</span>
<span class="sd">        model_info : dict</span>
<span class="sd">            Method-specific diagnostics and metadata. Typical fields include:</span>
<span class="sd">            ``method``, ``param_names``, ``fitted_params`` (packed blob for reuse),</span>
<span class="sd">            ``scaling`` (means/stds used), goodness-of-fit (e.g., ``llf``, ``aic``,</span>
<span class="sd">            ``bic``), and per-regime info when ``regime`` is provided.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If indices are not equally spaced, or grids mismatch in step or phase,</span>
<span class="sd">        or if required method-specific kwargs are missing (e.g., ``window`` for</span>
<span class="sd">        ``method=&#39;rolling&#39;``).</span>
<span class="sd">    KeyError</span>
<span class="sd">        If an unknown method name is provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># add these names in the set:</span>
    <span class="n">recognized</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;ols&quot;</span><span class="p">,</span>
        <span class="s2">&quot;huber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rolling&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lagged_reg&quot;</span><span class="p">,</span>
        <span class="s2">&quot;loess&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dfm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dfm_trimbur_ar&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dfm_trimbur_rw&quot;</span><span class="p">,</span>
        <span class="s2">&quot;resid_interp_linear&quot;</span><span class="p">,</span>
        <span class="s2">&quot;resid_interp_pchip&quot;</span><span class="p">,</span>
        <span class="s2">&quot;substitute&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">recognized</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown method: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;dfm_trimbur_rw&quot;</span><span class="p">,</span> <span class="s2">&quot;dfm_trimbur_ar&quot;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;fit&#39;/&#39;params&#39; are only supported for DFM methods.&quot;</span><span class="p">)</span>

    <span class="n">y0</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">_as_series_like</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="c1"># Pull optional tuning params from **kwargs (keeps backward compat in notebooks)</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;lags&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;window&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Align to common grid; for rolling with str window we regularize first</span>
    <span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span> <span class="o">=</span> <span class="n">_align</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">allow_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># If regime given, process per category and stitch</span>
    <span class="k">if</span> <span class="n">regime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">regime</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">y_al</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span><span class="o">.</span><span class="n">categories</span>
        <span class="n">yhats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pil_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">piu_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">info_all</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span> <span class="s2">&quot;by_regime&quot;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">cats</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">==</span> <span class="n">cat</span>
            <span class="n">y_c</span> <span class="o">=</span> <span class="n">y_al</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">X_c</span> <span class="o">=</span> <span class="n">X_al</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">res_c</span> <span class="o">=</span> <span class="n">fill_from_neighbor</span><span class="p">(</span>
                <span class="n">y_c</span><span class="p">,</span> <span class="n">X_c</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
            <span class="p">)</span>
            <span class="n">yhats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res_c</span><span class="p">[</span><span class="s2">&quot;yhat&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">cat</span><span class="p">)))</span>
            <span class="n">pil_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res_c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pi_lower&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">cat</span><span class="p">)))</span>
            <span class="n">piu_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res_c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pi_upper&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">cat</span><span class="p">)))</span>
            <span class="n">info_all</span><span class="p">[</span><span class="s2">&quot;by_regime&quot;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">cat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_c</span><span class="p">[</span><span class="s2">&quot;model_info&quot;</span><span class="p">]</span>
        <span class="c1"># Combine by choosing regime-specific predictions</span>
        <span class="n">yhat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">yhats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pi_lower</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pil_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pi_upper</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">piu_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info_all</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;substitute&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_substitute</span><span class="p">(</span><span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ols&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_ols</span><span class="p">(</span><span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;huber&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_huber</span><span class="p">(</span><span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;rolling&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;window must be provided for rolling regression (in samples)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;String window (e.g., &#39;30D&#39;) no longer supported. Pass an integer number of samples.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">window_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_rolling_regression</span><span class="p">(</span>
                <span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_n</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;lagged_reg&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">first_col</span> <span class="o">=</span> <span class="n">X_al</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">max_lag</span> <span class="o">=</span> <span class="mi">6</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lag_list</span> <span class="o">=</span> <span class="n">_suggest_lags</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">_mask_overlap</span><span class="p">(</span><span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">[[</span><span class="n">first_col</span><span class="p">]]),</span> <span class="n">max_lag</span><span class="o">=</span><span class="n">max_lag</span>
                    <span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">lag_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">lag_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lag_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">lags</span><span class="p">))</span>

            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_lagged_elasticnet</span><span class="p">(</span>
                <span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lag_list</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;loess&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">fit_loess_time_value</span><span class="p">(</span><span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;dfm_trimbur_rw&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_dfm</span><span class="p">(</span>
                <span class="n">y_al</span><span class="p">,</span>
                <span class="n">X_al</span><span class="p">,</span>
                <span class="n">factor</span><span class="o">=</span><span class="s2">&quot;trimbur&quot;</span><span class="p">,</span>
                <span class="n">anomaly_mode</span><span class="o">=</span><span class="s2">&quot;rw&quot;</span><span class="p">,</span>
                <span class="n">anom_var</span><span class="o">=</span><span class="s2">&quot;target&quot;</span><span class="p">,</span>
                <span class="n">rx_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">maxiter</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;dfm_trimbur_ar&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_dfm</span><span class="p">(</span>
                <span class="n">y_al</span><span class="p">,</span>
                <span class="n">X_al</span><span class="p">,</span>
                <span class="n">factor</span><span class="o">=</span><span class="s2">&quot;trimbur&quot;</span><span class="p">,</span>
                <span class="n">anomaly_mode</span><span class="o">=</span><span class="s2">&quot;ar&quot;</span><span class="p">,</span>
                <span class="n">anom_var</span><span class="o">=</span><span class="s2">&quot;neighbor&quot;</span><span class="p">,</span>
                <span class="n">rx_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">maxiter</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;resid_interp_linear&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_resid_interp</span><span class="p">(</span>
                <span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;resid_interp_pchip&quot;</span><span class="p">:</span>
            <span class="n">yhat</span><span class="p">,</span> <span class="n">pi_lower</span><span class="p">,</span> <span class="n">pi_upper</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_fit_resid_interp</span><span class="p">(</span><span class="n">y_al</span><span class="p">,</span> <span class="n">X_al</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;pchip&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown method: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

    <span class="c1"># Merge predictions into target to create filled series</span>
    <span class="n">filled</span> <span class="o">=</span> <span class="n">y_al</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">missing_mask</span> <span class="o">=</span> <span class="n">filled</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
    <span class="n">filled</span><span class="p">[</span><span class="n">missing_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">yhat</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span><span class="p">)[</span><span class="n">missing_mask</span><span class="p">]</span>

    <span class="c1"># Clip bounds if provided</span>
    <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filled</span> <span class="o">=</span> <span class="n">filled</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="n">lo</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filled</span> <span class="o">=</span> <span class="n">filled</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">upper</span><span class="o">=</span><span class="n">hi</span><span class="p">)</span>

    <span class="c1"># Forward-chaining CV (optional, rough)</span>
    <span class="n">metrics</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">FillResult</span><span class="p">(</span>
        <span class="n">filled</span><span class="o">=</span><span class="n">filled</span><span class="p">,</span>
        <span class="n">yhat</span><span class="o">=</span><span class="n">yhat</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
        <span class="n">pi_lower</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">pi_lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pi_lower</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span><span class="p">)),</span>
        <span class="n">pi_upper</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">pi_upper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pi_upper</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span><span class="p">)),</span>
        <span class="n">model_info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span>
        <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span></div>



<span class="c1"># ----------------------- Optional CSV writer with YAML ---------------------- #</span>


<div class="viewcode-block" id="write_filled_csv_with_yaml_header">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.neighbor_fill.write_filled_csv_with_yaml_header">[docs]</a>
<span class="k">def</span> <span class="nf">write_filled_csv_with_yaml_header</span><span class="p">(</span>
    <span class="n">filled</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">model_info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">metrics</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">extra_meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">float_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.6g}</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Write a CSV file with a YAML-like header as #-comments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filled : pd.Series</span>
<span class="sd">        Series to write; index must be a DatetimeIndex.</span>
<span class="sd">    path : str</span>
<span class="sd">        Destination filepath.</span>
<span class="sd">    model_info : dict</span>
<span class="sd">        Metadata from fill_from_neighbor; will be serialized.</span>
<span class="sd">    metrics : dict, optional</span>
<span class="sd">        Metrics to include.</span>
<span class="sd">    extra_meta : dict, optional</span>
<span class="sd">        Any additional metadata.</span>
<span class="sd">    float_format : str</span>
<span class="sd">        Format string for values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filled</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;filled.index must be a DatetimeIndex&quot;</span><span class="p">)</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;model_info&quot;</span><span class="p">:</span> <span class="n">model_info</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;metrics&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metrics</span>
    <span class="k">if</span> <span class="n">extra_meta</span><span class="p">:</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">extra_meta</span><span class="p">)</span>
    <span class="c1"># Simple YAML-ish dump</span>
    <span class="kn">import</span> <span class="nn">json</span>

    <span class="n">header_lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;# --- neighbor_fill metadata ---&quot;</span><span class="p">]</span>
    <span class="n">header_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">str</span><span class="p">))</span>
    <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header_lines</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="c1"># Build CSV body</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">filled</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;datetime&quot;</span>
    <span class="n">csv_body</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">date_format</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">csv_body</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2019, California Department of Water Resources.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>