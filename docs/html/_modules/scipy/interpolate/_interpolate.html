<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.interpolate._interpolate &#8212; vtools 0.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script src="../../../_static/documentation_options.js?v=7026087e"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
            </a></p>
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo" />
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Introduction and concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daylight_savings.html">Daylight Savings conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html">Averging, Filtering and Low Passing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html#Filters">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/tidal_envelope.html">Tidal Envelope Extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/climatology.html">Fitting and using a climatology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/merge_splice.html">Merging and Splicing Time Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/merge_splice.html#ts_merge:-strict-priority-option"><code class="docutils literal notranslate"><span class="pre">ts_merge</span></code>: strict priority option</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/extrapolation.html">Extrapolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/transition.html">Transitioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scipy.interpolate._interpolate</h1><div class="highlight"><pre>
<span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;interp1d&#39;</span><span class="p">,</span> <span class="s1">&#39;interp2d&#39;</span><span class="p">,</span> <span class="s1">&#39;lagrange&#39;</span><span class="p">,</span> <span class="s1">&#39;PPoly&#39;</span><span class="p">,</span> <span class="s1">&#39;BPoly&#39;</span><span class="p">,</span> <span class="s1">&#39;NdPPoly&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">searchsorted</span><span class="p">,</span> <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">atleast_2d</span><span class="p">,</span>
                   <span class="n">ravel</span><span class="p">,</span> <span class="n">poly1d</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">intp</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">spec</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_fitpack_py</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">dfitpack</span>
<span class="kn">from</span> <span class="nn">._polyint</span> <span class="kn">import</span> <span class="n">_Interpolator1D</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ppoly</span>
<span class="kn">from</span> <span class="nn">.interpnd</span> <span class="kn">import</span> <span class="n">_ndim_coords_from_arrays</span>
<span class="kn">from</span> <span class="nn">._bsplines</span> <span class="kn">import</span> <span class="n">make_interp_spline</span><span class="p">,</span> <span class="n">BSpline</span>

<span class="c1"># even though this is a stdlib module, it got accidentally exposed in __all__</span>
<span class="c1"># in the past. It is now deprecated and scheduled to be removed in SciPy 1.13.0</span>
<span class="kn">import</span> <span class="nn">itertools</span>  <span class="c1"># noqa: F401</span>


<span class="k">def</span> <span class="nf">lagrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Lagrange interpolating polynomial.</span>

<span class="sd">    Given two 1-D arrays `x` and `w,` returns the Lagrange interpolating</span>
<span class="sd">    polynomial through the points ``(x, w)``.</span>

<span class="sd">    Warning: This implementation is numerically unstable. Do not expect to</span>
<span class="sd">    be able to use more than about 20 points even if they are chosen optimally.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        `x` represents the x-coordinates of a set of datapoints.</span>
<span class="sd">    w : array_like</span>
<span class="sd">        `w` represents the y-coordinates of a set of datapoints, i.e., f(`x`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lagrange : `numpy.poly1d` instance</span>
<span class="sd">        The Lagrange interpolating polynomial.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Interpolate :math:`f(x) = x^3` by 3 points.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import lagrange</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x**3</span>
<span class="sd">    &gt;&gt;&gt; poly = lagrange(x, y)</span>

<span class="sd">    Since there are only 3 points, Lagrange polynomial has degree 2. Explicitly,</span>
<span class="sd">    it is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        \begin{aligned}</span>
<span class="sd">            L(x) &amp;= 1\times \frac{x (x - 2)}{-1} + 8\times \frac{x (x-1)}{2} \\</span>
<span class="sd">                 &amp;= x (-2 + 3x)</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    &gt;&gt;&gt; from numpy.polynomial.polynomial import Polynomial</span>
<span class="sd">    &gt;&gt;&gt; Polynomial(poly.coef[::-1]).coef</span>
<span class="sd">    array([ 0., -2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x_new = np.arange(0, 2.1, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.scatter(x, y, label=&#39;data&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x_new, Polynomial(poly.coef[::-1])(x_new), label=&#39;Polynomial&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x_new, 3*x_new**2 - 2*x_new + 0*x_new,</span>
<span class="sd">    ...          label=r&quot;$3 x^2 - 2 x$&quot;, linestyle=&#39;-.&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">poly1d</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">poly1d</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">pt</span> <span class="o">*=</span> <span class="n">poly1d</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span><span class="o">/</span><span class="n">fac</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">pt</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="c1"># !! Need to find argument for keeping initialize. If it isn&#39;t</span>
<span class="c1"># !! found, get rid of it!</span>


<span class="n">dep_mesg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">`interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy 1.14.0.</span>

<span class="s2">For legacy code, nearly bug-for-bug compatible replacements are</span>
<span class="s2">`RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for</span>
<span class="s2">scattered 2D data.</span>

<span class="s2">In new code, for regular grids use `RegularGridInterpolator` instead.</span>
<span class="s2">For scattered data, prefer `LinearNDInterpolator` or</span>
<span class="s2">`CloughTocher2DInterpolator`.</span>

<span class="s2">For more details see</span>
<span class="s2">`https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html`</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">interp2d</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    interp2d(x, y, z, kind=&#39;linear&#39;, copy=True, bounds_error=False,</span>
<span class="sd">             fill_value=None)</span>

<span class="sd">    .. deprecated:: 1.10.0</span>

<span class="sd">        `interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy</span>
<span class="sd">        1.14.0.</span>

<span class="sd">        For legacy code, nearly bug-for-bug compatible replacements are</span>
<span class="sd">        `RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for</span>
<span class="sd">        scattered 2D data.</span>

<span class="sd">        In new code, for regular grids use `RegularGridInterpolator` instead.</span>
<span class="sd">        For scattered data, prefer `LinearNDInterpolator` or</span>
<span class="sd">        `CloughTocher2DInterpolator`.</span>

<span class="sd">        For more details see</span>
<span class="sd">        `https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html</span>
<span class="sd">        &lt;https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html&gt;`_</span>


<span class="sd">    Interpolate over a 2-D grid.</span>

<span class="sd">    `x`, `y` and `z` are arrays of values used to approximate some function</span>
<span class="sd">    f: ``z = f(x, y)`` which returns a scalar value `z`. This class returns a</span>
<span class="sd">    function whose call method uses spline interpolation to find the value</span>
<span class="sd">    of new points.</span>

<span class="sd">    If `x` and `y` represent a regular grid, consider using</span>
<span class="sd">    `RectBivariateSpline`.</span>

<span class="sd">    If `z` is a vector value, consider using `interpn`.</span>

<span class="sd">    Note that calling `interp2d` with NaNs present in input values, or with</span>
<span class="sd">    decreasing values in `x` an `y` results in undefined behaviour.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : array_like</span>
<span class="sd">        Arrays defining the data point coordinates.</span>
<span class="sd">        The data point coordinates need to be sorted by increasing order.</span>

<span class="sd">        If the points lie on a regular grid, `x` can specify the column</span>
<span class="sd">        coordinates and `y` the row coordinates, for example::</span>

<span class="sd">          &gt;&gt;&gt; x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]</span>

<span class="sd">        Otherwise, `x` and `y` must specify the full coordinates for each</span>
<span class="sd">        point, for example::</span>

<span class="sd">          &gt;&gt;&gt; x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,4,2,5,3,6]</span>

<span class="sd">        If `x` and `y` are multidimensional, they are flattened before use.</span>
<span class="sd">    z : array_like</span>
<span class="sd">        The values of the function to interpolate at the data points. If</span>
<span class="sd">        `z` is a multidimensional array, it is flattened before use assuming</span>
<span class="sd">        Fortran-ordering (order=&#39;F&#39;).  The length of a flattened `z` array</span>
<span class="sd">        is either len(`x`)*len(`y`) if `x` and `y` specify the column and</span>
<span class="sd">        row coordinates or ``len(z) == len(x) == len(y)`` if `x` and `y`</span>
<span class="sd">        specify coordinates for each point.</span>
<span class="sd">    kind : {&#39;linear&#39;, &#39;cubic&#39;, &#39;quintic&#39;}, optional</span>
<span class="sd">        The kind of spline interpolation to use. Default is &#39;linear&#39;.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If True, the class makes internal copies of x, y and z.</span>
<span class="sd">        If False, references may be used. The default is to copy.</span>
<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, when interpolated values are requested outside of the</span>
<span class="sd">        domain of the input data (x,y), a ValueError is raised.</span>
<span class="sd">        If False, then `fill_value` is used.</span>
<span class="sd">    fill_value : number, optional</span>
<span class="sd">        If provided, the value to use for points outside of the</span>
<span class="sd">        interpolation domain. If omitted (None), values outside</span>
<span class="sd">        the domain are extrapolated via nearest-neighbor extrapolation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        Much faster 2-D interpolation if your input data is on a grid</span>
<span class="sd">    bisplrep, bisplev :</span>
<span class="sd">        Spline interpolation based on FITPACK</span>
<span class="sd">    BivariateSpline : a more recent wrapper of the FITPACK routines</span>
<span class="sd">    interp1d : 1-D version of this function</span>
<span class="sd">    RegularGridInterpolator : interpolation on a regular or rectilinear grid</span>
<span class="sd">        in arbitrary dimensions.</span>
<span class="sd">    interpn : Multidimensional interpolation on regular grids (wraps</span>
<span class="sd">        `RegularGridInterpolator` and `RectBivariateSpline`).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The minimum number of data points required along the interpolation</span>
<span class="sd">    axis is ``(k+1)**2``, with k=1 for linear, k=3 for cubic and k=5 for</span>
<span class="sd">    quintic interpolation.</span>

<span class="sd">    The interpolator is constructed by `bisplrep`, with a smoothing factor</span>
<span class="sd">    of 0. If more control over smoothing is needed, `bisplrep` should be</span>
<span class="sd">    used directly.</span>

<span class="sd">    The coordinates of the data points to interpolate `xnew` and `ynew`</span>
<span class="sd">    have to be sorted by ascending order.</span>
<span class="sd">    `interp2d` is legacy and is not</span>
<span class="sd">    recommended for use in new code. New code should use</span>
<span class="sd">    `RegularGridInterpolator` instead.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Construct a 2-D grid and interpolate on it:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import interpolate</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-5.01, 5.01, 0.25)</span>
<span class="sd">    &gt;&gt;&gt; y = np.arange(-5.01, 5.01, 0.25)</span>
<span class="sd">    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; z = np.sin(xx**2+yy**2)</span>
<span class="sd">    &gt;&gt;&gt; f = interpolate.interp2d(x, y, z, kind=&#39;cubic&#39;)</span>

<span class="sd">    Now use the obtained interpolation function and plot the result:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; xnew = np.arange(-5.01, 5.01, 1e-2)</span>
<span class="sd">    &gt;&gt;&gt; ynew = np.arange(-5.01, 5.01, 1e-2)</span>
<span class="sd">    &gt;&gt;&gt; znew = f(xnew, ynew)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, z[0, :], &#39;ro-&#39;, xnew, znew[0, :], &#39;b-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">dep_mesg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="n">rectangular_grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rectangular_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When on a regular grid with x.size = m &quot;</span>
                                     <span class="s2">&quot;and y.size = n, if z.ndim == 2, then z &quot;</span>
                                     <span class="s2">&quot;must have shape (n, m)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;x and y must have equal lengths for non rectangular grid&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid length for input z for non rectangular grid&quot;</span><span class="p">)</span>

        <span class="n">interpolation_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;quintic&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kx</span> <span class="o">=</span> <span class="n">ky</span> <span class="o">=</span> <span class="n">interpolation_types</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported interpolation type </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="si">}</span><span class="s2">, must be &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;either of </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span><span class="w"> </span><span class="n">interpolation_types</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rectangular_grid</span><span class="p">:</span>
            <span class="c1"># TODO: surfit is really not meant for interpolation!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">_fitpack_py</span><span class="o">.</span><span class="n">bisplrep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">regrid_smth</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">kx</span><span class="o">=</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx</span><span class="p">[:</span><span class="n">nx</span><span class="p">],</span> <span class="n">ty</span><span class="p">[:</span><span class="n">ny</span><span class="p">],</span> <span class="n">c</span><span class="p">[:(</span><span class="n">nx</span> <span class="o">-</span> <span class="n">kx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="n">ky</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span>
                        <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate the function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D array</span>
<span class="sd">            x-coordinates of the mesh on which to interpolate.</span>
<span class="sd">        y : 1-D array</span>
<span class="sd">            y-coordinates of the mesh on which to interpolate.</span>
<span class="sd">        dx : int &gt;= 0, &lt; kx</span>
<span class="sd">            Order of partial derivatives in x.</span>
<span class="sd">        dy : int &gt;= 0, &lt; ky</span>
<span class="sd">            Order of partial derivatives in y.</span>
<span class="sd">        assume_sorted : bool, optional</span>
<span class="sd">            If False, values of `x` and `y` can be in any order and they are</span>
<span class="sd">            sorted first.</span>
<span class="sd">            If True, `x` and `y` have to be arrays of monotonically</span>
<span class="sd">            increasing values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z : 2-D array with shape (len(y), len(x))</span>
<span class="sd">            The interpolated values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">dep_mesg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y should both be 1-D arrays&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_sorted</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_of_bounds_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span>
            <span class="n">out_of_bounds_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)</span>

            <span class="n">any_out_of_bounds_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">out_of_bounds_x</span><span class="p">)</span>
            <span class="n">any_out_of_bounds_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">out_of_bounds_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="p">(</span><span class="n">any_out_of_bounds_x</span> <span class="ow">or</span> <span class="n">any_out_of_bounds_y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Values out of range; x must be in </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;y in </span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">_fitpack_py</span><span class="o">.</span><span class="n">bisplev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">any_out_of_bounds_x</span><span class="p">:</span>
                <span class="n">z</span><span class="p">[:,</span> <span class="n">out_of_bounds_x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="k">if</span> <span class="n">any_out_of_bounds_y</span><span class="p">:</span>
                <span class="n">z</span><span class="p">[</span><span class="n">out_of_bounds_y</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_broadcast_up_to</span><span class="p">(</span><span class="n">arr_from</span><span class="p">,</span> <span class="n">shape_to</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to check that arr_from broadcasts up to shape_to&quot;&quot;&quot;</span>
    <span class="n">shape_from</span> <span class="o">=</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_to</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_from</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape_to</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape_from</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># all checks pass, do the upcasting that we need later</span>
            <span class="k">if</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_to</span><span class="p">:</span>
                <span class="n">arr_from</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape_to</span><span class="p">,</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr_from</span>
            <span class="k">return</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="c1"># at least one check failed</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> argument must be able to broadcast up &#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;to shape </span><span class="si">{</span><span class="n">shape_to</span><span class="si">}</span><span class="s1"> but had shape </span><span class="si">{</span><span class="n">shape_from</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to check if fill_value == &quot;extrapolate&quot; without warnings&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">fill_value</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="interp1d">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d">[docs]</a>
<span class="k">class</span> <span class="nc">interp1d</span><span class="p">(</span><span class="n">_Interpolator1D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate a 1-D function.</span>

<span class="sd">    .. legacy:: class</span>

<span class="sd">        For a guide to the intended replacements for `interp1d` see</span>
<span class="sd">        :ref:`tutorial-interpolate_1Dsection`.</span>

<span class="sd">    `x` and `y` are arrays of values used to approximate some function f:</span>
<span class="sd">    ``y = f(x)``. This class returns a function whose call method uses</span>
<span class="sd">    interpolation to find the value of new points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (npoints, ) array_like</span>
<span class="sd">        A 1-D array of real values.</span>
<span class="sd">    y : (..., npoints, ...) array_like</span>
<span class="sd">        A N-D array of real values. The length of `y` along the interpolation</span>
<span class="sd">        axis must be equal to the length of `x`. Use the ``axis`` parameter</span>
<span class="sd">        to select correct axis. Unlike other interpolators, the default</span>
<span class="sd">        interpolation axis is the last axis of `y`.</span>
<span class="sd">    kind : str or int, optional</span>
<span class="sd">        Specifies the kind of interpolation as a string or as an integer</span>
<span class="sd">        specifying the order of the spline interpolator to use.</span>
<span class="sd">        The string has to be one of &#39;linear&#39;, &#39;nearest&#39;, &#39;nearest-up&#39;, &#39;zero&#39;,</span>
<span class="sd">        &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;, or &#39;next&#39;. &#39;zero&#39;,</span>
<span class="sd">        &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39; refer to a spline interpolation of</span>
<span class="sd">        zeroth, first, second or third order; &#39;previous&#39; and &#39;next&#39; simply</span>
<span class="sd">        return the previous or next value of the point; &#39;nearest-up&#39; and</span>
<span class="sd">        &#39;nearest&#39; differ when interpolating half-integers (e.g. 0.5, 1.5)</span>
<span class="sd">        in that &#39;nearest-up&#39; rounds up and &#39;nearest&#39; rounds down. Default</span>
<span class="sd">        is &#39;linear&#39;.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis in the ``y`` array corresponding to the x-coordinate values. Unlike</span>
<span class="sd">        other interpolators, defaults to ``axis=-1``.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If True, the class makes internal copies of x and y.</span>
<span class="sd">        If False, references to `x` and `y` are used. The default is to copy.</span>
<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, a ValueError is raised any time interpolation is attempted on</span>
<span class="sd">        a value outside of the range of x (where extrapolation is</span>
<span class="sd">        necessary). If False, out of bounds values are assigned `fill_value`.</span>
<span class="sd">        By default, an error is raised unless ``fill_value=&quot;extrapolate&quot;``.</span>
<span class="sd">    fill_value : array-like or (array-like, array_like) or &quot;extrapolate&quot;, optional</span>
<span class="sd">        - if a ndarray (or float), this value will be used to fill in for</span>
<span class="sd">          requested points outside of the data range. If not provided, then</span>
<span class="sd">          the default is NaN. The array-like must broadcast properly to the</span>
<span class="sd">          dimensions of the non-interpolation axes.</span>
<span class="sd">        - If a two-element tuple, then the first element is used as a</span>
<span class="sd">          fill value for ``x_new &lt; x[0]`` and the second element is used for</span>
<span class="sd">          ``x_new &gt; x[-1]``. Anything that is not a 2-element tuple (e.g.,</span>
<span class="sd">          list or ndarray, regardless of shape) is taken to be a single</span>
<span class="sd">          array-like argument meant to be used for both bounds as</span>
<span class="sd">          ``below, above = fill_value, fill_value``. Using a two-element tuple</span>
<span class="sd">          or ndarray requires ``bounds_error=False``.</span>

<span class="sd">          .. versionadded:: 0.17.0</span>
<span class="sd">        - If &quot;extrapolate&quot;, then points outside the data range will be</span>
<span class="sd">          extrapolated.</span>

<span class="sd">          .. versionadded:: 0.17.0</span>
<span class="sd">    assume_sorted : bool, optional</span>
<span class="sd">        If False, values of `x` can be in any order and they are sorted first.</span>
<span class="sd">        If True, `x` has to be an array of monotonically increasing values.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fill_value</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    splrep, splev</span>
<span class="sd">        Spline interpolation/smoothing based on FITPACK.</span>
<span class="sd">    UnivariateSpline : An object-oriented wrapper of the FITPACK routines.</span>
<span class="sd">    interp2d : 2-D interpolation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Calling `interp1d` with NaNs present in input values results in</span>
<span class="sd">    undefined behaviour.</span>

<span class="sd">    Input values `x` and `y` must be convertible to `float` values like</span>
<span class="sd">    `int` or `float`.</span>

<span class="sd">    If the values in `x` are not unique, the resulting behavior is</span>
<span class="sd">    undefined and specific to the choice of `kind`, i.e., changing</span>
<span class="sd">    `kind` will change the behavior for duplicates.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy import interpolate</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(0, 10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.exp(-x/3.0)</span>
<span class="sd">    &gt;&gt;&gt; f = interpolate.interp1d(x, y)</span>

<span class="sd">    &gt;&gt;&gt; xnew = np.arange(0, 9, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d`</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;, xnew, ynew, &#39;-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="interp1d.__init__">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                 <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize a 1-D linear interpolation class.&quot;&quot;&quot;</span>
        <span class="n">_Interpolator1D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>  <span class="c1"># used by fill_value setter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">]:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;zero&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}[</span><span class="n">kind</span><span class="p">]</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;spline&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">kind</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;spline&#39;</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest-up&#39;</span><span class="p">,</span> <span class="s1">&#39;previous&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;next&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is unsupported: Use fitpack &quot;</span>
                                      <span class="s2">&quot;routines for other types.&quot;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_sorted</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the x array must have exactly one dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the y array must have at least one dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Force-cast y to a floating-point type, if it&#39;s not yet one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Backward compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Interpolation goes internally along the first axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_yi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">del</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>  <span class="c1"># clean up namespace to prevent misuse; use attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">=</span> <span class="n">kind</span>

        <span class="c1"># Adjust to interpolation kind; store reference to *unbound*</span>
        <span class="c1"># interpolation methods, in order to avoid circular references to self</span>
        <span class="c1"># stored in the bound instance methods, and therefore delayed garbage</span>
        <span class="c1"># collection.  See: https://docs.python.org/reference/datamodel.html</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest-up&#39;</span><span class="p">,</span> <span class="s1">&#39;previous&#39;</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">):</span>
            <span class="c1"># Make a &quot;view&quot; of the y array that is rotated to the interpolation</span>
            <span class="c1"># axis.</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                <span class="c1"># Do division before addition to prevent possible integer</span>
                <span class="c1"># overflow</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nearest</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest-up&#39;</span><span class="p">:</span>
                <span class="c1"># Do division before addition to prevent possible integer</span>
                <span class="c1"># overflow</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nearest</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;previous&#39;</span><span class="p">:</span>
                <span class="c1"># Side for np.searchsorted and index for clipping</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Move x by one floating point value to the left</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_previousnext</span>
                <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_update_bounds_error_for_extrapolation</span><span class="p">()</span>
                    <span class="c1"># assume y is sorted by x ascending order here.</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;next&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ind</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># Move x by one floating point value to the right</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_previousnext</span>
                <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_update_bounds_error_for_extrapolation</span><span class="p">()</span>
                    <span class="c1"># assume y is sorted by x ascending order here.</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if we can delegate to numpy.interp (2x-10x faster).</span>
                <span class="n">np_dtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">np_dtypes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">np_dtypes</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_linear_np</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Quadratic or cubic spline. If input contains even a single</span>
                <span class="c1"># nan, then the output is all nans. We cannot just feed data</span>
                <span class="c1"># with nans to make_interp_spline because it calls LAPACK.</span>
                <span class="c1"># So, we make up a bogus x and y with no nans and use it</span>
                <span class="c1"># to get the correct shape of the output, which we then fill</span>
                <span class="c1"># with nans.</span>
                <span class="c1"># For slinear or zero order spline, we just pass nans through.</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">sx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">sx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` array is all-nan&quot;</span><span class="p">)</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
                    <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
                    <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span> <span class="o">=</span> <span class="n">make_interp_spline</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                                              <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rewrite_nan</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nan_spline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_spline</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minval</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y arrays must have at &quot;</span>
                             <span class="s2">&quot;least </span><span class="si">%d</span><span class="s2"> entries&quot;</span> <span class="o">%</span> <span class="n">minval</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>  <span class="c1"># calls the setter, can modify bounds_err</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The fill value.&quot;&quot;&quot;</span>
        <span class="c1"># backwards compat: mimic a public attribute</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_orig</span>

    <span class="nd">@fill_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="c1"># extrapolation only works for nearest neighbor and linear methods</span>
        <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_update_bounds_error_for_extrapolation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="c1"># it&#39;s either a pair (_below_range, _above_range) or a single value</span>
            <span class="c1"># for both above and below range</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">below_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;fill_value (below)&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value (above)&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">below_above</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">_check_broadcast_up_to</span><span class="p">(</span>
                        <span class="n">below_above</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                <span class="n">below_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">_check_broadcast_up_to</span><span class="p">(</span>
                    <span class="n">fill_value</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_below</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_above</span> <span class="o">=</span> <span class="n">below_above</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># backwards compat: fill_value was a public attr; make it writeable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_orig</span> <span class="o">=</span> <span class="n">fill_value</span>

<div class="viewcode-block" id="interp1d._check_and_update_bounds_error_for_extrapolation">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._check_and_update_bounds_error_for_extrapolation">[docs]</a>
    <span class="k">def</span> <span class="nf">_check_and_update_bounds_error_for_extrapolation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot extrapolate and raise &quot;</span>
                             <span class="s2">&quot;at the same time.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="interp1d._call_linear_np">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._call_linear_np">[docs]</a>
    <span class="k">def</span> <span class="nf">_call_linear_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># Note that out-of-bounds values are taken care of in self._evaluate</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp1d._call_linear">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._call_linear">[docs]</a>
    <span class="k">def</span> <span class="nf">_call_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># 2. Find where in the original data, the values to interpolate</span>
        <span class="c1">#    would be inserted.</span>
        <span class="c1">#    Note: If x_new[n] == x[m], then m is returned by searchsorted.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span>

        <span class="c1"># 3. Clip x_new_indices so that they are within the range of</span>
        <span class="c1">#    self.x indices and at least 1. Removes mis-interpolation</span>
        <span class="c1">#    of x_new[n] = x[0]</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># 4. Calculate the slope of regions that each x_new value falls in.</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">x_new_indices</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">x_new_indices</span>

        <span class="n">x_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span>
        <span class="n">x_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>
        <span class="n">y_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span>
        <span class="n">y_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>

        <span class="c1"># Note that the following two expressions rely on the specifics of the</span>
        <span class="c1"># broadcasting semantics.</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_hi</span> <span class="o">-</span> <span class="n">y_lo</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_hi</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># 5. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">slope</span><span class="o">*</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_lo</span>

        <span class="k">return</span> <span class="n">y_new</span></div>


<div class="viewcode-block" id="interp1d._call_nearest">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._call_nearest">[docs]</a>
    <span class="k">def</span> <span class="nf">_call_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Find nearest neighbor interpolated y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="c1"># 2. Find where in the averaged data the values to interpolate</span>
        <span class="c1">#    would be inserted.</span>
        <span class="c1">#    Note: use side=&#39;left&#39; (right) to searchsorted() to define the</span>
        <span class="c1">#    halfway point to be nearest to the left (right) neighbor</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_side</span><span class="p">)</span>

        <span class="c1"># 3. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

        <span class="c1"># 4. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">x_new_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_new</span></div>


<div class="viewcode-block" id="interp1d._call_previousnext">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._call_previousnext">[docs]</a>
    <span class="k">def</span> <span class="nf">_call_previousnext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use previous/next neighbor of x_new, y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="c1"># 1. Get index of left/right value</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_shift</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_side</span><span class="p">)</span>

        <span class="c1"># 2. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ind</span><span class="p">,</span>
                                           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ind</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

        <span class="c1"># 3. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">x_new_indices</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_new</span></div>


<div class="viewcode-block" id="interp1d._call_spline">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._call_spline">[docs]</a>
    <span class="k">def</span> <span class="nf">_call_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span></div>


<div class="viewcode-block" id="interp1d._call_nan_spline">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._call_nan_spline">[docs]</a>
    <span class="k">def</span> <span class="nf">_call_nan_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="interp1d._evaluate">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._evaluate">[docs]</a>
    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># 1. Handle values in x_new that are outside of x. Throw error,</span>
        <span class="c1">#    or return a list of mask array indicating the outofbounds values.</span>
        <span class="c1">#    The behavior is set by the bounds_error variable.</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span><span class="p">:</span>
            <span class="n">below_bounds</span><span class="p">,</span> <span class="n">above_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_bounds</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Note fill_value must be broadcast up to the proper size</span>
                <span class="c1"># and flattened to work here</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_below</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_above</span>
        <span class="k">return</span> <span class="n">y_new</span></div>


<div class="viewcode-block" id="interp1d._check_bounds">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.tidalhours.interp1d._check_bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check the inputs for being in the bounds of the interpolated data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_new : array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_of_bounds : bool array</span>
<span class="sd">            The mask on x_new of values that are out of the bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If self.bounds_error is True, we raise an error if any x_new values</span>
        <span class="c1"># fall outside the range of x. Otherwise, we return an array indicating</span>
        <span class="c1"># which values are outside the boundary region.</span>
        <span class="n">below_bounds</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">above_bounds</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">below_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">below_bounds_value</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">below_bounds</span><span class="p">)]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A value (</span><span class="si">{</span><span class="n">below_bounds_value</span><span class="si">}</span><span class="s2">) in x_new is below &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;the interpolation range&#39;s minimum value (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">above_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">above_bounds_value</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">above_bounds</span><span class="p">)]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A value (</span><span class="si">{</span><span class="n">above_bounds_value</span><span class="si">}</span><span class="s2">) in x_new is above &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;the interpolation range&#39;s maximum value (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="c1"># !! Should we emit a warning if some values are out of bounds?</span>
        <span class="c1"># !! matlab does not.</span>
        <span class="k">return</span> <span class="n">below_bounds</span><span class="p">,</span> <span class="n">above_bounds</span></div>
</div>



<span class="k">class</span> <span class="nc">_PPolyBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for piecewise polynomials.&quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">extrapolate</span> <span class="o">!=</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coefficients array must be at least &quot;</span>
                             <span class="s2">&quot;2-dimensional.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> must be between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># move the interpolation axis to be the first one in self.c</span>
            <span class="c1"># More specifically, the target shape for self.c is (k, m, ...),</span>
            <span class="c1"># and axis !=0 means that we have c.shape (..., k, m, ...)</span>
            <span class="c1">#                                               ^</span>
            <span class="c1">#                                              axis</span>
            <span class="c1"># So we roll two of them.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least 2 breakpoints are needed&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c must have at least 2 dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polynomial must be at least of order 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of coefficients != len(x)-1&quot;</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must be strictly increasing or decreasing.&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> \
               <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the piecewise polynomial without making checks.</span>

<span class="sd">        Takes the same parameters as the constructor. Input arguments</span>
<span class="sd">        ``c`` and ``x`` must be arrays of the correct shape and type. The</span>
<span class="sd">        ``c`` array can only be of dtypes float and complex, and ``x``</span>
<span class="sd">        array must have dtype float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_ensure_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        c and x may be modified by the user. The Cython code expects</span>
<span class="sd">        that they are C contiguous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add additional breakpoints and coefficients to the polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : ndarray, size (k, m, ...)</span>
<span class="sd">            Additional coefficients for polynomials in intervals. Note that</span>
<span class="sd">            the first additional interval will be formed using one of the</span>
<span class="sd">            ``self.x`` end points.</span>
<span class="sd">        x : ndarray, size (m,)</span>
<span class="sd">            Additional breakpoints. Must be sorted in the same order as</span>
<span class="sd">            ``self.x`` and either to the right or to the left of the current</span>
<span class="sd">            breakpoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for c&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for x&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shapes of x </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and c </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> are incompatible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shapes of c </span><span class="si">{}</span><span class="s2"> and self.c </span><span class="si">{}</span><span class="s2"> are incompatible&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is not sorted.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is in the different order &quot;</span>
                                 <span class="s2">&quot;than `self.x`.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;prepend&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s2">&quot;from `self.x`.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is in the different order &quot;</span>
                                 <span class="s2">&quot;than `self.x`.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;prepend&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s2">&quot;from `self.x`.&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">k2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;append&#39;</span><span class="p">:</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;prepend&#39;</span><span class="p">:</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the piecewise polynomial or its derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points to evaluate the interpolant at.</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Must be non-negative.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used.</span>
<span class="sd">            If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array_like</span>
<span class="sd">            Interpolated values. Shape is determined by replacing</span>
<span class="sd">            the interpolation axis in the original array with the shape of x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_shape</span><span class="p">,</span> <span class="n">x_ndim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># With periodic extrapolation we map x to the segment</span>
        <span class="c1"># [self.x[0], self.x[-1]].</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># transpose to move the calculated values to the interpolation axis</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">x_ndim</span><span class="p">:</span><span class="n">x_ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[:</span><span class="n">x_ndim</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">x_ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">:]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">PPoly</span><span class="p">(</span><span class="n">_PPolyBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Piecewise polynomial in terms of coefficients and breakpoints</span>

<span class="sd">    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the</span>
<span class="sd">    local power basis::</span>

<span class="sd">        S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1))</span>

<span class="sd">    where ``k`` is the degree of the polynomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k, m, ...)</span>
<span class="sd">        Polynomial coefficients, order `k` and `m` intervals.</span>
<span class="sd">    x : ndarray, shape (m+1,)</span>
<span class="sd">        Polynomial breakpoints. Must be sorted in either increasing or</span>
<span class="sd">        decreasing order.</span>
<span class="sd">    extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">        If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">        based on first and last intervals, or to return NaNs. If &#39;periodic&#39;,</span>
<span class="sd">        periodic extrapolation is used. Default is True.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Interpolation axis. Default is zero.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials. They are reshaped</span>
<span class="sd">        to a 3-D array with the last dimension representing</span>
<span class="sd">        the trailing dimensions of the original coefficient array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Interpolation axis.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    solve</span>
<span class="sd">    roots</span>
<span class="sd">    extend</span>
<span class="sd">    from_spline</span>
<span class="sd">    from_bernstein_basis</span>
<span class="sd">    construct_fast</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    BPoly : piecewise polynomials in the Bernstein basis</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    High-order polynomials in the power basis can be numerically</span>
<span class="sd">    unstable. Precision problems can start to appear for orders</span>
<span class="sd">    larger than 20-30.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default is 1, i.e., compute the</span>
<span class="sd">            first derivative. If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k - n representing the derivative</span>
<span class="sd">            of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># multiply by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Antiderivative is also the indefinite integral of the function,</span>
<span class="sd">        and derivative is its inverse operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default is 1, i.e., compute</span>
<span class="sd">            the first integral. If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k + n representing</span>
<span class="sd">            the antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The antiderivative returned by this function is continuous and</span>
<span class="sd">        continuously differentiable to order n-1, up to floating point</span>
<span class="sd">        rounding error.</span>

<span class="sd">        If antiderivative is computed and ``self.extrapolate=&#39;periodic&#39;``,</span>
<span class="sd">        it will be set to False for the returned instance. This is done because</span>
<span class="sd">        the antiderivative is no longer periodic and its correct evaluation</span>
<span class="sd">        outside of the initially given x interval is difficult.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>

        <span class="c1"># divide by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># fix continuity of added degrees of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">fix_continuity</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower integration bound</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper integration bound</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used.</span>
<span class="sd">            If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># Swap integration bounds if needed</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">range_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="c1"># Compute the integral.</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="c1"># Split the integral into the part over period (can be several</span>
            <span class="c1"># of them) and the remaining part.</span>

            <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
            <span class="n">n_periods</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">range_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">*=</span> <span class="n">n_periods</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">range_int</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Map a to [xs, xe], b is always a + left.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">left</span>

            <span class="c1"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="c1"># over [a, xe] and from xs to what is remained.</span>
            <span class="n">remainder_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">range_int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">xe</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>

                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">range_int</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="n">range_int</span> <span class="o">*=</span> <span class="n">sign</span>
        <span class="k">return</span> <span class="n">range_int</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find real solutions of the equation ``pp(x) == y``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float, optional</span>
<span class="sd">            Right-hand side. Default is zero.</span>
<span class="sd">        discontinuity : bool, optional</span>
<span class="sd">            Whether to report sign changes across discontinuities at</span>
<span class="sd">            breakpoints as roots.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to return roots from the polynomial</span>
<span class="sd">            extrapolated based on first and last intervals, &#39;periodic&#39; works</span>
<span class="sd">            the same as False. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : ndarray</span>
<span class="sd">            Roots of the polynomial(s).</span>

<span class="sd">            If the PPoly object describes multiple polynomials, the</span>
<span class="sd">            return value is an object array whose each element is an</span>
<span class="sd">            ndarray containing the roots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine works only on real-valued polynomials.</span>

<span class="sd">        If the piecewise polynomial contains sections that are</span>
<span class="sd">        identically zero, the root list will contain the start point</span>
<span class="sd">        of the corresponding interval, followed by a ``nan`` value.</span>

<span class="sd">        If the polynomial is discontinuous across a breakpoint, and</span>
<span class="sd">        there is a sign change across the breakpoint, this is reported</span>
<span class="sd">        if the `discont` parameter is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Finding roots of ``[x**2 - 1, (x - 1)**2]`` defined on intervals</span>
<span class="sd">        ``[-2, 1], [1, 2]``:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import PPoly</span>
<span class="sd">        &gt;&gt;&gt; pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; pp.solve()</span>
<span class="sd">        array([-1.,  1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Root finding is only for &quot;</span>
                             <span class="s2">&quot;real-valued polynomials&quot;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_ppoly</span><span class="o">.</span><span class="n">real_roots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">discontinuity</span><span class="p">),</span>
                              <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="c1"># this for-loop is equivalent to ``r2[...] = r``, but that&#39;s broken</span>
            <span class="c1"># in NumPy 1.6.0</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>

            <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find real roots of the piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        discontinuity : bool, optional</span>
<span class="sd">            Whether to report sign changes across discontinuities at</span>
<span class="sd">            breakpoints as roots.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to return roots from the polynomial</span>
<span class="sd">            extrapolated based on first and last intervals, &#39;periodic&#39; works</span>
<span class="sd">            the same as False. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : ndarray</span>
<span class="sd">            Roots of the polynomial(s).</span>

<span class="sd">            If the PPoly object describes multiple polynomials, the</span>
<span class="sd">            return value is an object array whose each element is an</span>
<span class="sd">            ndarray containing the roots.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PPoly.solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">discontinuity</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_spline</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tck</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial from a spline</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tck</span>
<span class="sd">            A spline, as returned by `splrep` or a BSpline object.</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Construct an interpolating spline and convert it to a `PPoly` instance </span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import splrep, PPoly</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(0, 1, 11)</span>
<span class="sd">        &gt;&gt;&gt; y = np.sin(2*np.pi*x)</span>
<span class="sd">        &gt;&gt;&gt; tck = splrep(x, y, s=0)</span>
<span class="sd">        &gt;&gt;&gt; p = PPoly.from_spline(tck)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(p, PPoly)</span>
<span class="sd">        True</span>

<span class="sd">        Note that this function only supports 1D splines out of the box.</span>

<span class="sd">        If the ``tck`` object represents a parametric spline (e.g. constructed</span>
<span class="sd">        by `splprep` or a `BSpline` with ``c.ndim &gt; 1``), you will need to loop</span>
<span class="sd">        over the dimensions manually.</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import splprep, splev</span>
<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 1, 11)</span>
<span class="sd">        &gt;&gt;&gt; x = np.sin(2*np.pi*t)</span>
<span class="sd">        &gt;&gt;&gt; y = np.cos(2*np.pi*t)</span>
<span class="sd">        &gt;&gt;&gt; (t, c, k), u = splprep([x, y], s=0)</span>

<span class="sd">        Note that ``c`` is a list of two arrays of length 11.</span>

<span class="sd">        &gt;&gt;&gt; unew = np.arange(0, 1.01, 0.01)</span>
<span class="sd">        &gt;&gt;&gt; out = splev(unew, (t, c, k))</span>

<span class="sd">        To convert this spline to the power basis, we convert each</span>
<span class="sd">        component of the list of b-spline coefficients, ``c``, into the</span>
<span class="sd">        corresponding cubic polynomial.</span>

<span class="sd">        &gt;&gt;&gt; polys = [PPoly.from_spline((t, cj, k)) for cj in c]</span>
<span class="sd">        &gt;&gt;&gt; polys[0].c.shape</span>
<span class="sd">        (4, 14)</span>

<span class="sd">        Note that the coefficients of the polynomials `polys` are in the</span>
<span class="sd">        power basis and their dimensions reflect just that: here 4 is the order</span>
<span class="sd">        (degree+1), and 14 is the number of intervals---which is nothing but</span>
<span class="sd">        the length of the knot array of the original `tck` minus one.</span>

<span class="sd">        Optionally, we can stack the components into a single `PPoly` along</span>
<span class="sd">        the third dimension:</span>

<span class="sd">        &gt;&gt;&gt; cc = np.dstack([p.c for p in polys])    # has shape = (4, 14, 2)</span>
<span class="sd">        &gt;&gt;&gt; poly = PPoly(cc, polys[0].x)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(poly(unew).T,     # note the transpose to match `splev`</span>
<span class="sd">        ...             out, atol=1e-15)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tck</span><span class="p">,</span> <span class="n">BSpline</span><span class="p">):</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">tck</span>
            <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span>

        <span class="n">cvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_fitpack_py</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tck</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="n">cvals</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">spec</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">cvals</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bernstein_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial in the power basis</span>
<span class="sd">        from a polynomial in Bernstein basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            A Bernstein basis polynomial, as created by BPoly</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BPoly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;.from_bernstein_basis only accepts BPoly instances. &quot;</span>
                            <span class="s2">&quot;Got </span><span class="si">%s</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># polynomial order</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">a</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">s</span>
                <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">val</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span><span class="o">**</span><span class="n">s</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BPoly</span><span class="p">(</span><span class="n">_PPolyBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Piecewise polynomial in terms of coefficients and breakpoints.</span>

<span class="sd">    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the</span>
<span class="sd">    Bernstein polynomial basis::</span>

<span class="sd">        S = sum(c[a, i] * b(a, k; x) for a in range(k+1)),</span>

<span class="sd">    where ``k`` is the degree of the polynomial, and::</span>

<span class="sd">        b(a, k; x) = binom(k, a) * t**a * (1 - t)**(k - a),</span>

<span class="sd">    with ``t = (x - x[i]) / (x[i+1] - x[i])`` and ``binom`` is the binomial</span>
<span class="sd">    coefficient.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k, m, ...)</span>
<span class="sd">        Polynomial coefficients, order `k` and `m` intervals</span>
<span class="sd">    x : ndarray, shape (m+1,)</span>
<span class="sd">        Polynomial breakpoints. Must be sorted in either increasing or</span>
<span class="sd">        decreasing order.</span>
<span class="sd">    extrapolate : bool, optional</span>
<span class="sd">        If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">        based on first and last intervals, or to return NaNs. If &#39;periodic&#39;,</span>
<span class="sd">        periodic extrapolation is used. Default is True.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Interpolation axis. Default is zero.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials. They are reshaped</span>
<span class="sd">        to a 3-D array with the last dimension representing</span>
<span class="sd">        the trailing dimensions of the original coefficient array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Interpolation axis.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    extend</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    construct_fast</span>
<span class="sd">    from_power_basis</span>
<span class="sd">    from_derivatives</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    PPoly : piecewise polynomials in the power basis</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Properties of Bernstein polynomials are well documented in the literature,</span>
<span class="sd">    see for example [1]_ [2]_ [3]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Bernstein_polynomial</span>

<span class="sd">    .. [2] Kenneth I. Joy, Bernstein polynomials,</span>
<span class="sd">       http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf</span>

<span class="sd">    .. [3] E. H. Doha, A. H. Bhrawy, and M. A. Saker, Boundary Value Problems,</span>
<span class="sd">           vol 2011, article ID 829546, :doi:`10.1155/2011/829543`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import BPoly</span>
<span class="sd">    &gt;&gt;&gt; x = [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; c = [[1], [2], [3]]</span>
<span class="sd">    &gt;&gt;&gt; bp = BPoly(c, x)</span>

<span class="sd">    This creates a 2nd order polynomial</span>

<span class="sd">    .. math::</span>

<span class="sd">        B(x) = 1 \\times b_{0, 2}(x) + 2 \\times b_{1, 2}(x) + 3</span>
<span class="sd">               \\times b_{2, 2}(x) \\\\</span>
<span class="sd">             = 1 \\times (1-x)^2 + 2 \\times 2 x (1 - x) + 3 \\times x^2</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate_bernstein</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default is 1, i.e., compute the</span>
<span class="sd">            first derivative. If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            Piecewise polynomial of order k - nu representing the derivative of</span>
<span class="sd">            this polynomial.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
                <span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bp</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For a polynomial</span>
            <span class="c1">#    B(x) = \sum_{a=0}^{k} c_a b_{a, k}(x),</span>
            <span class="c1"># we use the fact that</span>
            <span class="c1">#   b&#39;_{a, k} = k ( b_{a-1, k-1} - b_{a, k-1} ),</span>
            <span class="c1"># which leads to</span>
            <span class="c1">#   B&#39;(x) = \sum_{a=0}^{k-1} (c_{a+1} - c_a) b_{a, k-1}</span>
            <span class="c1">#</span>
            <span class="c1"># finally, for an interval [y, y + dy] with dy != 1,</span>
            <span class="c1"># we need to correct for an extra power of dy</span>

            <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)[(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default is 1, i.e., compute</span>
<span class="sd">            the first integral. If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            Piecewise polynomial of order k + nu representing the</span>
<span class="sd">            antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If antiderivative is computed and ``self.extrapolate=&#39;periodic&#39;``,</span>
<span class="sd">        it will be set to False for the returned instance. This is done because</span>
<span class="sd">        the antiderivative is no longer periodic and its correct evaluation</span>
<span class="sd">        outside of the initially given x interval is difficult.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
                <span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bp</span>

        <span class="c1"># Construct the indefinite integrals on individual intervals</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">delta</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Now fix continuity: on the very first interval, take the integration</span>
        <span class="c1"># constant to be zero; on an interval [x_j, x_{j+1}) with j&gt;0,</span>
        <span class="c1"># the integration constant is then equal to the jump of the `bp` at x_j.</span>
        <span class="c1"># The latter is given by the coefficient of B_{n+1, n+1}</span>
        <span class="c1"># *on the previous interval* (other B. polynomials are zero at the</span>
        <span class="c1"># breakpoint). Finally, use the fact that BPs form a partition of unity.</span>
        <span class="n">c2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c2</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower integration bound</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper integration bound</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs. If &#39;periodic&#39;, periodic</span>
<span class="sd">            extrapolation is used. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: can probably use instead the fact that</span>
        <span class="c1"># \int_0^{1} B_{j, n}(x) \dx = 1/(n+1)</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># ib.extrapolate shouldn&#39;t be &#39;periodic&#39;, it is converted to</span>
        <span class="c1"># False for &#39;periodic. in antiderivative() call.</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">!=</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">ib</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="c1"># Split the integral into the part over period (can be several</span>
            <span class="c1"># of them) and the remaining part.</span>

            <span class="c1"># For simplicity and clarity convert to a &lt;= b case.</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
            <span class="n">n_periods</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">n_periods</span> <span class="o">*</span> <span class="p">(</span><span class="n">ib</span><span class="p">(</span><span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

            <span class="c1"># Map a and b to [xs, xe].</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">left</span>

            <span class="c1"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="c1"># over [a, xe] and from xs to what is remained.</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">xe</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">ib</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">ib</span><span class="p">(</span><span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ib</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_PPolyBase</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">extend</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_PPolyBase</span><span class="o">.</span><span class="n">extend</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_power_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial in Bernstein basis</span>
<span class="sd">        from a power basis polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            A piecewise polynomial in the power basis</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">PPoly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;.from_power_basis only accepts PPoly instances. &quot;</span>
                            <span class="s2">&quot;Got </span><span class="si">%s</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">pp</span><span class="p">))</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># polynomial order</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_derivatives</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a piecewise polynomial in the Bernstein basis,</span>
<span class="sd">        compatible with the specified values and derivatives at breakpoints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : array_like</span>
<span class="sd">            sorted 1-D array of x-coordinates</span>
<span class="sd">        yi : array_like or list of array_likes</span>
<span class="sd">            ``yi[i][j]`` is the ``j``\\ th derivative known at ``xi[i]``</span>
<span class="sd">        orders : None or int or array_like of ints. Default: None.</span>
<span class="sd">            Specifies the degree of local polynomials. If not None, some</span>
<span class="sd">            derivatives are ignored.</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``k`` derivatives are specified at a breakpoint ``x``, the</span>
<span class="sd">        constructed polynomial is exactly ``k`` times continuously</span>
<span class="sd">        differentiable at ``x``, unless the ``order`` is provided explicitly.</span>
<span class="sd">        In the latter case, the smoothness of the polynomial at</span>
<span class="sd">        the breakpoint is controlled by the ``order``.</span>

<span class="sd">        Deduces the number of derivatives to match at each end</span>
<span class="sd">        from ``order`` and the number of derivatives available. If</span>
<span class="sd">        possible it uses the same number of derivatives from</span>
<span class="sd">        each end; if the number is odd it tries to take the</span>
<span class="sd">        extra one from y2. In any case if not enough derivatives</span>
<span class="sd">        are available at one end or another it draws enough to</span>
<span class="sd">        make up the total from the other end.</span>

<span class="sd">        If the order is too high and not enough derivatives are available,</span>
<span class="sd">        an exception is raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import BPoly</span>
<span class="sd">        &gt;&gt;&gt; BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])</span>

<span class="sd">        Creates a polynomial `f(x)` of degree 3, defined on `[0, 1]`</span>
<span class="sd">        such that `f(0) = 1, df/dx(0) = 2, f(1) = 3, df/dx(1) = 4`</span>

<span class="sd">        &gt;&gt;&gt; BPoly.from_derivatives([0, 1, 2], [[0, 1], [0], [2]])</span>

<span class="sd">        Creates a piecewise polynomial `f(x)`, such that</span>
<span class="sd">        `f(0) = f(1) = 0`, `f(2) = 2`, and `df/dx(0) = 1`.</span>
<span class="sd">        Based on the number of derivatives provided, the order of the</span>
<span class="sd">        local polynomials is 2 on `[0, 1]` and 1 on `[1, 2]`.</span>
<span class="sd">        Notice that no restriction is imposed on the derivatives at</span>
<span class="sd">        ``x = 1`` and ``x = 2``.</span>

<span class="sd">        Indeed, the explicit form of the polynomial is::</span>

<span class="sd">            f(x) = | x * (1 - x),  0 &lt;= x &lt; 1</span>
<span class="sd">                   | 2 * (x - 1),  1 &lt;= x &lt;= 2</span>

<span class="sd">        So that f&#39;(1-0) = -1 and f&#39;(1+0) = 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xi and yi need to have the same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x coordinates are not in increasing order&quot;</span><span class="p">)</span>

        <span class="c1"># number of intervals</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># global poly order is k-1, local orders are &lt;=k and can vary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Using a 1-D array for y? Please .reshape(-1, 1).&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">if</span> <span class="n">orders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">orders</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">orders</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">o</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Orders must be positive.&quot;</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">n1</span><span class="o">+</span><span class="n">n2</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">mesg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Point </span><span class="si">%g</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> derivatives, point </span><span class="si">%g</span><span class="s2">&quot;</span>
                            <span class="s2">&quot; has </span><span class="si">%d</span><span class="s2"> derivatives, but order </span><span class="si">%d</span><span class="s2"> requested&quot;</span> <span class="o">%</span> <span class="p">(</span>
                               <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">),</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">mesg</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`order` input incompatible with&quot;</span>
                                     <span class="s2">&quot; length y1 or y2.&quot;</span><span class="p">)</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">_construct_from_derivatives</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="n">y1</span><span class="p">[:</span><span class="n">n1</span><span class="p">],</span> <span class="n">y2</span><span class="p">[:</span><span class="n">n2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">xi</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_from_derivatives</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the coefficients of a polynomial in the Bernstein basis</span>
<span class="sd">        given the values and derivatives at the edges.</span>

<span class="sd">        Return the coefficients of a polynomial in the Bernstein basis</span>
<span class="sd">        defined on ``[xa, xb]`` and having the values and derivatives at the</span>
<span class="sd">        endpoints `xa` and `xb` as specified by `ya` and `yb`.</span>
<span class="sd">        The polynomial constructed is of the minimal possible degree, i.e.,</span>
<span class="sd">        if the lengths of `ya` and `yb` are `na` and `nb`, the degree</span>
<span class="sd">        of the polynomial is ``na + nb - 1``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa : float</span>
<span class="sd">            Left-hand end point of the interval</span>
<span class="sd">        xb : float</span>
<span class="sd">            Right-hand end point of the interval</span>
<span class="sd">        ya : array_like</span>
<span class="sd">            Derivatives at `xa`. ``ya[0]`` is the value of the function, and</span>
<span class="sd">            ``ya[i]`` for ``i &gt; 0`` is the value of the ``i``\ th derivative.</span>
<span class="sd">        yb : array_like</span>
<span class="sd">            Derivatives at `xb`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            coefficient array of a polynomial having specified derivatives</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses several facts from life of Bernstein basis functions.</span>
<span class="sd">        First of all,</span>

<span class="sd">            .. math:: b&#39;_{a, n} = n (b_{a-1, n-1} - b_{a, n-1})</span>

<span class="sd">        If B(x) is a linear combination of the form</span>

<span class="sd">            .. math:: B(x) = \sum_{a=0}^{n} c_a b_{a, n},</span>

<span class="sd">        then :math: B&#39;(x) = n \sum_{a=0}^{n-1} (c_{a+1} - c_{a}) b_{a, n-1}.</span>
<span class="sd">        Iterating the latter one, one finds for the q-th derivative</span>

<span class="sd">            .. math:: B^{q}(x) = n!/(n-q)! \sum_{a=0}^{n-q} Q_a b_{a, n-q},</span>

<span class="sd">        with</span>

<span class="sd">          .. math:: Q_a = \sum_{j=0}^{q} (-)^{j+q} comb(q, j) c_{j+a}</span>

<span class="sd">        This way, only `a=0` contributes to :math: `B^{q}(x = xa)`, and</span>
<span class="sd">        `c_q` are found one by one by iterating `q = 0, ..., na`.</span>

<span class="sd">        At ``x = xb`` it&#39;s the same with ``a = n - q``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ya</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">yb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shapes of ya </span><span class="si">{}</span><span class="s1"> and yb </span><span class="si">{}</span><span class="s1"> are incompatible&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">yb</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="n">dta</span><span class="p">,</span> <span class="n">dtb</span> <span class="o">=</span> <span class="n">ya</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">yb</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">or</span>
               <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtb</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

        <span class="n">na</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ya</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">na</span> <span class="o">+</span> <span class="n">nb</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">na</span><span class="o">+</span><span class="n">nb</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># compute coefficients of a polynomial degree na+nb-1</span>
        <span class="c1"># walk left-to-right</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">ya</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">/</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xb</span> <span class="o">-</span> <span class="n">xa</span><span class="p">)</span><span class="o">**</span><span class="n">q</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># now walk right-to-left</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yb</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">/</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">xb</span> <span class="o">-</span> <span class="n">xa</span><span class="p">)</span><span class="o">**</span><span class="n">q</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">+</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_raise_degree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Raise a degree of a polynomial in the Bernstein basis.</span>

<span class="sd">        Given the coefficients of a polynomial degree `k`, return (the</span>
<span class="sd">        coefficients of) the equivalent polynomial of degree `k+d`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : array_like</span>
<span class="sd">            coefficient array, 1-D</span>
<span class="sd">        d : integer</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            coefficient array, 1-D array of length `c.shape[0] + d`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses the fact that a Bernstein polynomial `b_{a, k}` can be</span>
<span class="sd">        identically represented as a linear combination of polynomials of</span>
<span class="sd">        a higher degree `k+d`:</span>

<span class="sd">            .. math:: b_{a, k} = comb(k, a) \sum_{j=0}^{d} b_{a+j, k+d} \</span>
<span class="sd">                                 comb(d, j) / comb(k+d, a+j)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">NdPPoly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Piecewise tensor product polynomial</span>

<span class="sd">    The value at point ``xp = (x&#39;, y&#39;, z&#39;, ...)`` is evaluated by first</span>
<span class="sd">    computing the interval indices `i` such that::</span>

<span class="sd">        x[0][i[0]] &lt;= x&#39; &lt; x[0][i[0]+1]</span>
<span class="sd">        x[1][i[1]] &lt;= y&#39; &lt; x[1][i[1]+1]</span>
<span class="sd">        ...</span>

<span class="sd">    and then computing::</span>

<span class="sd">        S = sum(c[k0-m0-1,...,kn-mn-1,i[0],...,i[n]]</span>
<span class="sd">                * (xp[0] - x[0][i[0]])**m0</span>
<span class="sd">                * ...</span>
<span class="sd">                * (xp[n] - x[n][i[n]])**mn</span>
<span class="sd">                for m0 in range(k[0]+1)</span>
<span class="sd">                ...</span>
<span class="sd">                for mn in range(k[n]+1))</span>

<span class="sd">    where ``k[j]`` is the degree of the polynomial in dimension j. This</span>
<span class="sd">    representation is the piecewise multivariate power basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k0, ..., kn, m0, ..., mn, ...)</span>
<span class="sd">        Polynomial coefficients, with polynomial order `kj` and</span>
<span class="sd">        `mj+1` intervals for each dimension `j`.</span>
<span class="sd">    x : ndim-tuple of ndarrays, shapes (mj+1,)</span>
<span class="sd">        Polynomial breakpoints for each dimension. These must be</span>
<span class="sd">        sorted in increasing order.</span>
<span class="sd">    extrapolate : bool, optional</span>
<span class="sd">        Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">        and last intervals, or to return NaNs. Default: True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : tuple of ndarrays</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    integrate_1d</span>
<span class="sd">    construct_fast</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    PPoly : piecewise polynomials in 1D</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    High-order polynomials in the power basis can be numerically</span>
<span class="sd">    unstable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x arrays must all be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x arrays must all contain at least 2 points&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c must have at least 2*len(x) dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x-coordinates are not in increasing order&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and c do not agree on the number of intervals&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the piecewise polynomial without making checks.</span>

<span class="sd">        Takes the same parameters as the constructor. Input arguments</span>
<span class="sd">        ``c`` and ``x`` must be arrays of the correct shape and type.  The</span>
<span class="sd">        ``c`` array can only be of dtypes float and complex, and ``x``</span>
<span class="sd">        array must have dtype float.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> \
               <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">def</span> <span class="nf">_ensure_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the piecewise polynomial or its derivative</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Points to evaluate the interpolant at.</span>
<span class="sd">        nu : tuple, optional</span>
<span class="sd">            Orders of derivatives to evaluate. Each must be non-negative.</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array-like</span>
<span class="sd">            Interpolated values. Shape is determined by replacing</span>
<span class="sd">            the interpolation axis in the original array with the shape of x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">nu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid number of derivative orders nu&quot;</span><span class="p">)</span>

        <span class="n">dim1</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">dim2</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">dim3</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:])</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate_nd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                           <span class="n">ks</span><span class="p">,</span>
                           <span class="n">x</span><span class="p">,</span>
                           <span class="n">nu</span><span class="p">,</span>
                           <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span>
                           <span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_derivative_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1-D derivative along a selected dimension in-place</span>
<span class="sd">        May result to non-contiguous c array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antiderivative_inplace</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># noop</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># multiply by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">_antiderivative_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1-D antiderivative along a selected dimension</span>
<span class="sd">        May result to non-contiguous c array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_inplace</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nu</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

        <span class="c1"># divide by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># fix continuity of added degrees of freedom</span>
        <span class="n">perm2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">perm2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">perm2</span><span class="p">[</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm2</span><span class="p">[</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span><span class="p">],</span> <span class="n">perm2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">fix_continuity</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">nu</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="c1"># Done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ndim-tuple of int</span>
<span class="sd">            Order of derivatives to evaluate for each dimension.</span>
<span class="sd">            If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : NdPPoly</span>
<span class="sd">            Piecewise polynomial of orders (k[0] - nu[0], ..., k[n] - nu[n])</span>
<span class="sd">            representing the derivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals in each dimension are</span>
<span class="sd">        considered half-open, ``[a, b)``, except for the last interval</span>
<span class="sd">        which is closed ``[a, b]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_derivative_inplace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Antiderivative is also the indefinite integral of the function,</span>
<span class="sd">        and derivative is its inverse operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ndim-tuple of int</span>
<span class="sd">            Order of derivatives to evaluate for each dimension.</span>
<span class="sd">            If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k + n representing</span>
<span class="sd">            the antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The antiderivative returned by this function is continuous and</span>
<span class="sd">        continuously differentiable to order n-1, up to floating point</span>
<span class="sd">        rounding error.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_antiderivative_inplace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">integrate_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NdPPoly representation for one dimensional definite integral</span>

<span class="sd">        The result is a piecewise polynomial representing the integral:</span>

<span class="sd">        .. math::</span>

<span class="sd">           p(y, z, ...) = \int_a^b dx\, p(x, y, z, ...)</span>

<span class="sd">        where the dimension integrated over is specified with the</span>
<span class="sd">        `axis` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : float</span>
<span class="sd">            Lower and upper bound for integration.</span>
<span class="sd">        axis : int</span>
<span class="sd">            Dimension over which to compute the 1-D integrals</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : NdPPoly or array-like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b].</span>
<span class="sd">            If the polynomial was 1D, an array is returned,</span>
<span class="sd">            otherwise, an NdPPoly object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="c1"># reuse 1-D integration routines</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">swap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
                                 <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="c1"># Construct result</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ranges : ndim-tuple of 2-tuples float</span>
<span class="sd">            Sequence of lower and upper bounds for each dimension,</span>
<span class="sd">            ``[(a[0], b[0]), ..., (a[ndim-1], b[ndim-1])]``</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over</span>
<span class="sd">            [a[0], b[0]] x ... x [a[ndim-1], b[ndim-1]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Range not a sequence of correct length&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="c1"># Reuse 1D integration routine</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">):</span>
            <span class="n">swap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">n</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">c</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2019, California Department of Water Resources.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>