
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.signal.signaltools &#8212; vtools 3.6.6+1.g092ced5.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
            </a></p>
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Introduction and concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html">Averging, Filtering and Low Passing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html#Filters">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scipy.signal.signaltools</h1><div class="highlight"><pre>
<span></span><span class="c1"># Author: Travis Oliphant</span>
<span class="c1"># 1999 -- 2002</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">sigtools</span><span class="p">,</span> <span class="n">dlti</span>
<span class="kn">from</span> <span class="nn">._upfirdn</span> <span class="kn">import</span> <span class="n">upfirdn</span><span class="p">,</span> <span class="n">_output_len</span><span class="p">,</span> <span class="n">_upfirdn_modes</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span><span class="p">,</span> <span class="n">fft</span> <span class="k">as</span> <span class="n">sp_fft</span>
<span class="kn">from</span> <span class="nn">scipy.fft._helper</span> <span class="kn">import</span> <span class="n">_init_nd_shape_and_axes</span>
<span class="kn">from</span> <span class="nn">scipy._lib._util</span> <span class="kn">import</span> <span class="n">prod</span> <span class="k">as</span> <span class="n">_prod</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">lambertw</span>
<span class="kn">from</span> <span class="nn">.windows</span> <span class="kn">import</span> <span class="n">get_window</span>
<span class="kn">from</span> <span class="nn">._arraytools</span> <span class="kn">import</span> <span class="n">axis_slice</span><span class="p">,</span> <span class="n">axis_reverse</span><span class="p">,</span> <span class="n">odd_ext</span><span class="p">,</span> <span class="n">even_ext</span><span class="p">,</span> <span class="n">const_ext</span>
<span class="kn">from</span> <span class="nn">.filter_design</span> <span class="kn">import</span> <span class="n">cheby1</span><span class="p">,</span> <span class="n">_validate_sos</span>
<span class="kn">from</span> <span class="nn">.fir_filter_design</span> <span class="kn">import</span> <span class="n">firwin</span>
<span class="kn">from</span> <span class="nn">._sosfilt</span> <span class="kn">import</span> <span class="n">_sosfilt</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation_lags&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate2d&#39;</span><span class="p">,</span>
           <span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="s1">&#39;convolve2d&#39;</span><span class="p">,</span> <span class="s1">&#39;fftconvolve&#39;</span><span class="p">,</span> <span class="s1">&#39;oaconvolve&#39;</span><span class="p">,</span>
           <span class="s1">&#39;order_filter&#39;</span><span class="p">,</span> <span class="s1">&#39;medfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;medfilt2d&#39;</span><span class="p">,</span> <span class="s1">&#39;wiener&#39;</span><span class="p">,</span> <span class="s1">&#39;lfilter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lfiltic&#39;</span><span class="p">,</span> <span class="s1">&#39;sosfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;deconvolve&#39;</span><span class="p">,</span> <span class="s1">&#39;hilbert&#39;</span><span class="p">,</span> <span class="s1">&#39;hilbert2&#39;</span><span class="p">,</span>
           <span class="s1">&#39;cmplx_sort&#39;</span><span class="p">,</span> <span class="s1">&#39;unique_roots&#39;</span><span class="p">,</span> <span class="s1">&#39;invres&#39;</span><span class="p">,</span> <span class="s1">&#39;invresz&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span>
           <span class="s1">&#39;residuez&#39;</span><span class="p">,</span> <span class="s1">&#39;resample&#39;</span><span class="p">,</span> <span class="s1">&#39;resample_poly&#39;</span><span class="p">,</span> <span class="s1">&#39;detrend&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lfilter_zi&#39;</span><span class="p">,</span> <span class="s1">&#39;sosfilt_zi&#39;</span><span class="p">,</span> <span class="s1">&#39;sosfiltfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;choose_conv_method&#39;</span><span class="p">,</span>
           <span class="s1">&#39;filtfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;decimate&#39;</span><span class="p">,</span> <span class="s1">&#39;vectorstrength&#39;</span><span class="p">]</span>


<span class="n">_modedict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

<span class="n">_boundarydict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fill&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;pad&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;circular&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;symm&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_valfrommode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_modedict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;same&#39;, or &#39;full&#39;.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>


<span class="k">def</span> <span class="nf">_bvalfromboundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_boundarydict</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable boundary flags are &#39;fill&#39;, &#39;circular&#39; &quot;</span>
                         <span class="s2">&quot;(or &#39;wrap&#39;), and &#39;symmetric&#39; (or &#39;symm&#39;).&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>


<span class="k">def</span> <span class="nf">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine if inputs arrays need to be swapped in `&quot;valid&quot;` mode.</span>

<span class="sd">    If in `&quot;valid&quot;` mode, returns whether or not the input arrays need to be</span>
<span class="sd">    swapped depending on whether `shape1` is at least as large as `shape2` in</span>
<span class="sd">    every calculated dimension.</span>

<span class="sd">    This is important for some of the correlation and convolution</span>
<span class="sd">    implementations in this module, where the larger array input needs to come</span>
<span class="sd">    before the smaller array input when operating in this mode.</span>

<span class="sd">    Note that if the mode provided is not &#39;valid&#39;, False is immediately</span>
<span class="sd">    returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape1</span><span class="p">))</span>

    <span class="n">ok1</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">shape1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">shape2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>
    <span class="n">ok2</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">shape2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">shape1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ok1</span> <span class="ow">or</span> <span class="n">ok2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For &#39;valid&#39; mode, one must be at least &quot;</span>
                         <span class="s2">&quot;as large as the other in every dimension&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="ow">not</span> <span class="n">ok1</span>


<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlate two N-dimensional arrays.</span>

<span class="sd">    Cross-correlate `in1` and `in2`, with the output size determined by the</span>
<span class="sd">    `mode` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear cross-correlation</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    method : str {&#39;auto&#39;, &#39;direct&#39;, &#39;fft&#39;}, optional</span>
<span class="sd">        A string indicating which method to use to calculate the correlation.</span>

<span class="sd">        ``direct``</span>
<span class="sd">           The correlation is determined directly from sums, the definition of</span>
<span class="sd">           correlation.</span>
<span class="sd">        ``fft``</span>
<span class="sd">           The Fast Fourier Transform is used to perform the correlation more</span>
<span class="sd">           quickly (only available for numerical arrays.)</span>
<span class="sd">        ``auto``</span>
<span class="sd">           Automatically chooses direct or Fourier method based on an estimate</span>
<span class="sd">           of which is faster (default).  See `convolve` Notes for more detail.</span>

<span class="sd">           .. versionadded:: 0.19.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlate : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        cross-correlation of `in1` with `in2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose_conv_method : contains more documentation on `method`.</span>
<span class="sd">    correlation_lags : calculates the lag / displacement indices array for 1D</span>
<span class="sd">        cross-correlation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The correlation z of two d-dimensional arrays x and y is defined as::</span>

<span class="sd">        z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...])</span>

<span class="sd">    This way, if x and y are 1-D arrays and ``z = correlate(x, y, &#39;full&#39;)``</span>
<span class="sd">    then</span>

<span class="sd">    .. math::</span>

<span class="sd">          z[k] = (x * y)(k - N + 1)</span>
<span class="sd">               = \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*}</span>

<span class="sd">    for :math:`k = 0, 1, ..., ||x|| + ||y|| - 2`</span>

<span class="sd">    where :math:`||x||` is the length of ``x``, :math:`N = \max(||x||,||y||)`,</span>
<span class="sd">    and :math:`y_m` is 0 when m is outside the range of y.</span>

<span class="sd">    ``method=&#39;fft&#39;`` only works for numerical arrays as it relies on</span>
<span class="sd">    `fftconvolve`. In certain cases (i.e., arrays of objects or when</span>
<span class="sd">    rounding integers can lose precision), ``method=&#39;direct&#39;`` is always used.</span>

<span class="sd">    When using &quot;same&quot; mode with even-length inputs, the outputs of `correlate`</span>
<span class="sd">    and `correlate2d` differ: There is a 1-index offset between them.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Implement a matched filter using cross-correlation, to recover a signal</span>
<span class="sd">    that has passed through a noisy channel.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>

<span class="sd">    &gt;&gt;&gt; sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)</span>
<span class="sd">    &gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig))</span>
<span class="sd">    &gt;&gt;&gt; corr = signal.correlate(sig_noise, np.ones(128), mode=&#39;same&#39;) / 128</span>

<span class="sd">    &gt;&gt;&gt; clock = np.arange(64, len(sig), 128)</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(clock, sig[clock], &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.plot(sig_noise)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.set_title(&#39;Signal with noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.plot(corr)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.plot(clock, corr[clock], &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.axhline(0.5, ls=&#39;:&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlated with rectangular pulse&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Compute the cross-correlation of a noisy signal with the original signal.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(128) / 128</span>
<span class="sd">    &gt;&gt;&gt; sig = np.sin(2 * np.pi * x)</span>
<span class="sd">    &gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig))</span>
<span class="sd">    &gt;&gt;&gt; corr = signal.correlate(sig_noise, sig)</span>
<span class="sd">    &gt;&gt;&gt; lags = signal.correlation_lags(len(sig), len(sig_noise))</span>
<span class="sd">    &gt;&gt;&gt; corr /= np.max(corr)</span>

<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, figsize=(4.8, 4.8))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_xlabel(&#39;Sample Number&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.plot(sig_noise)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.set_title(&#39;Signal with noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.set_xlabel(&#39;Sample Number&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.plot(lags, corr)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlated signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_xlabel(&#39;Lag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="p">)</span>

    <span class="c1"># Don&#39;t use _valfrommode, since correlate should not accept numeric modes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_modedict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;same&#39;, or &#39;full&#39;.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="c1"># this either calls fftconvolve or this function with method==&#39;direct&#39;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">_reverse_and_conj</span><span class="p">(</span><span class="n">in2</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">:</span>
        <span class="c1"># fastpath to faster numpy.correlate for 1d inputs when possible</span>
        <span class="k">if</span> <span class="n">_np_conv_ok</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="c1"># _correlateND is far slower when in2.size &gt; in1.size, so swap them</span>
        <span class="c1"># and then undo the effect afterward if mode == &#39;full&#39;.  Also, it fails</span>
        <span class="c1"># with &#39;valid&#39; mode if in2 is larger than in1, so swap those, too.</span>
        <span class="c1"># Don&#39;t swap inputs for &#39;same&#39; mode, since shape of in1 matters.</span>
        <span class="n">swapped_inputs</span> <span class="o">=</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">in2</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span>
                          <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
            <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_correlateND</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>

            <span class="c1"># zero pad input</span>
            <span class="n">in1zpadded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">in1zpadded</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span> <span class="o">=</span> <span class="n">in1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_correlateND</span><span class="p">(</span><span class="n">in1zpadded</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
            <span class="c1"># Reverse and conjugate to undo the effect of swapping inputs</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">_reverse_and_conj</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">z</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable method flags are &#39;auto&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;direct&#39;, or &#39;fft&#39;.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">correlation_lags</span><span class="p">(</span><span class="n">in1_len</span><span class="p">,</span> <span class="n">in2_len</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the lag / displacement indices array for 1D cross-correlation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1_size : int</span>
<span class="sd">        First input size.</span>
<span class="sd">    in2_size : int</span>
<span class="sd">        Second input size.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output.</span>
<span class="sd">        See the documentation `correlate` for more information.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    correlate : Compute the N-dimensional cross-correlation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lags : array</span>
<span class="sd">        Returns an array containing cross-correlation lag/displacement indices.</span>
<span class="sd">        Indices can be indexed with the np.argmax of the correlation to return</span>
<span class="sd">        the lag/displacement.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Cross-correlation for continuous functions :math:`f` and :math:`g` is</span>
<span class="sd">    defined as:</span>

<span class="sd">    .. math ::</span>

<span class="sd">        \left ( f\star g \right )\left ( \tau \right )</span>
<span class="sd">        \triangleq \int_{t_0}^{t_0 +T}</span>
<span class="sd">        \overline{f\left ( t \right )}g\left ( t+\tau \right )dt</span>

<span class="sd">    Where :math:`\tau` is defined as the displacement, also known as the lag.</span>

<span class="sd">    Cross correlation for discrete functions :math:`f` and :math:`g` is</span>
<span class="sd">    defined as:</span>

<span class="sd">    .. math ::</span>
<span class="sd">        \left ( f\star g \right )\left [ n \right ]</span>
<span class="sd">        \triangleq \sum_{-\infty}^{\infty}</span>
<span class="sd">        \overline{f\left [ m \right ]}g\left [ m+n \right ]</span>

<span class="sd">    Where :math:`n` is the lag.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Cross-correlation of a signal with its time-delayed self.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import default_rng</span>
<span class="sd">    &gt;&gt;&gt; rng = default_rng()</span>
<span class="sd">    &gt;&gt;&gt; x = rng.standard_normal(1000)</span>
<span class="sd">    &gt;&gt;&gt; y = np.concatenate([rng.standard_normal(100), x])</span>
<span class="sd">    &gt;&gt;&gt; correlation = signal.correlate(x, y, mode=&quot;full&quot;)</span>
<span class="sd">    &gt;&gt;&gt; lags = signal.correlation_lags(x.size, y.size, mode=&quot;full&quot;)</span>
<span class="sd">    &gt;&gt;&gt; lag = lags[np.argmax(correlation)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate lag ranges in different modes of operation</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="c1"># the output is the full discrete linear convolution</span>
        <span class="c1"># of the inputs. (Default)</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">in2_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in1_len</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="c1"># the output is the same size as `in1`, centered</span>
        <span class="c1"># with respect to the &#39;full&#39; output.</span>
        <span class="c1"># calculate the full output</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">in2_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in1_len</span><span class="p">)</span>
        <span class="c1"># determine the midpoint in the full output</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">lags</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># determine lag_bound to be used with respect</span>
        <span class="c1"># to the midpoint</span>
        <span class="n">lag_bound</span> <span class="o">=</span> <span class="n">in1_len</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># calculate lag ranges for even and odd scenarios</span>
        <span class="k">if</span> <span class="n">in1_len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[(</span><span class="n">mid</span><span class="o">-</span><span class="n">lag_bound</span><span class="p">):(</span><span class="n">mid</span><span class="o">+</span><span class="n">lag_bound</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[(</span><span class="n">mid</span><span class="o">-</span><span class="n">lag_bound</span><span class="p">):(</span><span class="n">mid</span><span class="o">+</span><span class="n">lag_bound</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
        <span class="c1"># the output consists only of those elements that do not</span>
        <span class="c1"># rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
        <span class="c1"># must be at least as large as the other in every dimension.</span>

        <span class="c1"># the lag_bound will be either negative or positive</span>
        <span class="c1"># this let&#39;s us infer how to present the lag range</span>
        <span class="n">lag_bound</span> <span class="o">=</span> <span class="n">in1_len</span> <span class="o">-</span> <span class="n">in2_len</span>
        <span class="k">if</span> <span class="n">lag_bound</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lag_bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lag_bound</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lags</span>


<span class="k">def</span> <span class="nf">_centered</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">newshape</span><span class="p">):</span>
    <span class="c1"># Return the center newshape portion of the array.</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span>
    <span class="n">currshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">startind</span> <span class="o">=</span> <span class="p">(</span><span class="n">currshape</span> <span class="o">-</span> <span class="n">newshape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">endind</span> <span class="o">=</span> <span class="n">startind</span> <span class="o">+</span> <span class="n">newshape</span>
    <span class="n">myslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">startind</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">endind</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endind</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">myslice</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_init_freq_conv_axes</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">sorted_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handle the axes argument for frequency-domain convolution.</span>

<span class="sd">    Returns the inputs and axes in a standard form, eliminating redundant axes,</span>
<span class="sd">    swapping the inputs if necessary, and checking for various potential</span>
<span class="sd">    errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array</span>
<span class="sd">        Second input.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output.</span>
<span class="sd">        See the documentation `fftconvolve` for more information.</span>
<span class="sd">    axes : list of ints</span>
<span class="sd">        Axes over which to compute the FFTs.</span>
<span class="sd">    sorted_axes : bool, optional</span>
<span class="sd">        If `True`, sort the axes.</span>
<span class="sd">        Default is `False`, do not sort.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    in1 : array</span>
<span class="sd">        The first input, possible swapped with the second input.</span>
<span class="sd">    in2 : array</span>
<span class="sd">        The second input, possible swapped with the first input.</span>
<span class="sd">    axes : list of ints</span>
<span class="sd">        Axes over which to compute the FFTs.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">noaxes</span> <span class="o">=</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">_init_nd_shape_and_axes</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">noaxes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;when provided, axes cannot be empty&quot;</span><span class="p">)</span>

    <span class="c1"># Axes of length 1 can rely on broadcasting rules for multipy,</span>
    <span class="c1"># no fft needed.</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">s2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">sorted_axes</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">or</span> <span class="n">s1</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">s2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
               <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible shapes for in1 and in2:&quot;</span>
                         <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> and </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

    <span class="c1"># Check that input sizes are compatible with &#39;valid&#39; mode.</span>
    <span class="k">if</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">):</span>
        <span class="c1"># Convolution is commutative; order doesn&#39;t have any effect on output.</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

    <span class="k">return</span> <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">axes</span>


<span class="k">def</span> <span class="nf">_freq_domain_conv</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">calc_fast_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convolve two arrays in the frequency domain.</span>

<span class="sd">    This function implements only base the FFT-related operations.</span>
<span class="sd">    Specifically, it converts the signals to the frequency domain, multiplies</span>
<span class="sd">    them, then converts them back to the time domain.  Calculations of axes,</span>
<span class="sd">    shapes, convolution mode, etc. are implemented in higher level-functions,</span>
<span class="sd">    such as `fftconvolve` and `oaconvolve`.  Those functions should be used</span>
<span class="sd">    instead of this one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    axes : array_like of ints</span>
<span class="sd">        Axes over which to compute the FFTs.</span>
<span class="sd">    shape : array_like of ints</span>
<span class="sd">        The sizes of the FFTs.</span>
<span class="sd">    calc_fast_len : bool, optional</span>
<span class="sd">        If `True`, set each value of `shape` to the next fast FFT length.</span>
<span class="sd">        Default is `False`, use `axes` as-is.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        An N-dimensional array containing the discrete linear convolution of</span>
<span class="sd">        `in1` with `in2`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span>

    <span class="n">complex_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="ow">or</span> <span class="n">in2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">calc_fast_len</span><span class="p">:</span>
        <span class="c1"># Speed up FFT by padding to optimal size.</span>
        <span class="n">fshape</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sp_fft</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="ow">not</span> <span class="n">complex_result</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fshape</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_result</span><span class="p">:</span>
        <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">,</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">irfftn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">ifftn</span>

    <span class="n">sp1</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">fshape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">sp2</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">in2</span><span class="p">,</span> <span class="n">fshape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">sp1</span> <span class="o">*</span> <span class="n">sp2</span><span class="p">,</span> <span class="n">fshape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">calc_fast_len</span><span class="p">:</span>
        <span class="n">fslice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="k">for</span> <span class="n">sz</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">])</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">fslice</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_apply_conv_mode</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the convolution result shape based on the `mode` argument.</span>

<span class="sd">    Returns the result sliced to the correct size for the given mode.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ret : array</span>
<span class="sd">        The result array, with the appropriate shape for the &#39;full&#39; mode.</span>
<span class="sd">    s1 : list of int</span>
<span class="sd">        The shape of the first input.</span>
<span class="sd">    s2 : list of int</span>
<span class="sd">        The shape of the second input.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}</span>
<span class="sd">        A string indicating the size of the output.</span>
<span class="sd">        See the documentation `fftconvolve` for more information.</span>
<span class="sd">    axes : list of ints</span>
<span class="sd">        Axes over which to compute the convolution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : array</span>
<span class="sd">        A copy of `res`, sliced to the correct size for the given `mode`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_centered</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
        <span class="n">shape_valid</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">s1</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                       <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">_centered</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">shape_valid</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;acceptable mode flags are &#39;valid&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;same&#39;, or &#39;full&#39;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fftconvolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convolve two N-dimensional arrays using FFT.</span>

<span class="sd">    Convolve `in1` and `in2` using the fast Fourier transform method, with</span>
<span class="sd">    the output size determined by the `mode` argument.</span>

<span class="sd">    This is generally much faster than `convolve` for large arrays (n &gt; ~500),</span>
<span class="sd">    but can be slower when only a few output values are needed, and can only</span>
<span class="sd">    output float arrays (int or object array inputs will be cast to float).</span>

<span class="sd">    As of v0.19, `convolve` automatically chooses this method or the direct</span>
<span class="sd">    method based on an estimation of which is faster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    axes : int or array_like of ints or None, optional</span>
<span class="sd">        Axes over which to compute the convolution.</span>
<span class="sd">        The default is over all axes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve : Uses the direct convolution or FFT convolution algorithm</span>
<span class="sd">               depending on which is faster.</span>
<span class="sd">    oaconvolve : Uses the overlap-add method to do convolution, which is</span>
<span class="sd">                 generally faster when the input arrays are large and</span>
<span class="sd">                 significantly different in size.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Autocorrelation of white noise is an impulse.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; sig = rng.standard_normal(1000)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = signal.fftconvolve(sig, sig[::-1], mode=&#39;full&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;White noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_title(&#39;Autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    Gaussian blur implemented using FFT convolution.  Notice the dark borders</span>
<span class="sd">    around the image, due to the zero-padding beyond its boundaries.</span>
<span class="sd">    The `convolve2d` function allows for other types of image boundaries,</span>
<span class="sd">    but is far slower.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import misc</span>
<span class="sd">    &gt;&gt;&gt; face = misc.face(gray=True)</span>
<span class="sd">    &gt;&gt;&gt; kernel = np.outer(signal.windows.gaussian(70, 8),</span>
<span class="sd">    ...                   signal.windows.gaussian(70, 8))</span>
<span class="sd">    &gt;&gt;&gt; blurred = signal.fftconvolve(face, kernel, mode=&#39;same&#39;)</span>

<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1,</span>
<span class="sd">    ...                                                      figsize=(6, 15))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.imshow(face, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_kernel.imshow(kernel, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_kernel.set_title(&#39;Gaussian kernel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_kernel.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_blurred.imshow(blurred, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_blurred.set_title(&#39;Blurred&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_blurred.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># scalar inputs</span>
        <span class="k">return</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">in2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># empty arrays</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">_init_freq_conv_axes</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span>
                                          <span class="n">sorted_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">s1</span> <span class="o">=</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">((</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">else</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">_freq_domain_conv</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">calc_fast_len</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_apply_conv_mode</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_calc_oa_lens</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the optimal FFT lengths for overlapp-add convolution.</span>

<span class="sd">    The calculation is done for a single dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s1 : int</span>
<span class="sd">        Size of the dimension for the first array.</span>
<span class="sd">    s2 : int</span>
<span class="sd">        Size of the dimension for the second array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    block_size : int</span>
<span class="sd">        The size of the FFT blocks.</span>
<span class="sd">    overlap : int</span>
<span class="sd">        The amount of overlap between two blocks.</span>
<span class="sd">    in1_step : int</span>
<span class="sd">        The size of each step for the first array.</span>
<span class="sd">    in2_step : int</span>
<span class="sd">        The size of each step for the first array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set up the arguments for the conventional FFT approach.</span>
    <span class="n">fallback</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="o">+</span><span class="n">s2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>

    <span class="c1"># Use conventional FFT convolve if sizes are same.</span>
    <span class="k">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span> <span class="ow">or</span> <span class="n">s1</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">s2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fallback</span>

    <span class="k">if</span> <span class="n">s2</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">:</span>
        <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s1</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># There cannot be a useful block size if s2 is more than half of s1.</span>
    <span class="k">if</span> <span class="n">s2</span> <span class="o">&gt;=</span> <span class="n">s1</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fallback</span>

    <span class="c1"># Derivation of optimal block length</span>
    <span class="c1"># For original formula see:</span>
    <span class="c1"># https://en.wikipedia.org/wiki/Overlap-add_method</span>
    <span class="c1">#</span>
    <span class="c1"># Formula:</span>
    <span class="c1"># K = overlap = s2-1</span>
    <span class="c1"># N = block_size</span>
    <span class="c1"># C = complexity</span>
    <span class="c1"># e = exponential, exp(1)</span>
    <span class="c1">#</span>
    <span class="c1"># C = (N*(log2(N)+1))/(N-K)</span>
    <span class="c1"># C = (N*log2(2N))/(N-K)</span>
    <span class="c1"># C = N/(N-K) * log2(2N)</span>
    <span class="c1"># C1 = N/(N-K)</span>
    <span class="c1"># C2 = log2(2N) = ln(2N)/ln(2)</span>
    <span class="c1">#</span>
    <span class="c1"># dC1/dN = (1*(N-K)-N)/(N-K)^2 = -K/(N-K)^2</span>
    <span class="c1"># dC2/dN = 2/(2*N*ln(2)) = 1/(N*ln(2))</span>
    <span class="c1">#</span>
    <span class="c1"># dC/dN = dC1/dN*C2 + dC2/dN*C1</span>
    <span class="c1"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + N/(N*ln(2)*(N-K))</span>
    <span class="c1"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + 1/(ln(2)*(N-K))</span>
    <span class="c1"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + (N-K)/(ln(2)*(N-K)^2)</span>
    <span class="c1"># dC/dN = (-K*ln(2N) + (N-K)/(ln(2)*(N-K)^2)</span>
    <span class="c1"># dC/dN = (N - K*ln(2N) - K)/(ln(2)*(N-K)^2)</span>
    <span class="c1">#</span>
    <span class="c1"># Solve for minimum, where dC/dN = 0</span>
    <span class="c1"># 0 = (N - K*ln(2N) - K)/(ln(2)*(N-K)^2)</span>
    <span class="c1"># 0 * ln(2)*(N-K)^2 = N - K*ln(2N) - K</span>
    <span class="c1"># 0 = N - K*ln(2N) - K</span>
    <span class="c1"># 0 = N - K*(ln(2N) + 1)</span>
    <span class="c1"># 0 = N - K*ln(2Ne)</span>
    <span class="c1"># N = K*ln(2Ne)</span>
    <span class="c1"># N/K = ln(2Ne)</span>
    <span class="c1">#</span>
    <span class="c1"># e^(N/K) = e^ln(2Ne)</span>
    <span class="c1"># e^(N/K) = 2Ne</span>
    <span class="c1"># 1/e^(N/K) = 1/(2*N*e)</span>
    <span class="c1"># e^(N/-K) = 1/(2*N*e)</span>
    <span class="c1"># e^(N/-K) = K/N*1/(2*K*e)</span>
    <span class="c1"># N/K*e^(N/-K) = 1/(2*e*K)</span>
    <span class="c1"># N/-K*e^(N/-K) = -1/(2*e*K)</span>
    <span class="c1">#</span>
    <span class="c1"># Using Lambert W function</span>
    <span class="c1"># https://en.wikipedia.org/wiki/Lambert_W_function</span>
    <span class="c1"># x = W(y) It is the solution to y = x*e^x</span>
    <span class="c1"># x = N/-K</span>
    <span class="c1"># y = -1/(2*e*K)</span>
    <span class="c1">#</span>
    <span class="c1"># N/-K = W(-1/(2*e*K))</span>
    <span class="c1">#</span>
    <span class="c1"># N = -K*W(-1/(2*e*K))</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">s2</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">opt_size</span> <span class="o">=</span> <span class="o">-</span><span class="n">overlap</span><span class="o">*</span><span class="n">lambertw</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">e</span><span class="o">*</span><span class="n">overlap</span><span class="p">),</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="n">block_size</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">opt_size</span><span class="p">))</span>

    <span class="c1"># Use conventional FFT convolve if there is only going to be one block.</span>
    <span class="k">if</span> <span class="n">block_size</span> <span class="o">&gt;=</span> <span class="n">s1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fallback</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
        <span class="n">in1_step</span> <span class="o">=</span> <span class="n">block_size</span><span class="o">-</span><span class="n">s2</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">in2_step</span> <span class="o">=</span> <span class="n">s2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">in1_step</span> <span class="o">=</span> <span class="n">s2</span>
        <span class="n">in2_step</span> <span class="o">=</span> <span class="n">block_size</span><span class="o">-</span><span class="n">s2</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">in1_step</span><span class="p">,</span> <span class="n">in2_step</span>


<span class="k">def</span> <span class="nf">oaconvolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convolve two N-dimensional arrays using the overlap-add method.</span>

<span class="sd">    Convolve `in1` and `in2` using the overlap-add method, with</span>
<span class="sd">    the output size determined by the `mode` argument.</span>

<span class="sd">    This is generally much faster than `convolve` for large arrays (n &gt; ~500),</span>
<span class="sd">    and generally much faster than `fftconvolve` when one array is much</span>
<span class="sd">    larger than the other, but can be slower when only a few output values are</span>
<span class="sd">    needed or when the arrays are very similar in shape, and can only</span>
<span class="sd">    output float arrays (int or object array inputs will be cast to float).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    axes : int or array_like of ints or None, optional</span>
<span class="sd">        Axes over which to compute the convolution.</span>
<span class="sd">        The default is over all axes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve : Uses the direct convolution or FFT convolution algorithm</span>
<span class="sd">               depending on which is faster.</span>
<span class="sd">    fftconvolve : An implementation of convolution using FFT.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.4.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convolve a 100,000 sample signal with a 512-sample filter.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; sig = rng.standard_normal(100000)</span>
<span class="sd">    &gt;&gt;&gt; filt = signal.firwin(512, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; fsig = signal.oaconvolve(sig, filt)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;White noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.plot(fsig)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_title(&#39;Filtered noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Overlap-add_method&quot;.</span>
<span class="sd">           https://en.wikipedia.org/wiki/Overlap-add_method</span>
<span class="sd">    .. [2] Richard G. Lyons. Understanding Digital Signal Processing,</span>
<span class="sd">           Third Edition, 2011. Chapter 13.10.</span>
<span class="sd">           ISBN 13: 978-0137-02741-5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># scalar inputs</span>
        <span class="k">return</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">in2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># empty arrays</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>  <span class="c1"># Equivalent to fftconvolve</span>
        <span class="k">return</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">_init_freq_conv_axes</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span>
                                          <span class="n">sorted_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">s1</span> <span class="o">=</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">axes</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span>
        <span class="k">return</span> <span class="n">_apply_conv_mode</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="c1"># Calculate this now since in1 is changed later</span>
    <span class="n">shape_final</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">else</span>
                   <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>

    <span class="c1"># Calculate the block sizes for the output, steps, first and second inputs.</span>
    <span class="c1"># It is simpler to calculate them all together than doing them in separate</span>
    <span class="c1"># loops due to all the special cases that need to be handled.</span>
    <span class="n">optimal_sizes</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">else</span>
                     <span class="n">_calc_oa_lens</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">block_size</span><span class="p">,</span> <span class="n">overlaps</span><span class="p">,</span> \
        <span class="n">in1_step</span><span class="p">,</span> <span class="n">in2_step</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">optimal_sizes</span><span class="p">)</span>

    <span class="c1"># Fall back to fftconvolve if there is only one block in every dimension.</span>
    <span class="k">if</span> <span class="n">in1_step</span> <span class="o">==</span> <span class="n">s1</span> <span class="ow">and</span> <span class="n">in2_step</span> <span class="o">==</span> <span class="n">s2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

    <span class="c1"># Figure out the number of steps and padding.</span>
    <span class="c1"># This would get too complicated in a list comprehension.</span>
    <span class="n">nsteps1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nsteps2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pad_size1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pad_size2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">pad_size1</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="n">pad_size2</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">in1_step</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">curnstep1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">in1_step</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">block_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">curnstep1</span> <span class="o">&lt;</span> <span class="n">shape_final</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">curnstep1</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">curpad1</span> <span class="o">=</span> <span class="n">curnstep1</span><span class="o">*</span><span class="n">in1_step</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curnstep1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">curpad1</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">in2_step</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">curnstep2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">in2_step</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">block_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">curnstep2</span> <span class="o">&lt;</span> <span class="n">shape_final</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">curnstep2</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">curpad2</span> <span class="o">=</span> <span class="n">curnstep2</span><span class="o">*</span><span class="n">in2_step</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curnstep2</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">curpad2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">nsteps1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curnstep1</span><span class="p">]</span>
        <span class="n">nsteps2</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curnstep2</span><span class="p">]</span>
        <span class="n">pad_size1</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curpad1</span><span class="p">)]</span>
        <span class="n">pad_size2</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curpad2</span><span class="p">)]</span>

    <span class="c1"># Pad the array to a size that can be reshaped to the desired shape</span>
    <span class="c1"># if necessary.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">curpad</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">curpad</span> <span class="ow">in</span> <span class="n">pad_size1</span><span class="p">):</span>
        <span class="n">in1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">pad_size1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">curpad</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">curpad</span> <span class="ow">in</span> <span class="n">pad_size2</span><span class="p">):</span>
        <span class="n">in2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">in2</span><span class="p">,</span> <span class="n">pad_size2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Reshape the overlap-add parts to input block sizes.</span>
    <span class="n">split_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">iax</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">)]</span>
    <span class="n">fft_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">iax</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">iax</span> <span class="ow">in</span> <span class="n">split_axes</span><span class="p">]</span>

    <span class="c1"># We need to put each new dimension before the corresponding dimension</span>
    <span class="c1"># being reshaped in order to get the data in the right layout at the end.</span>
    <span class="n">reshape_size1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in1_step</span><span class="p">)</span>
    <span class="n">reshape_size2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in2_step</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_axes</span><span class="p">):</span>
        <span class="n">reshape_size1</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iax</span><span class="p">,</span> <span class="n">nsteps1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">reshape_size2</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iax</span><span class="p">,</span> <span class="n">nsteps2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">in1</span> <span class="o">=</span> <span class="n">in1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">reshape_size1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">reshape_size2</span><span class="p">)</span>

    <span class="c1"># Do the convolution.</span>
    <span class="n">fft_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">block_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">_freq_domain_conv</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">fft_axes</span><span class="p">,</span> <span class="n">fft_shape</span><span class="p">,</span> <span class="n">calc_fast_len</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Do the overlap-add.</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ax_fft</span><span class="p">,</span> <span class="n">ax_split</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">fft_axes</span><span class="p">,</span> <span class="n">split_axes</span><span class="p">):</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">ret</span><span class="p">,</span> <span class="n">overpart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">overlap</span><span class="p">],</span> <span class="n">ax_fft</span><span class="p">)</span>
        <span class="n">overpart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">overpart</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ax_split</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ret_overpart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="p">[</span><span class="n">overlap</span><span class="p">],</span> <span class="n">ax_fft</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ret_overpart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ret_overpart</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ax_split</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ret_overpart</span> <span class="o">+=</span> <span class="n">overpart</span>

    <span class="c1"># Reshape back to the correct dimensionality.</span>
    <span class="n">shape_ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fft_axes</span> <span class="k">else</span>
                 <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_axes</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">shape_ret</span><span class="p">)</span>

    <span class="c1"># Slice to the correct size.</span>
    <span class="n">slice_final</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="n">islice</span><span class="p">)</span> <span class="k">for</span> <span class="n">islice</span> <span class="ow">in</span> <span class="n">shape_final</span><span class="p">])</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">slice_final</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_apply_conv_mode</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_numeric_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">kinds</span><span class="o">=</span><span class="s1">&#39;buifc&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if a list of arrays are all numeric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ndarrays : array or list of arrays</span>
<span class="sd">        arrays to check if numeric.</span>
<span class="sd">    numeric_kinds : string-like</span>
<span class="sd">        The dtypes of the arrays to be checked. If the dtype.kind of</span>
<span class="sd">        the ndarrays are not in this string the function returns False and</span>
<span class="sd">        otherwise returns True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arrays</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">kinds</span>
    <span class="k">for</span> <span class="n">array_</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">array_</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_conv_ops</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">h_shape</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the number of operations required for direct/fft methods of</span>
<span class="sd">    convolution. The direct operations were recorded by making a dummy class to</span>
<span class="sd">    record the number of operations by overriding ``__mul__`` and ``__add__``.</span>
<span class="sd">    The FFT operations rely on the (well-known) computational complexity of the</span>
<span class="sd">    FFT (and the implementation of ``_freq_domain_conv``).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">h_shape</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">h_shape</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">x_shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;same&#39;, or &#39;full&#39;, not mode=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">x_shape</span><span class="p">,</span> <span class="n">h_shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">direct_ops</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
            <span class="n">direct_ops</span> <span class="o">=</span> <span class="p">(</span><span class="n">s2</span> <span class="o">-</span> <span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s1</span> <span class="k">if</span> <span class="n">s2</span> <span class="o">&gt;=</span> <span class="n">s1</span> <span class="k">else</span> <span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s2</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
            <span class="n">direct_ops</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span> <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span> <span class="k">else</span>
                          <span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span> <span class="o">-</span> <span class="p">(</span><span class="n">s2</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">s2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">direct_ops</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_prod</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">_prod</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span> <span class="o">*</span> <span class="n">_prod</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
            <span class="n">direct_ops</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_prod</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">_prod</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span> <span class="o">*</span> <span class="n">_prod</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
            <span class="n">direct_ops</span> <span class="o">=</span> <span class="n">_prod</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_prod</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

    <span class="n">full_out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_shape</span><span class="p">,</span> <span class="n">h_shape</span><span class="p">)]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">_prod</span><span class="p">(</span><span class="n">full_out_shape</span><span class="p">)</span>
    <span class="n">fft_ops</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># 3 separate FFTs of size full_out_shape</span>
    <span class="k">return</span> <span class="n">fft_ops</span><span class="p">,</span> <span class="n">direct_ops</span>


<span class="k">def</span> <span class="nf">_fftconv_faster</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if using fftconvolve or convolve is faster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        Signal</span>
<span class="sd">    h : np.ndarray</span>
<span class="sd">        Kernel</span>
<span class="sd">    mode : str</span>
<span class="sd">        Mode passed to convolve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fft_faster : bool</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See docstring of `choose_conv_method` for details on tuning hardware.</span>

<span class="sd">    See pull request 11031 for more detail:</span>
<span class="sd">    https://github.com/scipy/scipy/pull/11031.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fft_ops</span><span class="p">,</span> <span class="n">direct_ops</span> <span class="o">=</span> <span class="n">_conv_ops</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-3</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1e-4</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;valid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.89095737e-9</span><span class="p">,</span> <span class="mf">2.1364985e-10</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span>
            <span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.7649070e-9</span><span class="p">,</span> <span class="mf">2.1414831e-10</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span>
            <span class="s2">&quot;same&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">3.2646654e-9</span><span class="p">,</span> <span class="mf">2.8478277e-10</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span> <span class="p">(</span><span class="mf">3.21635404e-9</span><span class="p">,</span> <span class="mf">1.1773253e-8</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e-5</span><span class="p">),</span>
    <span class="p">}</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span>
            <span class="s2">&quot;valid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.85927e-9</span><span class="p">,</span> <span class="mf">2.11242e-8</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span>
            <span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.99817e-9</span><span class="p">,</span> <span class="mf">1.66174e-8</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span>
            <span class="s2">&quot;same&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.04735e-9</span><span class="p">,</span> <span class="mf">1.55367e-8</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="n">O_fft</span><span class="p">,</span> <span class="n">O_direct</span><span class="p">,</span> <span class="n">O_offset</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">O_fft</span> <span class="o">*</span> <span class="n">fft_ops</span> <span class="o">&lt;</span> <span class="n">O_direct</span> <span class="o">*</span> <span class="n">direct_ops</span> <span class="o">+</span> <span class="n">O_offset</span>


<span class="k">def</span> <span class="nf">_reverse_and_conj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse array `x` in all dimensions and perform the complex conjugate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reverse</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">reverse</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_np_conv_ok</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if numpy supports convolution of `volume` and `kernel` (i.e. both are</span>
<span class="sd">    1D ndarrays and of the appropriate shape).  NumPy&#39;s &#39;same&#39; mode uses the</span>
<span class="sd">    size of the larger input, while SciPy&#39;s uses the size of the first input.</span>

<span class="sd">    Invalid mode strings will return False and be caught by the calling func.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">volume</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_timeit_fast</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the time the statement/function took, in seconds.</span>

<span class="sd">    Faster, less precise version of IPython&#39;s timeit. `stmt` can be a statement</span>
<span class="sd">    written as a string or a callable.</span>

<span class="sd">    Will do only 1 loop (like IPython&#39;s timeit) with no repetitions</span>
<span class="sd">    (unlike IPython) for very slow functions.  For fast functions, only does</span>
<span class="sd">    enough loops to take 5 ms, which seems to produce similar results (on</span>
<span class="sd">    Windows at least), and avoids doing an extraneous cycle that isn&#39;t</span>
<span class="sd">    measured.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timer</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">setup</span><span class="p">)</span>

    <span class="c1"># determine number of calls per rep so total time for 1 rep &gt;= 5 ms</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">p</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>  <span class="c1"># seconds</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">5e-3</span> <span class="o">/</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># 5 ms for final test, 1/10th that for this one</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># second</span>
        <span class="c1"># If it&#39;s macroscopic, don&#39;t bother with repetitions</span>
        <span class="n">best</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">number</span> <span class="o">*=</span> <span class="mi">10</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>
        <span class="n">best</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="n">sec</span> <span class="o">=</span> <span class="n">best</span> <span class="o">/</span> <span class="n">number</span>
    <span class="k">return</span> <span class="n">sec</span>


<span class="k">def</span> <span class="nf">choose_conv_method</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the fastest convolution/correlation method.</span>

<span class="sd">    This primarily exists to be called during the ``method=&#39;auto&#39;`` option in</span>
<span class="sd">    `convolve` and `correlate`. It can also be used to determine the value of</span>
<span class="sd">    ``method`` for many different convolutions of the same dtype/shape.</span>
<span class="sd">    In addition, it supports timing the convolution to adapt the value of</span>
<span class="sd">    ``method`` to a particular set of inputs and/or hardware.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        The first argument passed into the convolution function.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        The second argument passed into the convolution function.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    measure : bool, optional</span>
<span class="sd">        If True, run and time the convolution of `in1` and `in2` with both</span>
<span class="sd">        methods and return the fastest. If False (default), predict the fastest</span>
<span class="sd">        method using precomputed values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    method : str</span>
<span class="sd">        A string indicating which convolution method is fastest, either</span>
<span class="sd">        &#39;direct&#39; or &#39;fft&#39;</span>
<span class="sd">    times : dict, optional</span>
<span class="sd">        A dictionary containing the times (in seconds) needed for each method.</span>
<span class="sd">        This value is only returned if ``measure=True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve</span>
<span class="sd">    correlate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Generally, this method is 99% accurate for 2D signals and 85% accurate</span>
<span class="sd">    for 1D signals for randomly chosen input sizes. For precision, use</span>
<span class="sd">    ``measure=True`` to find the fastest method by timing the convolution.</span>
<span class="sd">    This can be used to avoid the minimal overhead of finding the fastest</span>
<span class="sd">    ``method`` later, or to adapt the value of ``method`` to a particular set</span>
<span class="sd">    of inputs.</span>

<span class="sd">    Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this</span>
<span class="sd">    function. These experiments measured the ratio between the time required</span>
<span class="sd">    when using ``method=&#39;auto&#39;`` and the time required for the fastest method</span>
<span class="sd">    (i.e., ``ratio = time_auto / min(time_fft, time_direct)``). In these</span>
<span class="sd">    experiments, we found:</span>

<span class="sd">    * There is a 95% chance of this ratio being less than 1.5 for 1D signals</span>
<span class="sd">      and a 99% chance of being less than 2.5 for 2D signals.</span>
<span class="sd">    * The ratio was always less than 2.5/5 for 1D/2D signals respectively.</span>
<span class="sd">    * This function is most inaccurate for 1D convolutions that take between 1</span>
<span class="sd">      and 10 milliseconds with ``method=&#39;direct&#39;``. A good proxy for this</span>
<span class="sd">      (at least in our experiments) is ``1e6 &lt;= in1.size * in2.size &lt;= 1e7``.</span>

<span class="sd">    The 2D results almost certainly generalize to 3D/4D/etc because the</span>
<span class="sd">    implementation is the same (the 1D implementation is different).</span>

<span class="sd">    All the numbers above are specific to the EC2 machine. However, we did find</span>
<span class="sd">    that this function generalizes fairly decently across hardware. The speed</span>
<span class="sd">    tests were of similar quality (and even slightly better) than the same</span>
<span class="sd">    tests performed on the machine to tune this function&#39;s numbers (a mid-2014</span>
<span class="sd">    15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor).</span>

<span class="sd">    There are cases when `fftconvolve` supports the inputs but this function</span>
<span class="sd">    returns `direct` (e.g., to protect against floating point integer</span>
<span class="sd">    precision).</span>

<span class="sd">    .. versionadded:: 0.19</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Estimate the fastest method for a given input:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; img = rng.random((32, 32))</span>
<span class="sd">    &gt;&gt;&gt; filter = rng.random((8, 8))</span>
<span class="sd">    &gt;&gt;&gt; method = signal.choose_conv_method(img, filter, mode=&#39;same&#39;)</span>
<span class="sd">    &gt;&gt;&gt; method</span>
<span class="sd">    &#39;fft&#39;</span>

<span class="sd">    This can then be applied to other arrays of the same dtype and shape:</span>

<span class="sd">    &gt;&gt;&gt; img2 = rng.random((32, 32))</span>
<span class="sd">    &gt;&gt;&gt; filter2 = rng.random((8, 8))</span>
<span class="sd">    &gt;&gt;&gt; corr2 = signal.correlate(img2, filter2, mode=&#39;same&#39;, method=method)</span>
<span class="sd">    &gt;&gt;&gt; conv2 = signal.convolve(img2, filter2, mode=&#39;same&#39;, method=method)</span>

<span class="sd">    The output of this function (``method``) works with `correlate` and</span>
<span class="sd">    `convolve`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">measure</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;direct&#39;</span><span class="p">]:</span>
            <span class="n">times</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">_timeit_fast</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">convolve</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span>
                                         <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>

        <span class="n">chosen_method</span> <span class="o">=</span> <span class="s1">&#39;fft&#39;</span> <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="s1">&#39;fft&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="s1">&#39;direct&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;direct&#39;</span>
        <span class="k">return</span> <span class="n">chosen_method</span><span class="p">,</span> <span class="n">times</span>

    <span class="c1"># for integer input,</span>
    <span class="c1"># catch when more precision required than float provides (representing an</span>
    <span class="c1"># integer as float can lose precision in fftconvolve if larger than 2**52)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">_numeric_arrays</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">kinds</span><span class="o">=</span><span class="s1">&#39;ui&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">]]):</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">max_value</span> <span class="o">*=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nmant</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>

    <span class="k">if</span> <span class="n">_numeric_arrays</span><span class="p">([</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">],</span> <span class="n">kinds</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>

    <span class="k">if</span> <span class="n">_numeric_arrays</span><span class="p">([</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">_fftconv_faster</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;fft&#39;</span>

    <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>


<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two N-dimensional arrays.</span>

<span class="sd">    Convolve `in1` and `in2`, with the output size determined by the</span>
<span class="sd">    `mode` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    method : str {&#39;auto&#39;, &#39;direct&#39;, &#39;fft&#39;}, optional</span>
<span class="sd">        A string indicating which method to use to calculate the convolution.</span>

<span class="sd">        ``direct``</span>
<span class="sd">           The convolution is determined directly from sums, the definition of</span>
<span class="sd">           convolution.</span>
<span class="sd">        ``fft``</span>
<span class="sd">           The Fourier Transform is used to perform the convolution by calling</span>
<span class="sd">           `fftconvolve`.</span>
<span class="sd">        ``auto``</span>
<span class="sd">           Automatically chooses direct or Fourier method based on an estimate</span>
<span class="sd">           of which is faster (default).  See Notes for more detail.</span>

<span class="sd">           .. versionadded:: 0.19.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    convolve : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.polymul : performs polynomial multiplication (same operation, but</span>
<span class="sd">                    also accepts poly1d objects)</span>
<span class="sd">    choose_conv_method : chooses the fastest appropriate convolution method</span>
<span class="sd">    fftconvolve : Always uses the FFT method.</span>
<span class="sd">    oaconvolve : Uses the overlap-add method to do convolution, which is</span>
<span class="sd">                 generally faster when the input arrays are large and</span>
<span class="sd">                 significantly different in size.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, `convolve` and `correlate` use ``method=&#39;auto&#39;``, which calls</span>
<span class="sd">    `choose_conv_method` to choose the fastest method using pre-computed</span>
<span class="sd">    values (`choose_conv_method` can also measure real-world timing with a</span>
<span class="sd">    keyword argument). Because `fftconvolve` relies on floating point numbers,</span>
<span class="sd">    there are certain constraints that may force `method=direct` (more detail</span>
<span class="sd">    in `choose_conv_method` docstring).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Smooth a square pulse using a Hann window:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; sig = np.repeat([0., 1., 0.], 100)</span>
<span class="sd">    &gt;&gt;&gt; win = signal.windows.hann(50)</span>
<span class="sd">    &gt;&gt;&gt; filtered = signal.convolve(sig, win, mode=&#39;same&#39;) / sum(win)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original pulse&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ax_win.plot(win)</span>
<span class="sd">    &gt;&gt;&gt; ax_win.set_title(&#39;Filter impulse response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_win.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ax_filt.plot(filtered)</span>
<span class="sd">    &gt;&gt;&gt; ax_filt.set_title(&#39;Filtered signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_filt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">volume</span> <span class="o">*</span> <span class="n">kernel</span>
    <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;volume and kernel should have the same &quot;</span>
                         <span class="s2">&quot;dimensionality&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="c1"># Convolution is commutative; order doesn&#39;t have any effect on output</span>
        <span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">volume</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">choose_conv_method</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;fft&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">}:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">:</span>
        <span class="c1"># fastpath to faster numpy.convolve for 1d inputs when possible</span>
        <span class="k">if</span> <span class="n">_np_conv_ok</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">correlate</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">_reverse_and_conj</span><span class="p">(</span><span class="n">kernel</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;direct&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable method flags are &#39;auto&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;direct&#39;, or &#39;fft&#39;.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">order_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an order filter on an N-D array.</span>

<span class="sd">    Perform an order filter on the array in. The domain argument acts as a</span>
<span class="sd">    mask centered over each pixel. The non-zero elements of domain are</span>
<span class="sd">    used to select elements surrounding each input pixel which are placed</span>
<span class="sd">    in a list. The list is sorted, and the output for that pixel is the</span>
<span class="sd">    element corresponding to rank in the sorted list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        The N-dimensional input array.</span>
<span class="sd">    domain : array_like</span>
<span class="sd">        A mask array with the same number of dimensions as `a`.</span>
<span class="sd">        Each dimension should have an odd number of elements.</span>
<span class="sd">    rank : int</span>
<span class="sd">        A non-negative integer which selects the element from the</span>
<span class="sd">        sorted list (0 corresponds to the smallest element, 1 is the</span>
<span class="sd">        next smallest element, etc.).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The results of the order filter in an array with the same</span>
<span class="sd">        shape as `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(25).reshape(5, 5)</span>
<span class="sd">    &gt;&gt;&gt; domain = np.identity(3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8,  9],</span>
<span class="sd">           [10, 11, 12, 13, 14],</span>
<span class="sd">           [15, 16, 17, 18, 19],</span>
<span class="sd">           [20, 21, 22, 23, 24]])</span>
<span class="sd">    &gt;&gt;&gt; signal.order_filter(x, domain, 0)</span>
<span class="sd">    array([[  0.,   0.,   0.,   0.,   0.],</span>
<span class="sd">           [  0.,   0.,   1.,   2.,   0.],</span>
<span class="sd">           [  0.,   5.,   6.,   7.,   0.],</span>
<span class="sd">           [  0.,  10.,  11.,  12.,   0.],</span>
<span class="sd">           [  0.,   0.,   0.,   0.,   0.]])</span>
<span class="sd">    &gt;&gt;&gt; signal.order_filter(x, domain, 2)</span>
<span class="sd">    array([[  6.,   7.,   8.,   9.,   4.],</span>
<span class="sd">           [ 11.,  12.,  13.,  14.,   9.],</span>
<span class="sd">           [ 16.,  17.,  18.,  19.,  14.],</span>
<span class="sd">           [ 21.,  22.,  23.,  24.,  19.],</span>
<span class="sd">           [ 20.,  21.,  22.,  23.,  24.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each dimension of domain argument &quot;</span>
                             <span class="s2">&quot; should have an odd number of elements.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_order_filterND</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">medfilt</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a median filter on an N-dimensional array.</span>

<span class="sd">    Apply a median filter to the input array using a local window-size</span>
<span class="sd">    given by `kernel_size`. The array will automatically be zero-padded.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    volume : array_like</span>
<span class="sd">        An N-dimensional input array.</span>
<span class="sd">    kernel_size : array_like, optional</span>
<span class="sd">        A scalar or an N-length list giving the size of the median filter</span>
<span class="sd">        window in each dimension.  Elements of `kernel_size` should be odd.</span>
<span class="sd">        If `kernel_size` is a scalar, then this scalar is used as the size in</span>
<span class="sd">        each dimension. Default size is 3 for each dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        An array the same size as input containing the median filtered</span>
<span class="sd">        result.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If array size is smaller than kernel size along any dimension</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.ndimage.median_filter</span>
<span class="sd">    scipy.signal.medfilt2d</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The more general function `scipy.ndimage.median_filter` has a more</span>
<span class="sd">    efficient implementation of a median filter and therefore runs much faster.</span>

<span class="sd">    For 2-dimensional images with ``uint8``, ``float32`` or ``float64`` dtypes,</span>
<span class="sd">    the specialised function `scipy.signal.medfilt2d` may be faster.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kernel_size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each element of kernel_size should be odd.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;kernel_size exceeds volume extent: the volume will be &#39;</span>
                      <span class="s1">&#39;zero-padded.&#39;</span><span class="p">)</span>

    <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">volume</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">numels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">numels</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_order_filterND</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">wiener</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">mysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a Wiener filter on an N-dimensional array.</span>

<span class="sd">    Apply a Wiener filter to the N-dimensional array `im`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An N-dimensional array.</span>
<span class="sd">    mysize : int or array_like, optional</span>
<span class="sd">        A scalar or an N-length list giving the size of the Wiener filter</span>
<span class="sd">        window in each dimension.  Elements of mysize should be odd.</span>
<span class="sd">        If mysize is a scalar, then this scalar is used as the size</span>
<span class="sd">        in each dimension.</span>
<span class="sd">    noise : float, optional</span>
<span class="sd">        The noise-power to use. If None, then noise is estimated as the</span>
<span class="sd">        average of the local variance of the input.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Wiener filtered result with the same shape as `im`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from scipy.misc import face</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal.signaltools import wiener</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; img = rng.random((40, 40))    #Create a random image</span>
<span class="sd">    &gt;&gt;&gt; filtered_img = wiener(img, (5, 5))  #Filter the image</span>
<span class="sd">    &gt;&gt;&gt; f, (plot1, plot2) = plt.subplots(1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plot1.imshow(img)</span>
<span class="sd">    &gt;&gt;&gt; plot2.imshow(filtered_img)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This implementation is similar to wiener2 in Matlab/Octave.</span>
<span class="sd">    For more details see [1]_</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lim, Jae S., Two-Dimensional Signal and Image Processing,</span>
<span class="sd">           Englewood Cliffs, NJ, Prentice Hall, 1990, p. 548.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mysize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mysize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">mysize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mysize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mysize</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">mysize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">mysize</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="c1"># Estimate the local mean</span>
    <span class="n">lMean</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mysize</span><span class="p">),</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mysize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Estimate the local variance</span>
    <span class="n">lVar</span> <span class="o">=</span> <span class="p">(</span><span class="n">correlate</span><span class="p">(</span><span class="n">im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mysize</span><span class="p">),</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span>
            <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mysize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">lMean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Estimate the noise power if needed.</span>
    <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">lVar</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">im</span> <span class="o">-</span> <span class="n">lMean</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">noise</span> <span class="o">/</span> <span class="n">lVar</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">lMean</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lVar</span> <span class="o">&lt;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lMean</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">convolve2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two 2-dimensional arrays.</span>

<span class="sd">    Convolve `in1` and `in2` with output size determined by `mode`, and</span>
<span class="sd">    boundary conditions determined by `boundary` and `fillvalue`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    boundary : str {&#39;fill&#39;, &#39;wrap&#39;, &#39;symm&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">        ``fill``</span>
<span class="sd">           pad input arrays with fillvalue. (default)</span>
<span class="sd">        ``wrap``</span>
<span class="sd">           circular boundary conditions.</span>
<span class="sd">        ``symm``</span>
<span class="sd">           symmetrical boundary conditions.</span>

<span class="sd">    fillvalue : scalar, optional</span>
<span class="sd">        Value to fill pad input arrays with. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A 2-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the gradient of an image by 2D convolution with a complex Scharr</span>
<span class="sd">    operator.  (Horizontal operator is real, vertical is imaginary.)  Use</span>
<span class="sd">    symmetric boundary condition to avoid creating edges at the image</span>
<span class="sd">    boundaries.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; from scipy import misc</span>
<span class="sd">    &gt;&gt;&gt; ascent = misc.ascent()</span>
<span class="sd">    &gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],</span>
<span class="sd">    ...                    [-10+0j, 0+ 0j, +10 +0j],</span>
<span class="sd">    ...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy</span>
<span class="sd">    &gt;&gt;&gt; grad = signal.convolve2d(ascent, scharr, boundary=&#39;symm&#39;, mode=&#39;same&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.imshow(ascent, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_title(&#39;Gradient magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap=&#39;hsv&#39;) # hsv is cyclic, like angles</span>
<span class="sd">    &gt;&gt;&gt; ax_ang.set_title(&#39;Gradient orientation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_ang.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;convolve2d inputs must both be 2-D arrays&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">_valfrommode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">bval</span> <span class="o">=</span> <span class="n">_bvalfromboundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_convolve2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bval</span><span class="p">,</span> <span class="n">fillvalue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">correlate2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlate two 2-dimensional arrays.</span>

<span class="sd">    Cross correlate `in1` and `in2` with output size determined by `mode`, and</span>
<span class="sd">    boundary conditions determined by `boundary` and `fillvalue`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear cross-correlation</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    boundary : str {&#39;fill&#39;, &#39;wrap&#39;, &#39;symm&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">        ``fill``</span>
<span class="sd">           pad input arrays with fillvalue. (default)</span>
<span class="sd">        ``wrap``</span>
<span class="sd">           circular boundary conditions.</span>
<span class="sd">        ``symm``</span>
<span class="sd">           symmetrical boundary conditions.</span>

<span class="sd">    fillvalue : scalar, optional</span>
<span class="sd">        Value to fill pad input arrays with. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlate2d : ndarray</span>
<span class="sd">        A 2-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        cross-correlation of `in1` with `in2`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When using &quot;same&quot; mode with even-length inputs, the outputs of `correlate`</span>
<span class="sd">    and `correlate2d` differ: There is a 1-index offset between them.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use 2D cross-correlation to find the location of a template in a noisy</span>
<span class="sd">    image:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; from scipy import misc</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; face = misc.face(gray=True) - misc.face(gray=True).mean()</span>
<span class="sd">    &gt;&gt;&gt; template = np.copy(face[300:365, 670:750])  # right eye</span>
<span class="sd">    &gt;&gt;&gt; template -= template.mean()</span>
<span class="sd">    &gt;&gt;&gt; face = face + rng.standard_normal(face.shape) * 50  # add noise</span>
<span class="sd">    &gt;&gt;&gt; corr = signal.correlate2d(face, template, boundary=&#39;symm&#39;, mode=&#39;same&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,</span>
<span class="sd">    ...                                                     figsize=(6, 15))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.imshow(face, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_template.imshow(template, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_template.set_title(&#39;Template&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_template.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.imshow(corr, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(x, y, &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;correlate2d inputs must both be 2-D arrays&#39;</span><span class="p">)</span>

    <span class="n">swapped_inputs</span> <span class="o">=</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">_valfrommode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">bval</span> <span class="o">=</span> <span class="n">_bvalfromboundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_convolve2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bval</span><span class="p">,</span> <span class="n">fillvalue</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">medfilt2d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Median filter a 2-dimensional array.</span>

<span class="sd">    Apply a median filter to the `input` array using a local window-size</span>
<span class="sd">    given by `kernel_size` (must be odd). The array is zero-padded</span>
<span class="sd">    automatically.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        A 2-dimensional input array.</span>
<span class="sd">    kernel_size : array_like, optional</span>
<span class="sd">        A scalar or a list of length 2, giving the size of the</span>
<span class="sd">        median filter window in each dimension.  Elements of</span>
<span class="sd">        `kernel_size` should be odd.  If `kernel_size` is a scalar,</span>
<span class="sd">        then this scalar is used as the size in each dimension.</span>
<span class="sd">        Default is a kernel of size (3, 3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        An array the same size as input containing the median filtered</span>
<span class="sd">        result.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.ndimage.median_filter</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is faster than `medfilt` when the input dtype is ``uint8``,</span>
<span class="sd">    ``float32``, or ``float64``; for other types, this falls back to</span>
<span class="sd">    `medfilt`; you should use `scipy.ndimage.median_filter` instead as it is</span>
<span class="sd">    much faster.  In some situations, `scipy.ndimage.median_filter` may be</span>
<span class="sd">    faster than this function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="c1"># checking dtype.type, rather than just dtype, is necessary for</span>
    <span class="c1"># excluding np.longdouble with MS Visual C.</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">medfilt</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kernel_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">kernel_size</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each element of kernel_size should be odd.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_medfilt2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>


<div class="viewcode-block" id="lfilter"><a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.filter.lfilter">[docs]</a><span class="k">def</span> <span class="nf">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter data along one-dimension with an IIR or FIR filter.</span>

<span class="sd">    Filter a data sequence, `x`, using a digital filter.  This works for many</span>
<span class="sd">    fundamental data types (including Object type).  The filter is a direct</span>
<span class="sd">    form II transposed implementation of the standard difference equation</span>
<span class="sd">    (see Notes).</span>

<span class="sd">    The function `sosfilt` (and filter design using ``output=&#39;sos&#39;``) should be</span>
<span class="sd">    preferred over `lfilter` for most filtering tasks, as second-order sections</span>
<span class="sd">    have fewer numerical problems.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        The numerator coefficient vector in a 1-D sequence.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The denominator coefficient vector in a 1-D sequence.  If ``a[0]``</span>
<span class="sd">        is not 1, then both `a` and `b` are normalized by ``a[0]``.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        An N-dimensional input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of the input data array along which to apply the</span>
<span class="sd">        linear filter. The filter is applied to each subarray along</span>
<span class="sd">        this axis.  Default is -1.</span>
<span class="sd">    zi : array_like, optional</span>
<span class="sd">        Initial conditions for the filter delays.  It is a vector</span>
<span class="sd">        (or array of vectors for an N-dimensional input) of length</span>
<span class="sd">        ``max(len(a), len(b)) - 1``.  If `zi` is None or is not given then</span>
<span class="sd">        initial rest is assumed.  See `lfiltic` for more information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : array</span>
<span class="sd">        The output of the digital filter.</span>
<span class="sd">    zf : array, optional</span>
<span class="sd">        If `zi` is None, this is not returned, otherwise, `zf` holds the</span>
<span class="sd">        final filter delay values.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lfiltic : Construct initial conditions for `lfilter`.</span>
<span class="sd">    lfilter_zi : Compute initial state (steady state of step response) for</span>
<span class="sd">                 `lfilter`.</span>
<span class="sd">    filtfilt : A forward-backward filter, to obtain a filter with linear phase.</span>
<span class="sd">    savgol_filter : A Savitzky-Golay filter.</span>
<span class="sd">    sosfilt: Filter data using cascaded second-order sections.</span>
<span class="sd">    sosfiltfilt: A forward-backward filter using second-order sections.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The filter function is implemented as a direct II transposed structure.</span>
<span class="sd">    This means that the filter implements::</span>

<span class="sd">       a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[M]*x[n-M]</span>
<span class="sd">                             - a[1]*y[n-1] - ... - a[N]*y[n-N]</span>

<span class="sd">    where `M` is the degree of the numerator, `N` is the degree of the</span>
<span class="sd">    denominator, and `n` is the sample number.  It is implemented using</span>
<span class="sd">    the following difference equations (assuming M = N)::</span>

<span class="sd">         a[0]*y[n] = b[0] * x[n]               + d[0][n-1]</span>
<span class="sd">           d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1]</span>
<span class="sd">           d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1]</span>
<span class="sd">         ...</span>
<span class="sd">         d[N-2][n] = b[N-1]*x[n] - a[N-1]*y[n] + d[N-1][n-1]</span>
<span class="sd">         d[N-1][n] = b[N] * x[n] - a[N] * y[n]</span>

<span class="sd">    where `d` are the state variables.</span>

<span class="sd">    The rational transfer function describing this filter in the</span>
<span class="sd">    z-transform domain is::</span>

<span class="sd">                             -1              -M</span>
<span class="sd">                 b[0] + b[1]z  + ... + b[M] z</span>
<span class="sd">         Y(z) = -------------------------------- X(z)</span>
<span class="sd">                             -1              -N</span>
<span class="sd">                 a[0] + a[1]z  + ... + a[N] z</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate a noisy signal to be filtered:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(-1, 1, 201)</span>
<span class="sd">    &gt;&gt;&gt; x = (np.sin(2*np.pi*0.75*t*(1-t) + 2.1) +</span>
<span class="sd">    ...      0.1*np.sin(2*np.pi*1.25*t + 1) +</span>
<span class="sd">    ...      0.18*np.cos(2*np.pi*3.85*t))</span>
<span class="sd">    &gt;&gt;&gt; xn = x + rng.standard_normal(len(t)) * 0.08</span>

<span class="sd">    Create an order 3 lowpass butterworth filter:</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(3, 0.05)</span>

<span class="sd">    Apply the filter to xn.  Use lfilter_zi to choose the initial condition of</span>
<span class="sd">    the filter:</span>

<span class="sd">    &gt;&gt;&gt; zi = signal.lfilter_zi(b, a)</span>
<span class="sd">    &gt;&gt;&gt; z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0])</span>

<span class="sd">    Apply the filter again, to have a result filtered at an order the same as</span>
<span class="sd">    filtfilt:</span>

<span class="sd">    &gt;&gt;&gt; z2, _ = signal.lfilter(b, a, z, zi=zi*z[0])</span>

<span class="sd">    Use filtfilt to apply the filter:</span>

<span class="sd">    &gt;&gt;&gt; y = signal.filtfilt(b, a, xn)</span>

<span class="sd">    Plot the original signal and the various filtered versions:</span>

<span class="sd">    &gt;&gt;&gt; plt.figure</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, xn, &#39;b&#39;, alpha=0.75)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, z, &#39;r--&#39;, t, z2, &#39;r&#39;, t, y, &#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend((&#39;noisy signal&#39;, &#39;lfilter, once&#39;, &#39;lfilter, twice&#39;,</span>
<span class="sd">    ...             &#39;filtfilt&#39;), loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># This path only supports types fdgFDGO to mirror _linear_filter below.</span>
        <span class="c1"># Any of b, a, x, or zi can set the dtype, but there is no default</span>
        <span class="c1"># casting of other types; instead a NotImplementedError is raised.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object of too small depth for desired array&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_validate_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># _linear_filter does not broadcast zi, but does do expansion of</span>
            <span class="c1"># singleton dims.</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object of too small depth for desired array&#39;</span><span class="p">)</span>
            <span class="n">expected_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">expected_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">expected_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">expected_shape</span><span class="p">)</span>
            <span class="c1"># check the trivial case where zi is the right shape first</span>
            <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
                <span class="n">strides</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">+=</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected shape for zi: expected &#39;</span>
                                         <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, found </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="n">expected_shape</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">expected_shape</span><span class="p">,</span>
                                                     <span class="n">strides</span><span class="p">)</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;fdgFDGO&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;input type &#39;</span><span class="si">%s</span><span class="s2">&#39; not supported&quot;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">/=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">out_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">out_full</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="n">out_full</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">zi</span>

        <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">out_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out_full</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">out_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">zf</span> <span class="o">=</span> <span class="n">out_full</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">zf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_linear_filter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_linear_filter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">lfiltic</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct initial conditions for lfilter given input and output vectors.</span>

<span class="sd">    Given a linear filter (b, a) and initial conditions on the output `y`</span>
<span class="sd">    and the input `x`, return the initial conditions on the state vector zi</span>
<span class="sd">    which is used by `lfilter` to generate the output given the input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Linear filter term.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Linear filter term.</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Initial conditions.</span>

<span class="sd">        If ``N = len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.</span>

<span class="sd">        If `y` is too short, it is padded with zeros.</span>
<span class="sd">    x : array_like, optional</span>
<span class="sd">        Initial conditions.</span>

<span class="sd">        If ``M = len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.</span>

<span class="sd">        If `x` is not given, its initial conditions are assumed zero.</span>

<span class="sd">        If `x` is too short, it is padded with zeros.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zi : ndarray</span>
<span class="sd">        The state vector ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``,</span>
<span class="sd">        where ``K = max(M, N)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lfilter, lfilter_zi</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;bui&#39;</span><span class="p">:</span>
            <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_type</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;bui&#39;</span><span class="p">:</span>
            <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">L</span><span class="p">)]</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">result_type</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">L</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[:</span><span class="n">N</span> <span class="o">-</span> <span class="n">m</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">zi</span>


<span class="k">def</span> <span class="nf">deconvolve</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">divisor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deconvolves ``divisor`` out of ``signal`` using inverse filtering.</span>

<span class="sd">    Returns the quotient and remainder such that</span>
<span class="sd">    ``signal = convolve(divisor, quotient) + remainder``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : array_like</span>
<span class="sd">        Signal data, typically a recorded signal</span>
<span class="sd">    divisor : array_like</span>
<span class="sd">        Divisor data, typically an impulse response or filter that was</span>
<span class="sd">        applied to the original signal</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quotient : ndarray</span>
<span class="sd">        Quotient, typically the recovered original signal</span>
<span class="sd">    remainder : ndarray</span>
<span class="sd">        Remainder</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Deconvolve a signal that&#39;s been filtered:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; original = [0, 1, 0, 0, 1, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; impulse_response = [2, 1]</span>
<span class="sd">    &gt;&gt;&gt; recorded = signal.convolve(impulse_response, original)</span>
<span class="sd">    &gt;&gt;&gt; recorded</span>
<span class="sd">    array([0, 2, 1, 0, 2, 3, 1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; recovered, remainder = signal.deconvolve(recorded, impulse_response)</span>
<span class="sd">    &gt;&gt;&gt; recovered</span>
<span class="sd">    array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.polydiv : performs polynomial division (same operation, but</span>
<span class="sd">                    also accepts poly1d objects)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">divisor</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">quot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">num</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">quot</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">convolve</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">quot</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span>


<span class="k">def</span> <span class="nf">hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the analytic signal, using the Hilbert transform.</span>

<span class="sd">    The transformation is done along the last axis by default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Signal data.  Must be real.</span>
<span class="sd">    N : int, optional</span>
<span class="sd">        Number of Fourier components.  Default: ``x.shape[axis]``</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to do the transformation.  Default: -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xa : ndarray</span>
<span class="sd">        Analytic signal of `x`, of each 1-D array along `axis`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The analytic signal ``x_a(t)`` of signal ``x(t)`` is:</span>

<span class="sd">    .. math:: x_a = F^{-1}(F(x) 2U) = x + i y</span>

<span class="sd">    where `F` is the Fourier transform, `U` the unit step function,</span>
<span class="sd">    and `y` the Hilbert transform of `x`. [1]_</span>

<span class="sd">    In other words, the negative half of the frequency spectrum is zeroed</span>
<span class="sd">    out, turning the real-valued signal into a complex signal.  The Hilbert</span>
<span class="sd">    transformed signal can be obtained from ``np.imag(hilbert(x))``, and the</span>
<span class="sd">    original signal from ``np.real(hilbert(x))``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example we use the Hilbert transform to determine the amplitude</span>
<span class="sd">    envelope and instantaneous frequency of an amplitude-modulated signal.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import hilbert, chirp</span>

<span class="sd">    &gt;&gt;&gt; duration = 1.0</span>
<span class="sd">    &gt;&gt;&gt; fs = 400.0</span>
<span class="sd">    &gt;&gt;&gt; samples = int(fs*duration)</span>
<span class="sd">    &gt;&gt;&gt; t = np.arange(samples) / fs</span>

<span class="sd">    We create a chirp of which the frequency increases from 20 Hz to 100 Hz and</span>
<span class="sd">    apply an amplitude modulation.</span>

<span class="sd">    &gt;&gt;&gt; signal = chirp(t, 20.0, t[-1], 100.0)</span>
<span class="sd">    &gt;&gt;&gt; signal *= (1.0 + 0.5 * np.sin(2.0*np.pi*3.0*t) )</span>

<span class="sd">    The amplitude envelope is given by magnitude of the analytic signal. The</span>
<span class="sd">    instantaneous frequency can be obtained by differentiating the</span>
<span class="sd">    instantaneous phase in respect to time. The instantaneous phase corresponds</span>
<span class="sd">    to the phase angle of the analytic signal.</span>

<span class="sd">    &gt;&gt;&gt; analytic_signal = hilbert(signal)</span>
<span class="sd">    &gt;&gt;&gt; amplitude_envelope = np.abs(analytic_signal)</span>
<span class="sd">    &gt;&gt;&gt; instantaneous_phase = np.unwrap(np.angle(analytic_signal))</span>
<span class="sd">    &gt;&gt;&gt; instantaneous_frequency = (np.diff(instantaneous_phase) /</span>
<span class="sd">    ...                            (2.0*np.pi) * fs)</span>

<span class="sd">    &gt;&gt;&gt; fig, (ax0, ax1) = plt.subplots(nrows=2)</span>
<span class="sd">    &gt;&gt;&gt; ax0.plot(t, signal, label=&#39;signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax0.plot(t, amplitude_envelope, label=&#39;envelope&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax0.set_xlabel(&quot;time in seconds&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax0.legend()</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(t[1:], instantaneous_frequency)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_xlabel(&quot;time in seconds&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_ylim(0.0, 120.0)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Analytic signal&quot;.</span>
<span class="sd">           https://en.wikipedia.org/wiki/Analytic_signal</span>
<span class="sd">    .. [2] Leon Cohen, &quot;Time-Frequency Analysis&quot;, 1995. Chapter 2.</span>
<span class="sd">    .. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal</span>
<span class="sd">           Processing, Third Edition, 2009. Chapter 12.</span>
<span class="sd">           ISBN 13: 978-1292-02572-8</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be real.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be positive.&quot;</span><span class="p">)</span>

    <span class="n">Xf</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Xf</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">hilbert2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the &#39;2-D&#39; analytic signal of `x`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        2-D signal data.</span>
<span class="sd">    N : int or tuple of two ints, optional</span>
<span class="sd">        Number of Fourier components. Default is ``x.shape``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xa : ndarray</span>
<span class="sd">        Analytic signal of `x` taken along axes (0,1).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Analytic signal&quot;,</span>
<span class="sd">        https://en.wikipedia.org/wiki/Analytic_signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 2-D.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be real.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be positive.&quot;</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When given as a tuple, N must hold exactly &quot;</span>
                         <span class="s2">&quot;two positive integers&quot;</span><span class="p">)</span>

    <span class="n">Xf</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">h1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">h2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;h</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">N1</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">N1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">N1</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N1</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">N1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">exec</span><span class="p">(</span><span class="s2">&quot;h</span><span class="si">%d</span><span class="s2"> = h&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">())</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">Xf</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">cmplx_sort</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort roots based on magnitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        The roots to sort, as a 1-D array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p_sorted : ndarray</span>
<span class="sd">        Sorted roots.</span>
<span class="sd">    indx : ndarray</span>
<span class="sd">        Array of indices needed to sort the input `p`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; vals = [1, 4, 1+1.j, 3]</span>
<span class="sd">    &gt;&gt;&gt; p_sorted, indx = signal.cmplx_sort(vals)</span>
<span class="sd">    &gt;&gt;&gt; p_sorted</span>
<span class="sd">    array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])</span>
<span class="sd">    &gt;&gt;&gt; indx</span>
<span class="sd">    array([0, 2, 3, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">indx</span>


<span class="k">def</span> <span class="nf">unique_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine unique roots and their multiplicities from a list of roots.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        The list of roots.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal in terms of</span>
<span class="sd">        the distance between them. Default is 1e-3. Refer to Notes about</span>
<span class="sd">        the details on roots grouping.</span>
<span class="sd">    rtype : {&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}, optional</span>
<span class="sd">        How to determine the returned root if multiple roots are within</span>
<span class="sd">        `tol` of each other.</span>

<span class="sd">          - &#39;max&#39;, &#39;maximum&#39;: pick the maximum of those roots</span>
<span class="sd">          - &#39;min&#39;, &#39;minimum&#39;: pick the minimum of those roots</span>
<span class="sd">          - &#39;avg&#39;, &#39;mean&#39;: take the average of those roots</span>

<span class="sd">        When finding minimum or maximum among complex roots they are compared</span>
<span class="sd">        first by the real part and then by the imaginary part.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unique : ndarray</span>
<span class="sd">        The list of unique roots.</span>
<span class="sd">    multiplicity : ndarray</span>
<span class="sd">        The multiplicity of each root.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If we have 3 roots ``a``, ``b`` and ``c``, such that ``a`` is close to</span>
<span class="sd">    ``b`` and ``b`` is close to ``c`` (distance is less than `tol`), then it</span>
<span class="sd">    doesn&#39;t necessarily mean that ``a`` is close to ``c``. It means that roots</span>
<span class="sd">    grouping is not unique. In this function we use &quot;greedy&quot; grouping going</span>
<span class="sd">    through the roots in the order they are given in the input `p`.</span>

<span class="sd">    This utility function is not specific to roots but can be used for any</span>
<span class="sd">    sequence of values for which uniqueness and multiplicity has to be</span>
<span class="sd">    determined. For a more general routine, see `numpy.unique`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]</span>
<span class="sd">    &gt;&gt;&gt; uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype=&#39;avg&#39;)</span>

<span class="sd">    Check which roots have multiplicity larger than 1:</span>

<span class="sd">    &gt;&gt;&gt; uniq[mult &gt; 1]</span>
<span class="sd">    array([ 1.305])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">]:</span>
        <span class="n">reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
    <span class="k">elif</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum&#39;</span><span class="p">]:</span>
        <span class="n">reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span>
    <span class="k">elif</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
        <span class="n">reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`rtype` must be one of &quot;</span>
                         <span class="s2">&quot;{&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}&quot;</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="n">p_unique</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p_multiplicity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="n">group</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>

        <span class="n">p_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">group</span><span class="p">]))</span>
        <span class="n">p_multiplicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>

        <span class="n">used</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p_unique</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p_multiplicity</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">invres</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute b(s) and a(s) from partial fraction expansion.</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]</span>
<span class="sd">      H(s) = ------ = ------------------------------------------</span>
<span class="sd">              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</span>

<span class="sd">    then the partial-fraction expansion H(s) is defined as::</span>

<span class="sd">               r[0]       r[1]             r[-1]</span>
<span class="sd">           = -------- + -------- + ... + --------- + k(s)</span>
<span class="sd">             (s-p[0])   (s-p[1])         (s-p[-1])</span>

<span class="sd">    If there are any repeated roots (closer together than `tol`), then H(s)</span>
<span class="sd">    has terms like::</span>

<span class="sd">          r[i]      r[i+1]              r[i+n-1]</span>
<span class="sd">        -------- + ----------- + ... + -----------</span>
<span class="sd">        (s-p[i])  (s-p[i])**2          (s-p[i])**n</span>

<span class="sd">    This function is used for polynomials in positive powers of s or z,</span>
<span class="sd">    such as analog filters or digital filters in controls engineering.  For</span>
<span class="sd">    negative powers of z (typical for digital filters in DSP), use `invresz`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like</span>
<span class="sd">        Residues corresponding to the poles. For repeated poles, the residues</span>
<span class="sd">        must be ordered to correspond to ascending by power fractions.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles. Equal poles must be adjacent.</span>
<span class="sd">    k : array_like</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal in terms of</span>
<span class="sd">        the distance between them. Default is 1e-3. See `unique_roots`</span>
<span class="sd">        for further details.</span>
<span class="sd">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span>
<span class="sd">        Method for computing a root to represent a group of identical roots.</span>
<span class="sd">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    residue, invresz, unique_roots</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>

    <span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">_group_poles</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="p">)</span>
    <span class="n">factors</span><span class="p">,</span> <span class="n">denominator</span> <span class="o">=</span> <span class="n">_compute_factors</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span>
                                            <span class="n">include_powers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">residue</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">residue</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span>


<span class="k">def</span> <span class="nf">_compute_factors</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">include_powers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the total polynomial divided by factors for each root.&quot;&quot;&quot;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">current</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pole</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">multiplicity</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">monomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">pole</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mult</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">monomial</span><span class="p">)</span>
        <span class="n">suffixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="n">suffixes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">pole</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">):</span>
        <span class="n">monomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">pole</span><span class="p">])</span>
        <span class="n">block</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mult</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">include_powers</span><span class="p">:</span>
                <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">suffix</span><span class="p">))</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">monomial</span><span class="p">)</span>
        <span class="n">factors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">factors</span><span class="p">,</span> <span class="n">current</span>


<span class="k">def</span> <span class="nf">_compute_residues</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">numerator</span><span class="p">):</span>
    <span class="n">denominator_factors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_compute_factors</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">)</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">numerator</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">poles</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pole</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span>
                                  <span class="n">denominator_factors</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mult</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">residues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">pole</span><span class="p">)</span> <span class="o">/</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">pole</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numer</span> <span class="o">=</span> <span class="n">numerator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">monomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">pole</span><span class="p">])</span>
            <span class="n">factor</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polydiv</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">monomial</span><span class="p">)</span>

            <span class="n">block</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mult</span><span class="p">):</span>
                <span class="n">numer</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polydiv</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">monomial</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">numer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polysub</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

            <span class="n">residues</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">residue</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute partial-fraction expansion of b(s) / a(s).</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]</span>
<span class="sd">      H(s) = ------ = ------------------------------------------</span>
<span class="sd">              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</span>

<span class="sd">    then the partial-fraction expansion H(s) is defined as::</span>

<span class="sd">               r[0]       r[1]             r[-1]</span>
<span class="sd">           = -------- + -------- + ... + --------- + k(s)</span>
<span class="sd">             (s-p[0])   (s-p[1])         (s-p[-1])</span>

<span class="sd">    If there are any repeated roots (closer together than `tol`), then H(s)</span>
<span class="sd">    has terms like::</span>

<span class="sd">          r[i]      r[i+1]              r[i+n-1]</span>
<span class="sd">        -------- + ----------- + ... + -----------</span>
<span class="sd">        (s-p[i])  (s-p[i])**2          (s-p[i])**n</span>

<span class="sd">    This function is used for polynomials in positive powers of s or z,</span>
<span class="sd">    such as analog filters or digital filters in controls engineering.  For</span>
<span class="sd">    negative powers of z (typical for digital filters in DSP), use `residuez`.</span>

<span class="sd">    See Notes for details about the algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal in terms of</span>
<span class="sd">        the distance between them. Default is 1e-3. See `unique_roots`</span>
<span class="sd">        for further details.</span>
<span class="sd">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span>
<span class="sd">        Method for computing a root to represent a group of identical roots.</span>
<span class="sd">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        Residues corresponding to the poles. For repeated poles, the residues</span>
<span class="sd">        are ordered to correspond to ascending by power fractions.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles ordered by magnitude in ascending order.</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    invres, residuez, numpy.poly, unique_roots</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The &quot;deflation through subtraction&quot; algorithm is used for</span>
<span class="sd">    computations --- method 6 in [1]_.</span>

<span class="sd">    The form of partial fraction expansion depends on poles multiplicity in</span>
<span class="sd">    the exact mathematical sense. However there is no way to exactly</span>
<span class="sd">    determine multiplicity of roots of a polynomial in numerical computing.</span>
<span class="sd">    Thus you should think of the result of `residue` with given `tol` as</span>
<span class="sd">    partial fraction expansion computed for the denominator composed of the</span>
<span class="sd">    computed poles with empirically determined multiplicity. The choice of</span>
<span class="sd">    `tol` can drastically change the result if there are close poles.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. F. Mahoney, B. D. Sivazlian, &quot;Partial fractions expansion: a</span>
<span class="sd">           review of computational methodology and efficiency&quot;, Journal of</span>
<span class="sd">           Computational and Applied Mathematics, Vol. 9, 1983.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator `a` is zero.&quot;</span><span class="p">)</span>

    <span class="n">poles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">poles</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">poles</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polydiv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span>
    <span class="n">unique_poles</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">)</span>
    <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">multiplicity</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="n">residues</span> <span class="o">=</span> <span class="n">_compute_residues</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">pole</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">):</span>
        <span class="n">poles</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span> <span class="o">+</span> <span class="n">mult</span><span class="p">]</span> <span class="o">=</span> <span class="n">pole</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">mult</span>

    <span class="k">return</span> <span class="n">residues</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poles</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">residuez</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute partial-fraction expansion of b(z) / a(z).</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)</span>
<span class="sd">        H(z) = ------ = ------------------------------------------</span>
<span class="sd">                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</span>

<span class="sd">    then the partial-fraction expansion H(z) is defined as::</span>

<span class="sd">                 r[0]                   r[-1]</span>
<span class="sd">         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...</span>
<span class="sd">           (1-p[0]z**(-1))         (1-p[-1]z**(-1))</span>

<span class="sd">    If there are any repeated roots (closer than `tol`), then the partial</span>
<span class="sd">    fraction expansion has terms like::</span>

<span class="sd">             r[i]              r[i+1]                    r[i+n-1]</span>
<span class="sd">        -------------- + ------------------ + ... + ------------------</span>
<span class="sd">        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n</span>

<span class="sd">    This function is used for polynomials in negative powers of z,</span>
<span class="sd">    such as digital filters in DSP.  For positive powers, use `residue`.</span>

<span class="sd">    See Notes of `residue` for details about the algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal in terms of</span>
<span class="sd">        the distance between them. Default is 1e-3. See `unique_roots`</span>
<span class="sd">        for further details.</span>
<span class="sd">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span>
<span class="sd">        Method for computing a root to represent a group of identical roots.</span>
<span class="sd">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        Residues corresponding to the poles. For repeated poles, the residues</span>
<span class="sd">        are ordered to correspond to ascending by power fractions.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles ordered by magnitude in ascending order.</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    invresz, residue, unique_roots</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator `a` is zero.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;First coefficient of determinant `a` must be &quot;</span>
                         <span class="s2">&quot;non-zero.&quot;</span><span class="p">)</span>

    <span class="n">poles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">poles</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">poles</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">b_rev</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">a_rev</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_rev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_rev</span><span class="p">):</span>
        <span class="n">k_rev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k_rev</span><span class="p">,</span> <span class="n">b_rev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polydiv</span><span class="p">(</span><span class="n">b_rev</span><span class="p">,</span> <span class="n">a_rev</span><span class="p">)</span>

    <span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span>
    <span class="n">unique_poles</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">)</span>
    <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">multiplicity</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

    <span class="n">residues</span> <span class="o">=</span> <span class="n">_compute_residues</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">b_rev</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pole</span><span class="p">,</span> <span class="n">mult</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">):</span>
        <span class="n">poles</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span> <span class="o">+</span> <span class="n">mult</span><span class="p">]</span> <span class="o">=</span> <span class="n">pole</span>
        <span class="n">powers</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span> <span class="o">+</span> <span class="n">mult</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">mult</span>

    <span class="n">residues</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="n">poles</span><span class="p">)</span> <span class="o">**</span> <span class="n">powers</span> <span class="o">/</span> <span class="n">a_rev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">residues</span><span class="p">,</span> <span class="n">poles</span><span class="p">,</span> <span class="n">k_rev</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_group_poles</span><span class="p">(</span><span class="n">poles</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">]:</span>
        <span class="n">reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
    <span class="k">elif</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum&#39;</span><span class="p">]:</span>
        <span class="n">reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span>
    <span class="k">elif</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
        <span class="n">reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`rtype` must be one of &quot;</span>
                         <span class="s2">&quot;{&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}&quot;</span><span class="p">)</span>

    <span class="n">unique</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">multiplicity</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">pole</span> <span class="o">=</span> <span class="n">poles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="n">pole</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">poles</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">poles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">pole</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">block</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
            <span class="n">multiplicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
            <span class="n">pole</span> <span class="o">=</span> <span class="n">poles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="n">pole</span><span class="p">]</span>

    <span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
    <span class="n">multiplicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">unique</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">invresz</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute b(z) and a(z) from partial fraction expansion.</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)</span>
<span class="sd">        H(z) = ------ = ------------------------------------------</span>
<span class="sd">                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</span>

<span class="sd">    then the partial-fraction expansion H(z) is defined as::</span>

<span class="sd">                 r[0]                   r[-1]</span>
<span class="sd">         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...</span>
<span class="sd">           (1-p[0]z**(-1))         (1-p[-1]z**(-1))</span>

<span class="sd">    If there are any repeated roots (closer than `tol`), then the partial</span>
<span class="sd">    fraction expansion has terms like::</span>

<span class="sd">             r[i]              r[i+1]                    r[i+n-1]</span>
<span class="sd">        -------------- + ------------------ + ... + ------------------</span>
<span class="sd">        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n</span>

<span class="sd">    This function is used for polynomials in negative powers of z,</span>
<span class="sd">    such as digital filters in DSP.  For positive powers, use `invres`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like</span>
<span class="sd">        Residues corresponding to the poles. For repeated poles, the residues</span>
<span class="sd">        must be ordered to correspond to ascending by power fractions.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles. Equal poles must be adjacent.</span>
<span class="sd">    k : array_like</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal in terms of</span>
<span class="sd">        the distance between them. Default is 1e-3. See `unique_roots`</span>
<span class="sd">        for further details.</span>
<span class="sd">    rtype : {&#39;avg&#39;, &#39;min&#39;, &#39;max&#39;}, optional</span>
<span class="sd">        Method for computing a root to represent a group of identical roots.</span>
<span class="sd">        Default is &#39;avg&#39;. See `unique_roots` for further details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    residuez, unique_roots, invres</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>

    <span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">_group_poles</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="p">)</span>
    <span class="n">factors</span><span class="p">,</span> <span class="n">denominator</span> <span class="o">=</span> <span class="n">_compute_factors</span><span class="p">(</span><span class="n">unique_poles</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span>
                                            <span class="n">include_powers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">denominator</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">residue</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">residue</span> <span class="o">*</span> <span class="n">factor</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">numerator</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">denominator</span>


<span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample `x` to `num` samples using Fourier method along the given axis.</span>

<span class="sd">    The resampled signal starts at the same value as `x` but is sampled</span>
<span class="sd">    with a spacing of ``len(x) / num * (spacing of x)``.  Because a</span>
<span class="sd">    Fourier method is used, the signal is assumed to be periodic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The data to be resampled.</span>
<span class="sd">    num : int</span>
<span class="sd">        The number of samples in the resampled signal.</span>
<span class="sd">    t : array_like, optional</span>
<span class="sd">        If `t` is given, it is assumed to be the equally spaced sample</span>
<span class="sd">        positions associated with the signal data in `x`.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` that is resampled.  Default is 0.</span>
<span class="sd">    window : array_like, callable, string, float, or tuple, optional</span>
<span class="sd">        Specifies the window applied to the signal in the Fourier</span>
<span class="sd">        domain.  See below for details.</span>
<span class="sd">    domain : string, optional</span>
<span class="sd">        A string indicating the domain of the input `x`:</span>
<span class="sd">        ``time`` Consider the input `x` as time-domain (Default),</span>
<span class="sd">        ``freq`` Consider the input `x` as frequency-domain.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    resampled_x or (resampled_x, resampled_t)</span>
<span class="sd">        Either the resampled array, or, if `t` was given, a tuple</span>
<span class="sd">        containing the resampled array and the corresponding resampled</span>
<span class="sd">        positions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    decimate : Downsample the signal after applying an FIR or IIR filter.</span>
<span class="sd">    resample_poly : Resample using polyphase filtering and an FIR filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The argument `window` controls a Fourier-domain window that tapers</span>
<span class="sd">    the Fourier spectrum before zero-padding to alleviate ringing in</span>
<span class="sd">    the resampled values for sampled signals you didn&#39;t intend to be</span>
<span class="sd">    interpreted as band-limited.</span>

<span class="sd">    If `window` is a function, then it is called with a vector of inputs</span>
<span class="sd">    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</span>

<span class="sd">    If `window` is an array of the same length as `x.shape[axis]` it is</span>
<span class="sd">    assumed to be the window to be applied directly in the Fourier</span>
<span class="sd">    domain (with dc and low-frequency first).</span>

<span class="sd">    For any other type of `window`, the function `scipy.signal.get_window`</span>
<span class="sd">    is called to generate the window.</span>

<span class="sd">    The first sample of the returned vector is the same as the first</span>
<span class="sd">    sample of the input vector.  The spacing between samples is changed</span>
<span class="sd">    from ``dx`` to ``dx * len(x) / num``.</span>

<span class="sd">    If `t` is not None, then it is used solely to calculate the resampled</span>
<span class="sd">    positions `resampled_t`</span>

<span class="sd">    As noted, `resample` uses FFT transformations, which can be very</span>
<span class="sd">    slow if the number of input or output samples is large and prime;</span>
<span class="sd">    see `scipy.fft.fft`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Note that the end of the resampled data rises to meet the first</span>
<span class="sd">    sample of the next cycle:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = np.cos(-x**2/6.0)</span>
<span class="sd">    &gt;&gt;&gt; f = signal.resample(y, 100)</span>
<span class="sd">    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;go-&#39;, xnew, f, &#39;.-&#39;, 10, y[0], &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend([&#39;data&#39;, &#39;resampled&#39;], loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable domain flags are &#39;time&#39; or&quot;</span>
                         <span class="s2">&quot; &#39;freq&#39;, not domain=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="c1"># Check if we can use faster real FFT</span>
    <span class="n">real_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
        <span class="c1"># Forward transform</span>
        <span class="k">if</span> <span class="n">real_input</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Full complex FFT</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># domain == &#39;freq&#39;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Apply window to spectrum</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">sp_fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;window must have the same length as data&#39;</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">window</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span>

        <span class="n">newshape_W</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">newshape_W</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">real_input</span><span class="p">:</span>
            <span class="c1"># Fold the window back on itself to mimic complex behavior</span>
            <span class="n">W_real</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">W_real</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">W_real</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W_real</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="n">X</span> <span class="o">*=</span> <span class="n">W_real</span><span class="p">[:</span><span class="n">newshape_W</span><span class="p">[</span><span class="n">axis</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape_W</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">*=</span> <span class="n">W</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape_W</span><span class="p">)</span>

    <span class="c1"># Copy each half of the original spectrum to the output spectrum, either</span>
    <span class="c1"># truncating high frequences (downsampling) or zero-padding them</span>
    <span class="c1"># (upsampling)</span>

    <span class="c1"># Placeholder array for output spectrum</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">real_input</span><span class="p">:</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Copy positive frequency components (and Nyquist, if present)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Slice index that includes Nyquist if present</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nyq</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">real_input</span><span class="p">:</span>
        <span class="c1"># Copy negative frequency components</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># (slice expression doesn&#39;t collapse to empty array)</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nyq</span> <span class="o">-</span> <span class="n">N</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

    <span class="c1"># Split/join Nyquist component(s) if present</span>
    <span class="c1"># So far we have set Y[+N/2]=X[+N/2]</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">Nx</span><span class="p">:</span>  <span class="c1"># downsampling</span>
            <span class="k">if</span> <span class="n">real_input</span><span class="p">:</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">*=</span> <span class="mf">2.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># select the component of Y at frequency +N/2,</span>
                <span class="c1"># add the component of X at -N/2</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">Nx</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>  <span class="c1"># upsampling</span>
            <span class="c1"># select the component at frequency +N/2 and halve it</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">real_input</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
                <span class="c1"># set the component at -N/2 equal to the component at +N/2</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">Y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span>

    <span class="c1"># Inverse transform</span>
    <span class="k">if</span> <span class="n">real_input</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">*=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Nx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_t</span>


<span class="k">def</span> <span class="nf">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">),</span>
                  <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample `x` along the given axis using polyphase filtering.</span>

<span class="sd">    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass</span>
<span class="sd">    FIR filter is applied, and then it is downsampled by the factor `down`.</span>
<span class="sd">    The resulting sample rate is ``up / down`` times the original sample</span>
<span class="sd">    rate. By default, values beyond the boundary of the signal are assumed</span>
<span class="sd">    to be zero during the filtering step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The data to be resampled.</span>
<span class="sd">    up : int</span>
<span class="sd">        The upsampling factor.</span>
<span class="sd">    down : int</span>
<span class="sd">        The downsampling factor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` that is resampled. Default is 0.</span>
<span class="sd">    window : string, tuple, or array_like, optional</span>
<span class="sd">        Desired window to use to design the low-pass filter, or the FIR filter</span>
<span class="sd">        coefficients to employ. See below for details.</span>
<span class="sd">    padtype : string, optional</span>
<span class="sd">        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of</span>
<span class="sd">        the other signal extension modes supported by `scipy.signal.upfirdn`.</span>
<span class="sd">        Changes assumptions on values beyond the boundary. If `constant`,</span>
<span class="sd">        assumed to be `cval` (default zero). If `line` assumed to continue a</span>
<span class="sd">        linear trend defined by the first and last points. `mean`, `median`,</span>
<span class="sd">        `maximum` and `minimum` work as in `np.pad` and assume that the values</span>
<span class="sd">        beyond the boundary are the mean, median, maximum or minimum</span>
<span class="sd">        respectively of the array along the axis.</span>

<span class="sd">        .. versionadded:: 1.4.0</span>
<span class="sd">    cval : float, optional</span>
<span class="sd">        Value to use if `padtype=&#39;constant&#39;`. Default is zero.</span>

<span class="sd">        .. versionadded:: 1.4.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    resampled_x : array</span>
<span class="sd">        The resampled array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    decimate : Downsample the signal after applying an FIR or IIR filter.</span>
<span class="sd">    resample : Resample up or down using the FFT method.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This polyphase method will likely be faster than the Fourier method</span>
<span class="sd">    in `scipy.signal.resample` when the number of samples is large and</span>
<span class="sd">    prime, or when the number of samples is large and `up` and `down`</span>
<span class="sd">    share a large greatest common denominator. The length of the FIR</span>
<span class="sd">    filter used will depend on ``max(up, down) // gcd(up, down)``, and</span>
<span class="sd">    the number of operations during polyphase filtering will depend on</span>
<span class="sd">    the filter length and `down` (see `scipy.signal.upfirdn` for details).</span>

<span class="sd">    The argument `window` specifies the FIR low-pass filter design.</span>

<span class="sd">    If `window` is an array_like it is assumed to be the FIR filter</span>
<span class="sd">    coefficients. Note that the FIR filter is applied after the upsampling</span>
<span class="sd">    step, so it should be designed to operate on a signal at a sampling</span>
<span class="sd">    frequency higher than the original by a factor of `up//gcd(up, down)`.</span>
<span class="sd">    This function&#39;s output will be centered with respect to this array, so it</span>
<span class="sd">    is best to pass a symmetric filter with an odd number of samples if, as</span>
<span class="sd">    is usually the case, a zero-phase filter is desired.</span>

<span class="sd">    For any other type of `window`, the functions `scipy.signal.get_window`</span>
<span class="sd">    and `scipy.signal.firwin` are called to generate the appropriate filter</span>
<span class="sd">    coefficients.</span>

<span class="sd">    The first sample of the returned vector is the same as the first</span>
<span class="sd">    sample of the input vector. The spacing between samples is changed</span>
<span class="sd">    from ``dx`` to ``dx * down / float(up)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    By default, the end of the resampled data rises to meet the first</span>
<span class="sd">    sample of the next cycle for the FFT method, and gets closer to zero</span>
<span class="sd">    for the polyphase method:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = np.cos(-x**2/6.0)</span>
<span class="sd">    &gt;&gt;&gt; f_fft = signal.resample(y, 100)</span>
<span class="sd">    &gt;&gt;&gt; f_poly = signal.resample_poly(y, 100, 20)</span>
<span class="sd">    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xnew, f_fft, &#39;b.-&#39;, xnew, f_poly, &#39;r.-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;ko-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(10, y[0], &#39;bo&#39;, 10, 0., &#39;ro&#39;)  # boundaries</span>
<span class="sd">    &gt;&gt;&gt; plt.legend([&#39;resample&#39;, &#39;resamp_poly&#39;, &#39;data&#39;], loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    This default behaviour can be changed by using the padtype option:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>

<span class="sd">    &gt;&gt;&gt; N = 5</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 1, N, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = 2 + x**2 - 1.7*np.sin(x) + .2*np.cos(11*x)</span>
<span class="sd">    &gt;&gt;&gt; y2 = 1 + x**3 + 0.1*np.sin(x) + .1*np.cos(11*x)</span>
<span class="sd">    &gt;&gt;&gt; Y = np.stack([y, y2], axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; up = 4</span>
<span class="sd">    &gt;&gt;&gt; xr = np.linspace(0, 1, N*up, endpoint=False)</span>

<span class="sd">    &gt;&gt;&gt; y2 = signal.resample_poly(Y, up, 1, padtype=&#39;constant&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y3 = signal.resample_poly(Y, up, 1, padtype=&#39;mean&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y4 = signal.resample_poly(Y, up, 1, padtype=&#39;line&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; for i in [0,1]:</span>
<span class="sd">    ...     plt.figure()</span>
<span class="sd">    ...     plt.plot(xr, y4[:,i], &#39;g.&#39;, label=&#39;line&#39;)</span>
<span class="sd">    ...     plt.plot(xr, y3[:,i], &#39;y.&#39;, label=&#39;mean&#39;)</span>
<span class="sd">    ...     plt.plot(xr, y2[:,i], &#39;r.&#39;, label=&#39;constant&#39;)</span>
<span class="sd">    ...     plt.plot(x, Y[:,i], &#39;k-&#39;)</span>
<span class="sd">    ...     plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">up</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">up</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;up must be an integer&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">down</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;down must be an integer&quot;</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>
    <span class="n">down</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">down</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">up</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">down</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;up and down must be &gt;= 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">padtype</span> <span class="o">!=</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cval has no effect when padtype is &#39;</span><span class="p">,</span> <span class="n">padtype</span><span class="p">)</span>

    <span class="c1"># Determine our up and down factors</span>
    <span class="c1"># Use a rational approximation to save computation time on really long</span>
    <span class="c1"># signals</span>
    <span class="n">g_</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">//=</span> <span class="n">g_</span>
    <span class="n">down</span> <span class="o">//=</span> <span class="n">g_</span>
    <span class="k">if</span> <span class="n">up</span> <span class="o">==</span> <span class="n">down</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n_in</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">n_out</span> <span class="o">=</span> <span class="n">n_in</span> <span class="o">*</span> <span class="n">up</span>
    <span class="n">n_out</span> <span class="o">=</span> <span class="n">n_out</span> <span class="o">//</span> <span class="n">down</span> <span class="o">+</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n_out</span> <span class="o">%</span> <span class="n">down</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>  <span class="c1"># use array to force a copy (we modify it)</span>
        <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;window must be 1-D&#39;</span><span class="p">)</span>
        <span class="n">half_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Design a linear-phase low-pass FIR filter</span>
        <span class="n">max_rate</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
        <span class="n">f_c</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">max_rate</span>  <span class="c1"># cutoff of FIR filter (rel. to Nyquist)</span>
        <span class="n">half_len</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">max_rate</span>  <span class="c1"># reasonable cutoff for sinc-like function</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">half_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f_c</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">*=</span> <span class="n">up</span>

    <span class="c1"># Zero-pad our filter to put the output samples at the center</span>
    <span class="n">n_pre_pad</span> <span class="o">=</span> <span class="p">(</span><span class="n">down</span> <span class="o">-</span> <span class="n">half_len</span> <span class="o">%</span> <span class="n">down</span><span class="p">)</span>
    <span class="n">n_post_pad</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_pre_remove</span> <span class="o">=</span> <span class="p">(</span><span class="n">half_len</span> <span class="o">+</span> <span class="n">n_pre_pad</span><span class="p">)</span> <span class="o">//</span> <span class="n">down</span>
    <span class="c1"># We should rarely need to do this given our filter lengths...</span>
    <span class="k">while</span> <span class="n">_output_len</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_pre_pad</span> <span class="o">+</span> <span class="n">n_post_pad</span><span class="p">,</span> <span class="n">n_in</span><span class="p">,</span>
                      <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_out</span> <span class="o">+</span> <span class="n">n_pre_remove</span><span class="p">:</span>
        <span class="n">n_post_pad</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pre_pad</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">h</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_post_pad</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">h</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
    <span class="n">n_pre_remove_end</span> <span class="o">=</span> <span class="n">n_pre_remove</span> <span class="o">+</span> <span class="n">n_out</span>

    <span class="c1"># Remove background depending on the padtype option</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span>
             <span class="s1">&#39;minimum&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">}</span>
    <span class="n">upfirdn_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;cval&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">background_values</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="n">padtype</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">padtype</span> <span class="ow">in</span> <span class="n">_upfirdn_modes</span><span class="p">:</span>
        <span class="n">upfirdn_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="n">padtype</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">padtype</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cval</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">upfirdn_kwargs</span><span class="p">[</span><span class="s1">&#39;cval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cval</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;padtype must be one of: maximum, mean, median, minimum, &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_upfirdn_modes</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">background_values</span>

    <span class="c1"># filter then remove excess</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">upfirdn</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">upfirdn_kwargs</span><span class="p">)</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">keep</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n_pre_remove</span><span class="p">,</span> <span class="n">n_pre_remove_end</span><span class="p">)</span>
    <span class="n">y_keep</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">keep</span><span class="p">)]</span>

    <span class="c1"># Add background back</span>
    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">y_keep</span> <span class="o">+=</span> <span class="n">background_values</span>

    <span class="k">return</span> <span class="n">y_keep</span>


<span class="k">def</span> <span class="nf">vectorstrength</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">period</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine the vector strength of the events corresponding to the given</span>
<span class="sd">    period.</span>

<span class="sd">    The vector strength is a measure of phase synchrony, how well the</span>
<span class="sd">    timing of the events is synchronized to a single period of a periodic</span>
<span class="sd">    signal.</span>

<span class="sd">    If multiple periods are used, calculate the vector strength of each.</span>
<span class="sd">    This is called the &quot;resonating vector strength&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : 1D array_like</span>
<span class="sd">        An array of time points containing the timing of the events.</span>
<span class="sd">    period : float or array_like</span>
<span class="sd">        The period of the signal that the events should synchronize to.</span>
<span class="sd">        The period is in the same units as `events`.  It can also be an array</span>
<span class="sd">        of periods, in which case the outputs are arrays of the same length.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    strength : float or 1D array</span>
<span class="sd">        The strength of the synchronization.  1.0 is perfect synchronization</span>
<span class="sd">        and 0.0 is no synchronization.  If `period` is an array, this is also</span>
<span class="sd">        an array with each element containing the vector strength at the</span>
<span class="sd">        corresponding period.</span>
<span class="sd">    phase : float or array</span>
<span class="sd">        The phase that the events are most strongly synchronized to in radians.</span>
<span class="sd">        If `period` is an array, this is also an array with each element</span>
<span class="sd">        containing the phase for the corresponding period.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector</span>
<span class="sd">        strength: Auditory system, electric fish, and noise.</span>
<span class="sd">        Chaos 21, 047508 (2011);</span>
<span class="sd">        :doi:`10.1063/1.3670512`.</span>
<span class="sd">    van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:</span>
<span class="sd">        biological and mathematical perspectives.  Biol Cybern.</span>
<span class="sd">        2013 Aug;107(4):385-96. :doi:`10.1007/s00422-013-0561-7`.</span>
<span class="sd">    van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens</span>
<span class="sd">        when we vary the &quot;probing&quot; frequency while keeping the spike times</span>
<span class="sd">        fixed.  Biol Cybern. 2013 Aug;107(4):491-94.</span>
<span class="sd">        :doi:`10.1007/s00422-013-0560-8`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;events cannot have dimensions more than 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">period</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;period cannot have dimensions more than 1&#39;</span><span class="p">)</span>

    <span class="c1"># we need to know later if period was originally a scalar</span>
    <span class="n">scalarperiod</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">period</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;periods must be positive&#39;</span><span class="p">)</span>

    <span class="c1"># this converts the times to vectors</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">period</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">events</span><span class="p">))</span>

    <span class="c1"># the vector strength is just the magnitude of the mean of the vectors</span>
    <span class="c1"># the vector phase is the angle of the mean of the vectors</span>
    <span class="n">vectormean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">strength</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vectormean</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vectormean</span><span class="p">)</span>

    <span class="c1"># if the original period was a scalar, return scalars</span>
    <span class="k">if</span> <span class="n">scalarperiod</span><span class="p">:</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">strength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">strength</span><span class="p">,</span> <span class="n">phase</span>


<span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">bp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove linear trend along axis from data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        The input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to detrend the data. By default this is the</span>
<span class="sd">        last axis (-1).</span>
<span class="sd">    type : {&#39;linear&#39;, &#39;constant&#39;}, optional</span>
<span class="sd">        The type of detrending. If ``type == &#39;linear&#39;`` (default),</span>
<span class="sd">        the result of a linear least-squares fit to `data` is subtracted</span>
<span class="sd">        from `data`.</span>
<span class="sd">        If ``type == &#39;constant&#39;``, only the mean of `data` is subtracted.</span>
<span class="sd">    bp : array_like of ints, optional</span>
<span class="sd">        A sequence of break points. If given, an individual linear fit is</span>
<span class="sd">        performed for each part of `data` between two break points.</span>
<span class="sd">        Break points are specified as indices into `data`. This parameter</span>
<span class="sd">        only has an effect when ``type == &#39;linear&#39;``.</span>
<span class="sd">    overwrite_data : bool, optional</span>
<span class="sd">        If True, perform in place detrending and avoid a copy. Default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : ndarray</span>
<span class="sd">        The detrended input data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import default_rng</span>
<span class="sd">    &gt;&gt;&gt; rng = default_rng()</span>
<span class="sd">    &gt;&gt;&gt; npoints = 1000</span>
<span class="sd">    &gt;&gt;&gt; noise = rng.standard_normal(npoints)</span>
<span class="sd">    &gt;&gt;&gt; x = 3 + 2*np.linspace(0, 1, npoints) + noise</span>
<span class="sd">    &gt;&gt;&gt; (signal.detrend(x) - noise).max()</span>
<span class="sd">    0.06  # random</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trend type must be &#39;linear&#39; or &#39;constant&#39;.&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;dfDF&#39;</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dshape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">dshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">N</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bp</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breakpoints must be less than length &quot;</span>
                             <span class="s2">&quot;of data along given axis.&quot;</span><span class="p">)</span>
        <span class="n">Nreg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Restructure data so that axis is along first dimension and</span>
        <span class="c1">#  all other dimensions are collapsed into second dimension</span>
        <span class="n">rnk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">rnk</span>
        <span class="n">newdims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">rnk</span><span class="p">]</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newdims</span><span class="p">)),</span>
                             <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">_prod</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span> <span class="o">//</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite_data</span><span class="p">:</span>
            <span class="n">newdata</span> <span class="o">=</span> <span class="n">newdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># make sure we have a copy</span>
        <span class="k">if</span> <span class="n">newdata</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;dfDF&#39;</span><span class="p">:</span>
            <span class="n">newdata</span> <span class="o">=</span> <span class="n">newdata</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Find leastsq fit and remove it for each piece</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nreg</span><span class="p">):</span>
            <span class="n">Npts</span> <span class="o">=</span> <span class="n">bp</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Npts</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Npts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Npts</span><span class="p">)</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">coef</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">newdata</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>
            <span class="n">newdata</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">newdata</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
        <span class="c1"># Put data back in original shape.</span>
        <span class="n">tdshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">newdims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newdata</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tdshape</span><span class="p">))</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rnk</span><span class="p">))</span>
        <span class="n">olddims</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="n">axis</span><span class="p">:]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">olddims</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct initial conditions for lfilter for step response steady-state.</span>

<span class="sd">    Compute an initial state `zi` for the `lfilter` function that corresponds</span>
<span class="sd">    to the steady state of the step response.</span>

<span class="sd">    A typical use of this function is to set the initial state so that the</span>
<span class="sd">    output of the filter starts at the same value as the first element of</span>
<span class="sd">    the signal to be filtered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b, a : array_like (1-D)</span>
<span class="sd">        The IIR filter coefficients. See `lfilter` for more</span>
<span class="sd">        information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zi : 1-D ndarray</span>
<span class="sd">        The initial state for the filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lfilter, lfiltic, filtfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A linear filter with order m has a state space representation (A, B, C, D),</span>
<span class="sd">    for which the output y of the filter can be expressed as::</span>

<span class="sd">        z(n+1) = A*z(n) + B*x(n)</span>
<span class="sd">        y(n)   = C*z(n) + D*x(n)</span>

<span class="sd">    where z(n) is a vector of length m, A has shape (m, m), B has shape</span>
<span class="sd">    (m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is</span>
<span class="sd">    a scalar).  lfilter_zi solves::</span>

<span class="sd">        zi = A*zi + B</span>

<span class="sd">    In other words, it finds the initial condition for which the response</span>
<span class="sd">    to an input of all ones is a constant.</span>

<span class="sd">    Given the filter coefficients `a` and `b`, the state space matrices</span>
<span class="sd">    for the transposed direct form II implementation of the linear filter,</span>
<span class="sd">    which is the implementation used by scipy.signal.lfilter, are::</span>

<span class="sd">        A = scipy.linalg.companion(a).T</span>
<span class="sd">        B = b[1:] - a[1:]*b[0]</span>

<span class="sd">    assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first</span>
<span class="sd">    divided by a[0].</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The following code creates a lowpass Butterworth filter. Then it</span>
<span class="sd">    applies that filter to an array whose values are all 1.0; the</span>
<span class="sd">    output is also all 1.0, as expected for a lowpass filter.  If the</span>
<span class="sd">    `zi` argument of `lfilter` had not been given, the output would have</span>
<span class="sd">    shown the transient signal.</span>

<span class="sd">    &gt;&gt;&gt; from numpy import array, ones</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import lfilter, lfilter_zi, butter</span>
<span class="sd">    &gt;&gt;&gt; b, a = butter(5, 0.25)</span>
<span class="sd">    &gt;&gt;&gt; zi = lfilter_zi(b, a)</span>
<span class="sd">    &gt;&gt;&gt; y, zo = lfilter(b, a, ones(10), zi=zi)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])</span>

<span class="sd">    Another example:</span>

<span class="sd">    &gt;&gt;&gt; x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; y, zf = lfilter(b, a, x, zi=zi*x[0])</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,</span>
<span class="sd">        0.44399389,  0.35505241])</span>

<span class="sd">    Note that the `zi` argument to `lfilter` was computed using</span>
<span class="sd">    `lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no</span>
<span class="sd">    transient until the input drops from 0.5 to 0.0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># FIXME: Can this function be replaced with an appropriate</span>
    <span class="c1"># use of lfiltic?  For example, when b,a = butter(N,Wn),</span>
    <span class="c1">#    lfiltic(b, a, y=numpy.ones_like(a), x=numpy.ones_like(b)).</span>
    <span class="c1">#</span>

    <span class="c1"># We could use scipy.signal.normalize, but it uses warnings in</span>
    <span class="c1"># cases where a ValueError is more appropriate, and it allows</span>
    <span class="c1"># b to be 2D.</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numerator b must be 1-D.&quot;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator a must be 1-D.&quot;</span><span class="p">)</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be at least one nonzero `a` coefficient.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># Normalize the coefficients so a[0] == 1.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="c1"># Pad a or b with zeros so they are the same length.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>

    <span class="n">IminusA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">-</span> <span class="n">linalg</span><span class="o">.</span><span class="n">companion</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Solve zi = A*zi + B</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">IminusA</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

    <span class="c1"># For future reference: we could also use the following</span>
    <span class="c1"># explicit formulas to solve the linear system:</span>
    <span class="c1">#</span>
    <span class="c1"># zi = np.zeros(n - 1)</span>
    <span class="c1"># zi[0] = B.sum() / IminusA[:,0].sum()</span>
    <span class="c1"># asum = 1.0</span>
    <span class="c1"># csum = 0.0</span>
    <span class="c1"># for k in range(1,n-1):</span>
    <span class="c1">#     asum += a[k]</span>
    <span class="c1">#     csum += b[k] - a[k]*b[0]</span>
    <span class="c1">#     zi[k] = asum*zi[0] - csum</span>

    <span class="k">return</span> <span class="n">zi</span>


<span class="k">def</span> <span class="nf">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct initial conditions for sosfilt for step response steady-state.</span>

<span class="sd">    Compute an initial state `zi` for the `sosfilt` function that corresponds</span>
<span class="sd">    to the steady state of the step response.</span>

<span class="sd">    A typical use of this function is to set the initial state so that the</span>
<span class="sd">    output of the filter starts at the same value as the first element of</span>
<span class="sd">    the signal to be filtered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span>
<span class="sd">        specification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zi : ndarray</span>
<span class="sd">        Initial conditions suitable for use with ``sosfilt``, shape</span>
<span class="sd">        ``(n_sections, 2)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sosfilt, zpk2sos</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Filter a rectangular pulse that begins at time 0, with and without</span>
<span class="sd">    the use of the `zi` argument of `scipy.signal.sosfilt`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.butter(9, 0.125, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zi = signal.sosfilt_zi(sos)</span>
<span class="sd">    &gt;&gt;&gt; x = (np.arange(250) &lt; 100).astype(int)</span>
<span class="sd">    &gt;&gt;&gt; f1 = signal.sosfilt(sos, x)</span>
<span class="sd">    &gt;&gt;&gt; f2, zo = signal.sosfilt(sos, x, zi=zi)</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(x, &#39;k--&#39;, label=&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(f1, &#39;b&#39;, alpha=0.5, linewidth=2, label=&#39;filtered&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(f2, &#39;g&#39;, alpha=0.25, linewidth=4, label=&#39;filtered with zi&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos must be shape (n_sections, 6)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sos</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;bui&#39;</span><span class="p">:</span>
        <span class="n">sos</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">n_sections</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_sections</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sos</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="c1"># If H(z) = B(z)/A(z) is this section&#39;s transfer function, then</span>
        <span class="c1"># b.sum()/a.sum() is H(1), the gain at omega=0.  That&#39;s the steady</span>
        <span class="c1"># state value of this section&#39;s step response.</span>
        <span class="n">scale</span> <span class="o">*=</span> <span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">zi</span>


<span class="k">def</span> <span class="nf">_filtfilt_gust</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">irlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forward-backward IIR filter that uses Gustafsson&#39;s method.</span>

<span class="sd">    Apply the IIR filter defined by `(b,a)` to `x` twice, first forward</span>
<span class="sd">    then backward, using Gustafsson&#39;s initial conditions [1]_.</span>

<span class="sd">    Let ``y_fb`` be the result of filtering first forward and then backward,</span>
<span class="sd">    and let ``y_bf`` be the result of filtering first backward then forward.</span>
<span class="sd">    Gustafsson&#39;s method is to compute initial conditions for the forward</span>
<span class="sd">    pass and the backward pass such that ``y_fb == y_bf``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : scalar or 1-D ndarray</span>
<span class="sd">        Numerator coefficients of the filter.</span>
<span class="sd">    a : scalar or 1-D ndarray</span>
<span class="sd">        Denominator coefficients of the filter.</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Data to be filtered.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `x` to be filtered.  Default is -1.</span>
<span class="sd">    irlen : int or None, optional</span>
<span class="sd">        The length of the nonnegligible part of the impulse response.</span>
<span class="sd">        If `irlen` is None, or if the length of the signal is less than</span>
<span class="sd">        ``2 * irlen``, then no part of the impulse response is ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The filtered data.</span>
<span class="sd">    x0 : ndarray</span>
<span class="sd">        Initial condition for the forward filter.</span>
<span class="sd">    x1 : ndarray</span>
<span class="sd">        Initial condition for the backward filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Typically the return values `x0` and `x1` are not needed by the</span>
<span class="sd">    caller.  The intended use of these return values is in unit tests.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] F. Gustaffson. Determining the initial states in forward-backward</span>
<span class="sd">           filtering. Transactions on Signal Processing, 46(4):988-992, 1996.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In the comments, &quot;Gustafsson&#39;s paper&quot; and [1] refer to the</span>
    <span class="c1"># paper referenced in the docstring.</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># The filter is just scalar multiplication, with no state.</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Move the axis containing the data to the end.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># n is the number of samples in the data to be filtered.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">irlen</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">irlen</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">irlen</span>

    <span class="c1"># Create Obs, the observability matrix (called O in the paper).</span>
    <span class="c1"># This matrix can be interpreted as the operator that propagates</span>
    <span class="c1"># an arbitrary initial state to the output, assuming the input is</span>
    <span class="c1"># zero.</span>
    <span class="c1"># In Gustafsson&#39;s paper, the forward and backward filters are not</span>
    <span class="c1"># necessarily the same, so he has both O_f and O_b.  We use the same</span>
    <span class="c1"># filter in both directions, so we only need O. The same comment</span>
    <span class="c1"># applies to S below.</span>
    <span class="n">Obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="n">zi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Obs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">Obs</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Obs</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Obsr is O^R (Gustafsson&#39;s notation for row-reversed O)</span>
    <span class="n">Obsr</span> <span class="o">=</span> <span class="n">Obs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Create S.  S is the matrix that applies the filter to the reversed</span>
    <span class="c1"># propagated initial conditions.  That is,</span>
    <span class="c1">#     out = S.dot(zi)</span>
    <span class="c1"># is the same as</span>
    <span class="c1">#     tmp, _ = lfilter(b, a, zeros(), zi=zi)  # Propagate ICs.</span>
    <span class="c1">#     out = lfilter(b, a, tmp[::-1])          # Reverse and filter.</span>

    <span class="c1"># Equations (5) &amp; (6) of [1]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Obs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Sr is S^R (row-reversed S)</span>
    <span class="n">Sr</span> <span class="o">=</span> <span class="n">S</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># M is [(S^R - O), (O^R - S)]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Sr</span> <span class="o">-</span> <span class="n">Obs</span><span class="p">,</span> <span class="n">Obsr</span> <span class="o">-</span> <span class="n">S</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Matrix described in section IV of [1].</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">))</span>
        <span class="n">M</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sr</span> <span class="o">-</span> <span class="n">Obs</span>
        <span class="n">M</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="n">order</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Obsr</span> <span class="o">-</span> <span class="n">S</span>

    <span class="c1"># Naive forward-backward and backward-forward filters.</span>
    <span class="c1"># These have large transients because the filters use zero initial</span>
    <span class="c1"># conditions.</span>
    <span class="n">y_f</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y_fb</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">y_f</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">y_b</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y_bf</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">y_b</span><span class="p">)</span>

    <span class="n">delta_y_bf_fb</span> <span class="o">=</span> <span class="n">y_bf</span> <span class="o">-</span> <span class="n">y_fb</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">delta_y_bf_fb</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_m</span> <span class="o">=</span> <span class="n">delta_y_bf_fb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
        <span class="n">end_m</span> <span class="o">=</span> <span class="n">delta_y_bf_fb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">:]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">start_m</span><span class="p">,</span> <span class="n">end_m</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># ic_opt holds the &quot;optimal&quot; initial conditions.</span>
    <span class="c1"># The following code computes the result shown in the formula</span>
    <span class="c1"># of the paper between equations (6) and (7).</span>
    <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ic_opt</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">delta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Reshape delta so it can be used as an array of multiple</span>
        <span class="c1"># right-hand-sides in linalg.lstsq.</span>
        <span class="n">delta2d</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ic_opt0</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">delta2d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ic_opt</span> <span class="o">=</span> <span class="n">ic_opt0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>

    <span class="c1"># Now compute the filtered signal using equation (7) of [1].</span>
    <span class="c1"># First, form [S^R, O^R] and call it W.</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Sr</span><span class="p">,</span> <span class="n">Obsr</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">))</span>
        <span class="n">W</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sr</span>
        <span class="n">W</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="n">order</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Obsr</span>

    <span class="c1"># Equation (7) of [1] says</span>
    <span class="c1">#     Y_fb^opt = Y_fb^0 + W * [x_0^opt; x_{N-1}^opt]</span>
    <span class="c1"># `wic` is (almost) the product on the right.</span>
    <span class="c1"># W has shape (m, 2*order), and ic_opt has shape (..., 2*order),</span>
    <span class="c1"># so we can&#39;t use W.dot(ic_opt).  Instead, we dot ic_opt with W.T,</span>
    <span class="c1"># so wic has shape (..., m).</span>
    <span class="n">wic</span> <span class="o">=</span> <span class="n">ic_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># `wic` is &quot;almost&quot; the product of W and the optimal ICs in equation</span>
    <span class="c1"># (7)--if we&#39;re using a truncated impulse response (m &lt; n), `wic`</span>
    <span class="c1"># contains only the adjustments required for the ends of the signal.</span>
    <span class="c1"># Here we form y_opt, taking this into account if necessary.</span>
    <span class="n">y_opt</span> <span class="o">=</span> <span class="n">y_fb</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">y_opt</span> <span class="o">+=</span> <span class="n">wic</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wic</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
        <span class="n">y_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">wic</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">:]</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">ic_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">ic_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">order</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Restore the data axis to its original position.</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">y_opt</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y_opt</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span>


<div class="viewcode-block" id="filtfilt"><a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.filter.filtfilt">[docs]</a><span class="k">def</span> <span class="nf">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="n">padlen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span>
             <span class="n">irlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a digital filter forward and backward to a signal.</span>

<span class="sd">    This function applies a linear digital filter twice, once forward and</span>
<span class="sd">    once backwards.  The combined filter has zero phase and a filter order</span>
<span class="sd">    twice that of the original.</span>

<span class="sd">    The function provides options for handling the edges of the signal.</span>

<span class="sd">    The function `sosfiltfilt` (and filter design using ``output=&#39;sos&#39;``)</span>
<span class="sd">    should be preferred over `filtfilt` for most filtering tasks, as</span>
<span class="sd">    second-order sections have fewer numerical problems.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : (N,) array_like</span>
<span class="sd">        The numerator coefficient vector of the filter.</span>
<span class="sd">    a : (N,) array_like</span>
<span class="sd">        The denominator coefficient vector of the filter.  If ``a[0]``</span>
<span class="sd">        is not 1, then both `a` and `b` are normalized by ``a[0]``.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The array of data to be filtered.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` to which the filter is applied.</span>
<span class="sd">        Default is -1.</span>
<span class="sd">    padtype : str or None, optional</span>
<span class="sd">        Must be &#39;odd&#39;, &#39;even&#39;, &#39;constant&#39;, or None.  This determines the</span>
<span class="sd">        type of extension to use for the padded signal to which the filter</span>
<span class="sd">        is applied.  If `padtype` is None, no padding is used.  The default</span>
<span class="sd">        is &#39;odd&#39;.</span>
<span class="sd">    padlen : int or None, optional</span>
<span class="sd">        The number of elements by which to extend `x` at both ends of</span>
<span class="sd">        `axis` before applying the filter.  This value must be less than</span>
<span class="sd">        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.</span>
<span class="sd">        The default value is ``3 * max(len(a), len(b))``.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Determines the method for handling the edges of the signal, either</span>
<span class="sd">        &quot;pad&quot; or &quot;gust&quot;.  When `method` is &quot;pad&quot;, the signal is padded; the</span>
<span class="sd">        type of padding is determined by `padtype` and `padlen`, and `irlen`</span>
<span class="sd">        is ignored.  When `method` is &quot;gust&quot;, Gustafsson&#39;s method is used,</span>
<span class="sd">        and `padtype` and `padlen` are ignored.</span>
<span class="sd">    irlen : int or None, optional</span>
<span class="sd">        When `method` is &quot;gust&quot;, `irlen` specifies the length of the</span>
<span class="sd">        impulse response of the filter.  If `irlen` is None, no part</span>
<span class="sd">        of the impulse response is ignored.  For a long signal, specifying</span>
<span class="sd">        `irlen` can significantly improve the performance of the filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The filtered output with the same shape as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When `method` is &quot;pad&quot;, the function pads the data along the given axis</span>
<span class="sd">    in one of three ways: odd, even or constant.  The odd and even extensions</span>
<span class="sd">    have the corresponding symmetry about the end point of the data.  The</span>
<span class="sd">    constant extension extends the data with the values at the end points. On</span>
<span class="sd">    both the forward and backward passes, the initial condition of the</span>
<span class="sd">    filter is found by using `lfilter_zi` and scaling it by the end point of</span>
<span class="sd">    the extended data.</span>

<span class="sd">    When `method` is &quot;gust&quot;, Gustafsson&#39;s method [1]_ is used.  Initial</span>
<span class="sd">    conditions are chosen for the forward and backward passes so that the</span>
<span class="sd">    forward-backward filter gives the same result as the backward-forward</span>
<span class="sd">    filter.</span>

<span class="sd">    The option to use Gustaffson&#39;s method was added in scipy version 0.16.0.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] F. Gustaffson, &quot;Determining the initial states in forward-backward</span>
<span class="sd">           filtering&quot;, Transactions on Signal Processing, Vol. 46, pp. 988-992,</span>
<span class="sd">           1996.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The examples will use several functions from `scipy.signal`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    First we create a one second signal that is the sum of two pure sine</span>
<span class="sd">    waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1.0, 2001)</span>
<span class="sd">    &gt;&gt;&gt; xlow = np.sin(2 * np.pi * 5 * t)</span>
<span class="sd">    &gt;&gt;&gt; xhigh = np.sin(2 * np.pi * 250 * t)</span>
<span class="sd">    &gt;&gt;&gt; x = xlow + xhigh</span>

<span class="sd">    Now create a lowpass Butterworth filter with a cutoff of 0.125 times</span>
<span class="sd">    the Nyquist frequency, or 125 Hz, and apply it to ``x`` with `filtfilt`.</span>
<span class="sd">    The result should be approximately ``xlow``, with no phase shift.</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(8, 0.125)</span>
<span class="sd">    &gt;&gt;&gt; y = signal.filtfilt(b, a, x, padlen=150)</span>
<span class="sd">    &gt;&gt;&gt; np.abs(y - xlow).max()</span>
<span class="sd">    9.1086182074789912e-06</span>

<span class="sd">    We get a fairly clean result for this artificial example because</span>
<span class="sd">    the odd extension is exact, and with the moderately long padding,</span>
<span class="sd">    the filter&#39;s transients have dissipated by the time the actual data</span>
<span class="sd">    is reached.  In general, transient effects at the edges are</span>
<span class="sd">    unavoidable.</span>

<span class="sd">    The following example demonstrates the option ``method=&quot;gust&quot;``.</span>

<span class="sd">    First, create a filter.</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.</span>

<span class="sd">    `sig` is a random input signal to be filtered.</span>

<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; n = 60</span>
<span class="sd">    &gt;&gt;&gt; sig = rng.standard_normal(n)**3 + 3*rng.standard_normal(n).cumsum()</span>

<span class="sd">    Apply `filtfilt` to `sig`, once using the Gustafsson method, and</span>
<span class="sd">    once using padding, and plot the results for comparison.</span>

<span class="sd">    &gt;&gt;&gt; fgust = signal.filtfilt(b, a, sig, method=&quot;gust&quot;)</span>
<span class="sd">    &gt;&gt;&gt; fpad = signal.filtfilt(b, a, sig, padlen=50)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(sig, &#39;k-&#39;, label=&#39;input&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(fgust, &#39;b-&#39;, linewidth=4, label=&#39;gust&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(fpad, &#39;c-&#39;, linewidth=1.5, label=&#39;pad&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The `irlen` argument can be used to improve the performance</span>
<span class="sd">    of Gustafsson&#39;s method.</span>

<span class="sd">    Estimate the impulse response length of the filter.</span>

<span class="sd">    &gt;&gt;&gt; z, p, k = signal.tf2zpk(b, a)</span>
<span class="sd">    &gt;&gt;&gt; eps = 1e-9</span>
<span class="sd">    &gt;&gt;&gt; r = np.max(np.abs(p))</span>
<span class="sd">    &gt;&gt;&gt; approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))</span>
<span class="sd">    &gt;&gt;&gt; approx_impulse_len</span>
<span class="sd">    137</span>

<span class="sd">    Apply the filter to a longer signal, with and without the `irlen`</span>
<span class="sd">    argument.  The difference between `y1` and `y2` is small.  For long</span>
<span class="sd">    signals, using `irlen` gives a significant performance improvement.</span>

<span class="sd">    &gt;&gt;&gt; x = rng.standard_normal(5000)</span>
<span class="sd">    &gt;&gt;&gt; y1 = signal.filtfilt(b, a, x, method=&#39;gust&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y2 = signal.filtfilt(b, a, x, method=&#39;gust&#39;, irlen=approx_impulse_len)</span>
<span class="sd">    &gt;&gt;&gt; print(np.max(np.abs(y1 - y2)))</span>
<span class="sd">    1.80056858312e-10</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;gust&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;pad&#39; or &#39;gust&#39;.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gust&quot;</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">_filtfilt_gust</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">irlen</span><span class="o">=</span><span class="n">irlen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="c1"># method == &quot;pad&quot;</span>
    <span class="n">edge</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">_validate_pad</span><span class="p">(</span><span class="n">padtype</span><span class="p">,</span> <span class="n">padlen</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                              <span class="n">ntaps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

    <span class="c1"># Get the steady state of the filter&#39;s step response.</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="c1"># Reshape zi and create x0 so that zi*x0 broadcasts</span>
    <span class="c1"># to the correct value for the &#39;zi&#39; keyword argument</span>
    <span class="c1"># to lfilter.</span>
    <span class="n">zi_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">zi_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">size</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">zi_shape</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Forward filter.</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">x0</span><span class="p">)</span>

    <span class="c1"># Backward filter.</span>
    <span class="c1"># Create y0 so zi*y0 broadcasts appropriately.</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span>

    <span class="c1"># Reverse y.</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Slice the actual signal from the extended signal.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span></div>


<span class="k">def</span> <span class="nf">_validate_pad</span><span class="p">(</span><span class="n">padtype</span><span class="p">,</span> <span class="n">padlen</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to validate padding for filtfilt&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;even&#39;</span><span class="p">,</span> <span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Unknown value &#39;</span><span class="si">%s</span><span class="s2">&#39; given to padtype.  padtype &quot;</span>
                          <span class="s2">&quot;must be &#39;even&#39;, &#39;odd&#39;, &#39;constant&#39;, or None.&quot;</span><span class="p">)</span> <span class="o">%</span>
                         <span class="n">padtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">padlen</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">padlen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Original padding; preserved for backwards compatibility.</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">ntaps</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">padlen</span>

    <span class="c1"># x&#39;s &#39;axis&#39; dimension must be bigger than edge.</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">edge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of the input vector x must be greater &quot;</span>
                         <span class="s2">&quot;than padlen, which is </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">edge</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Make an extension of length `edge` at each</span>
        <span class="c1"># end of the input array.</span>
        <span class="k">if</span> <span class="n">padtype</span> <span class="o">==</span> <span class="s1">&#39;even&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">even_ext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">padtype</span> <span class="o">==</span> <span class="s1">&#39;odd&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">odd_ext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">const_ext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">,</span> <span class="n">ext</span>


<span class="k">def</span> <span class="nf">_validate_x</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be at least 1-D&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter data along one dimension using cascaded second-order sections.</span>

<span class="sd">    Filter a data sequence, `x`, using a digital IIR filter defined by</span>
<span class="sd">    `sos`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. Each row corresponds to a second-order</span>
<span class="sd">        section, with the first three columns providing the numerator</span>
<span class="sd">        coefficients and the last three providing the denominator</span>
<span class="sd">        coefficients.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        An N-dimensional input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of the input data array along which to apply the</span>
<span class="sd">        linear filter. The filter is applied to each subarray along</span>
<span class="sd">        this axis.  Default is -1.</span>
<span class="sd">    zi : array_like, optional</span>
<span class="sd">        Initial conditions for the cascaded filter delays.  It is a (at</span>
<span class="sd">        least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where</span>
<span class="sd">        ``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]``</span>
<span class="sd">        replaced by 2.  If `zi` is None or is not given then initial rest</span>
<span class="sd">        (i.e. all zeros) is assumed.</span>
<span class="sd">        Note that these initial conditions are *not* the same as the initial</span>
<span class="sd">        conditions given by `lfiltic` or `lfilter_zi`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The output of the digital filter.</span>
<span class="sd">    zf : ndarray, optional</span>
<span class="sd">        If `zi` is None, this is not returned, otherwise, `zf` holds the</span>
<span class="sd">        final filter delay values.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The filter function is implemented as a series of second-order filters</span>
<span class="sd">    with direct-form II transposed structure. It is designed to minimize</span>
<span class="sd">    numerical precision errors for high-order filters.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Plot a 13th-order filter&#39;s impulse response using both `lfilter` and</span>
<span class="sd">    `sosfilt`, showing the instability that results from trying to do a</span>
<span class="sd">    13th-order filter in a single stage (the numerical error pushes some poles</span>
<span class="sd">    outside of the unit circle):</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(13, 0.009, 80, 0.05, output=&#39;ba&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sos = signal.ellip(13, 0.009, 80, 0.05, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x = signal.unit_impulse(700)</span>
<span class="sd">    &gt;&gt;&gt; y_tf = signal.lfilter(b, a, x)</span>
<span class="sd">    &gt;&gt;&gt; y_sos = signal.sosfilt(sos, x)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y_tf, &#39;r&#39;, label=&#39;TF&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y_sos, &#39;k&#39;, label=&#39;SOS&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_validate_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">sos</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">_validate_sos</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="n">x_zi_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_zi_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">x_zi_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">n_sections</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_zi_shape</span><span class="p">)</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zi</span><span class="p">))</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;fdgFDGO&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;input type &#39;</span><span class="si">%s</span><span class="s2">&#39; not supported&quot;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>  <span class="c1"># make a copy so that we can operate in place</span>
        <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">x_zi_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid zi shape. With axis=</span><span class="si">%r</span><span class="s1">, an input with &#39;</span>
                             <span class="s1">&#39;shape </span><span class="si">%r</span><span class="s1">, and an sos array with </span><span class="si">%d</span><span class="s1"> sections, zi &#39;</span>
                             <span class="s1">&#39;must have shape </span><span class="si">%r</span><span class="s1">, got </span><span class="si">%r</span><span class="s1">.&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">n_sections</span><span class="p">,</span> <span class="n">x_zi_shape</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">return_zi</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x_zi_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">return_zi</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>  <span class="c1"># make positive</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">x_shape</span><span class="p">,</span> <span class="n">zi_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># make a copy, can modify in place</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_sections</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
    <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">x_shape</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_zi</span><span class="p">:</span>
        <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">zi_shape</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="n">padlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A forward-backward digital filter using cascaded second-order sections.</span>

<span class="sd">    See `filtfilt` for more complete information about this method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. Each row corresponds to a second-order</span>
<span class="sd">        section, with the first three columns providing the numerator</span>
<span class="sd">        coefficients and the last three providing the denominator</span>
<span class="sd">        coefficients.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The array of data to be filtered.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` to which the filter is applied.</span>
<span class="sd">        Default is -1.</span>
<span class="sd">    padtype : str or None, optional</span>
<span class="sd">        Must be &#39;odd&#39;, &#39;even&#39;, &#39;constant&#39;, or None.  This determines the</span>
<span class="sd">        type of extension to use for the padded signal to which the filter</span>
<span class="sd">        is applied.  If `padtype` is None, no padding is used.  The default</span>
<span class="sd">        is &#39;odd&#39;.</span>
<span class="sd">    padlen : int or None, optional</span>
<span class="sd">        The number of elements by which to extend `x` at both ends of</span>
<span class="sd">        `axis` before applying the filter.  This value must be less than</span>
<span class="sd">        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.</span>
<span class="sd">        The default value is::</span>

<span class="sd">            3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),</span>
<span class="sd">                                        (sos[:, 5] == 0).sum()))</span>

<span class="sd">        The extra subtraction at the end attempts to compensate for poles</span>
<span class="sd">        and zeros at the origin (e.g. for odd-order filters) to yield</span>
<span class="sd">        equivalent estimates of `padlen` to those of `filtfilt` for</span>
<span class="sd">        second-order section filters built with `scipy.signal` functions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The filtered output with the same shape as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    filtfilt, sosfilt, sosfilt_zi, sosfreqz</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.18.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import sosfiltfilt, butter</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>

<span class="sd">    Create an interesting signal to filter.</span>

<span class="sd">    &gt;&gt;&gt; n = 201</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1, n)</span>
<span class="sd">    &gt;&gt;&gt; x = 1 + (t &lt; 0.5) - 0.25*t**2 + 0.05*rng.standard_normal(n)</span>

<span class="sd">    Create a lowpass Butterworth filter, and use it to filter `x`.</span>

<span class="sd">    &gt;&gt;&gt; sos = butter(4, 0.125, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = sosfiltfilt(sos, x)</span>

<span class="sd">    For comparison, apply an 8th order filter using `sosfilt`.  The filter</span>
<span class="sd">    is initialized using the mean of the first four values of `x`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import sosfilt, sosfilt_zi</span>
<span class="sd">    &gt;&gt;&gt; sos8 = butter(8, 0.125, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zi = x[:4].mean() * sosfilt_zi(sos8)</span>
<span class="sd">    &gt;&gt;&gt; y2, zo = sosfilt(sos8, x, zi=zi)</span>

<span class="sd">    Plot the results.  Note that the phase of `y` matches the input, while</span>
<span class="sd">    `y2` has a significant phase delay.</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(t, x, alpha=0.5, label=&#39;x(t)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, y, label=&#39;y(t)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, y2, label=&#39;y2(t)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sos</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">_validate_sos</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_validate_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># `method` is &quot;pad&quot;...</span>
    <span class="n">ntaps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_sections</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">ntaps</span> <span class="o">-=</span> <span class="nb">min</span><span class="p">((</span><span class="n">sos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="p">(</span><span class="n">sos</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">edge</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">_validate_pad</span><span class="p">(</span><span class="n">padtype</span><span class="p">,</span> <span class="n">padlen</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                              <span class="n">ntaps</span><span class="o">=</span><span class="n">ntaps</span><span class="p">)</span>

    <span class="c1"># These steps follow the same form as filtfilt with modifications</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>  <span class="c1"># shape (n_sections, 2) --&gt; (n_sections, ..., 2, ...)</span>
    <span class="n">zi_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">zi_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_sections</span><span class="p">]</span> <span class="o">+</span> <span class="n">zi_shape</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">x_0</span><span class="p">)</span>
    <span class="n">y_0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">y_0</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">zero_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downsample the signal after applying an anti-aliasing filter.</span>

<span class="sd">    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR</span>
<span class="sd">    filter with Hamming window is used if `ftype` is &#39;fir&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The signal to be downsampled, as an N-dimensional array.</span>
<span class="sd">    q : int</span>
<span class="sd">        The downsampling factor. When using IIR downsampling, it is recommended</span>
<span class="sd">        to call `decimate` multiple times for downsampling factors higher than</span>
<span class="sd">        13.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        The order of the filter (1 less than the length for &#39;fir&#39;). Defaults to</span>
<span class="sd">        8 for &#39;iir&#39; and 20 times the downsampling factor for &#39;fir&#39;.</span>
<span class="sd">    ftype : str {&#39;iir&#39;, &#39;fir&#39;} or ``dlti`` instance, optional</span>
<span class="sd">        If &#39;iir&#39; or &#39;fir&#39;, specifies the type of lowpass filter. If an instance</span>
<span class="sd">        of an `dlti` object, uses that object to filter before downsampling.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to decimate.</span>
<span class="sd">    zero_phase : bool, optional</span>
<span class="sd">        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`</span>
<span class="sd">        when using an IIR filter, and shifting the outputs back by the filter&#39;s</span>
<span class="sd">        group delay when using an FIR filter. The default value of ``True`` is</span>
<span class="sd">        recommended, since a phase shift is generally not desired.</span>

<span class="sd">        .. versionadded:: 0.18.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The down-sampled signal.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    resample : Resample up or down using the FFT method.</span>
<span class="sd">    resample_poly : Resample using polyphase filtering and an FIR filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``zero_phase`` keyword was added in 0.18.0.</span>
<span class="sd">    The possibility to use instances of ``dlti`` as ``ftype`` was added in</span>
<span class="sd">    0.18.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;fir&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">half_len</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">q</span>  <span class="c1"># reasonable cutoff for our sinc-like function</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_len</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">q</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">),</span> <span class="mf">1.</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;iir&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">dlti</span><span class="p">(</span><span class="o">*</span><span class="n">cheby1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.8</span> <span class="o">/</span> <span class="n">q</span><span class="p">))</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">system</span><span class="o">.</span><span class="n">den</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ftype</span><span class="p">,</span> <span class="n">dlti</span><span class="p">):</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">ftype</span><span class="o">.</span><span class="n">_as_tf</span><span class="p">()</span>  <span class="c1"># Avoids copying if already in TF form</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">system</span><span class="o">.</span><span class="n">den</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid ftype&#39;</span><span class="p">)</span>

    <span class="n">result_type</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">result_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;bui&#39;</span><span class="p">:</span>
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_type</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_type</span><span class="p">)</span>

    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># FIR case</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">zero_phase</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># upfirdn is generally faster than lfilter by a factor equal to the</span>
            <span class="c1"># downsampling factor, since it only calculates the needed outputs</span>
            <span class="n">n_out</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="n">q</span> <span class="o">+</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">upfirdn</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">up</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">down</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_out</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># IIR case</span>
        <span class="k">if</span> <span class="n">zero_phase</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, California Department of Water Resources.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>