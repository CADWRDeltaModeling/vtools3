
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.signal.fir_filter_design &#8212; vtools 3.6.6+1.g092ced5.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
            </a></p>
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Introduction and concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html">Averging, Filtering and Low Passing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html#Filters">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scipy.signal.fir_filter_design</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Functions for FIR filter design.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">log</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">irfft</span><span class="p">,</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">sinc</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="p">(</span><span class="n">toeplitz</span><span class="p">,</span> <span class="n">hankel</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">LinAlgError</span><span class="p">,</span> <span class="n">LinAlgWarning</span><span class="p">,</span>
                          <span class="n">lstsq</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">sigtools</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;kaiser_beta&#39;</span><span class="p">,</span> <span class="s1">&#39;kaiser_atten&#39;</span><span class="p">,</span> <span class="s1">&#39;kaiserord&#39;</span><span class="p">,</span>
           <span class="s1">&#39;firwin&#39;</span><span class="p">,</span> <span class="s1">&#39;firwin2&#39;</span><span class="p">,</span> <span class="s1">&#39;remez&#39;</span><span class="p">,</span> <span class="s1">&#39;firls&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_phase&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">nyq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility for replacing the argument &#39;nyq&#39; (with default 1) with &#39;fs&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nyq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">nyq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values cannot be given for both &#39;nyq&#39; and &#39;fs&#39;.&quot;</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nyq</span>
    <span class="k">return</span> <span class="n">fs</span>


<span class="c1"># Some notes on function parameters:</span>
<span class="c1">#</span>
<span class="c1"># `cutoff` and `width` are given as numbers between 0 and 1.  These are</span>
<span class="c1"># relative frequencies, expressed as a fraction of the Nyquist frequency.</span>
<span class="c1"># For example, if the Nyquist frequency is 2 KHz, then width=0.15 is a width</span>
<span class="c1"># of 300 Hz.</span>
<span class="c1">#</span>
<span class="c1"># The `order` of a FIR filter is one less than the number of taps.</span>
<span class="c1"># This is a potential source of confusion, so in the following code,</span>
<span class="c1"># we will always use the number of taps as the parameterization of</span>
<span class="c1"># the &#39;size&#39; of the filter. The &quot;number of taps&quot; means the number</span>
<span class="c1"># of coefficients, which is the same as the length of the impulse</span>
<span class="c1"># response of the filter.</span>


<span class="k">def</span> <span class="nf">kaiser_beta</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the Kaiser parameter `beta`, given the attenuation `a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float</span>
<span class="sd">        The desired attenuation in the stopband and maximum ripple in</span>
<span class="sd">        the passband, in dB.  This should be a *positive* number.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    beta : float</span>
<span class="sd">        The `beta` parameter to be used in the formula for a Kaiser window.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Oppenheim, Schafer, &quot;Discrete-Time Signal Processing&quot;, p.475-476.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we want to design a lowpass filter, with 65 dB attenuation</span>
<span class="sd">    in the stop band.  The Kaiser window parameter to be used in the</span>
<span class="sd">    window method is computed by `kaiser_beta(65)`:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import kaiser_beta</span>
<span class="sd">    &gt;&gt;&gt; kaiser_beta(65)</span>
<span class="sd">    6.20426</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.1102</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mf">8.7</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">21</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5842</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">21</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.4</span> <span class="o">+</span> <span class="mf">0.07886</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">21</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">beta</span>


<span class="k">def</span> <span class="nf">kaiser_atten</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the attenuation of a Kaiser FIR filter.</span>

<span class="sd">    Given the number of taps `N` and the transition width `width`, compute the</span>
<span class="sd">    attenuation `a` in dB, given by Kaiser&#39;s formula:</span>

<span class="sd">        a = 2.285 * (N - 1) * pi * width + 7.95</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numtaps : int</span>
<span class="sd">        The number of taps in the FIR filter.</span>
<span class="sd">    width : float</span>
<span class="sd">        The desired width of the transition region between passband and</span>
<span class="sd">        stopband (or, in general, at any discontinuity) for the filter,</span>
<span class="sd">        expressed as a fraction of the Nyquist frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : float</span>
<span class="sd">        The attenuation of the ripple, in dB.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kaiserord, kaiser_beta</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we want to design a FIR filter using the Kaiser window method</span>
<span class="sd">    that will have 211 taps and a transition width of 9 Hz for a signal that</span>
<span class="sd">    is sampled at 480 Hz. Expressed as a fraction of the Nyquist frequency,</span>
<span class="sd">    the width is 9/(0.5*480) = 0.0375. The approximate attenuation (in dB)</span>
<span class="sd">    is computed as follows:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import kaiser_atten</span>
<span class="sd">    &gt;&gt;&gt; kaiser_atten(211, 0.0375)</span>
<span class="sd">    64.48099630593983</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">2.285</span> <span class="o">*</span> <span class="p">(</span><span class="n">numtaps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mf">7.95</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">kaiserord</span><span class="p">(</span><span class="n">ripple</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the filter window parameters for the Kaiser window method.</span>

<span class="sd">    The parameters returned by this function are generally used to create</span>
<span class="sd">    a finite impulse response filter using the window method, with either</span>
<span class="sd">    `firwin` or `firwin2`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ripple : float</span>
<span class="sd">        Upper bound for the deviation (in dB) of the magnitude of the</span>
<span class="sd">        filter&#39;s frequency response from that of the desired filter (not</span>
<span class="sd">        including frequencies in any transition intervals). That is, if w</span>
<span class="sd">        is the frequency expressed as a fraction of the Nyquist frequency,</span>
<span class="sd">        A(w) is the actual frequency response of the filter and D(w) is the</span>
<span class="sd">        desired frequency response, the design requirement is that::</span>

<span class="sd">            abs(A(w) - D(w))) &lt; 10**(-ripple/20)</span>

<span class="sd">        for 0 &lt;= w &lt;= 1 and w not in a transition interval.</span>
<span class="sd">    width : float</span>
<span class="sd">        Width of transition region, normalized so that 1 corresponds to pi</span>
<span class="sd">        radians / sample. That is, the frequency is expressed as a fraction</span>
<span class="sd">        of the Nyquist frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numtaps : int</span>
<span class="sd">        The length of the Kaiser window.</span>
<span class="sd">    beta : float</span>
<span class="sd">        The beta parameter for the Kaiser window.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kaiser_beta, kaiser_atten</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are several ways to obtain the Kaiser window:</span>

<span class="sd">    - ``signal.windows.kaiser(numtaps, beta, sym=True)``</span>
<span class="sd">    - ``signal.get_window(beta, numtaps)``</span>
<span class="sd">    - ``signal.get_window((&#39;kaiser&#39;, beta), numtaps)``</span>

<span class="sd">    The empirical equations discovered by Kaiser are used.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Oppenheim, Schafer, &quot;Discrete-Time Signal Processing&quot;, pp.475-476.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    We will use the Kaiser window method to design a lowpass FIR filter</span>
<span class="sd">    for a signal that is sampled at 1000 Hz.</span>

<span class="sd">    We want at least 65 dB rejection in the stop band, and in the pass</span>
<span class="sd">    band the gain should vary no more than 0.5%.</span>

<span class="sd">    We want a cutoff frequency of 175 Hz, with a transition between the</span>
<span class="sd">    pass band and the stop band of 24 Hz. That is, in the band [0, 163],</span>
<span class="sd">    the gain varies no more than 0.5%, and in the band [187, 500], the</span>
<span class="sd">    signal is attenuated by at least 65 dB.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import kaiserord, firwin, freqz</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fs = 1000.0</span>
<span class="sd">    &gt;&gt;&gt; cutoff = 175</span>
<span class="sd">    &gt;&gt;&gt; width = 24</span>

<span class="sd">    The Kaiser method accepts just a single parameter to control the pass</span>
<span class="sd">    band ripple and the stop band rejection, so we use the more restrictive</span>
<span class="sd">    of the two. In this case, the pass band ripple is 0.005, or 46.02 dB,</span>
<span class="sd">    so we will use 65 dB as the design parameter.</span>

<span class="sd">    Use `kaiserord` to determine the length of the filter and the</span>
<span class="sd">    parameter for the Kaiser window.</span>

<span class="sd">    &gt;&gt;&gt; numtaps, beta = kaiserord(65, width/(0.5*fs))</span>
<span class="sd">    &gt;&gt;&gt; numtaps</span>
<span class="sd">    167</span>
<span class="sd">    &gt;&gt;&gt; beta</span>
<span class="sd">    6.20426</span>

<span class="sd">    Use `firwin` to create the FIR filter.</span>

<span class="sd">    &gt;&gt;&gt; taps = firwin(numtaps, cutoff, window=(&#39;kaiser&#39;, beta),</span>
<span class="sd">    ...               scale=False, nyq=0.5*fs)</span>

<span class="sd">    Compute the frequency response of the filter.  ``w`` is the array of</span>
<span class="sd">    frequencies, and ``h`` is the corresponding complex array of frequency</span>
<span class="sd">    responses.</span>

<span class="sd">    &gt;&gt;&gt; w, h = freqz(taps, worN=8000)</span>
<span class="sd">    &gt;&gt;&gt; w *= 0.5*fs/np.pi  # Convert w to Hz.</span>

<span class="sd">    Compute the deviation of the magnitude of the filter&#39;s response from</span>
<span class="sd">    that of the ideal lowpass filter. Values in the transition region are</span>
<span class="sd">    set to ``nan``, so they won&#39;t appear in the plot.</span>

<span class="sd">    &gt;&gt;&gt; ideal = w &lt; cutoff  # The &quot;ideal&quot; frequency response.</span>
<span class="sd">    &gt;&gt;&gt; deviation = np.abs(np.abs(h) - ideal)</span>
<span class="sd">    &gt;&gt;&gt; deviation[(w &gt; cutoff - 0.5*width) &amp; (w &lt; cutoff + 0.5*width)] = np.nan</span>

<span class="sd">    Plot the deviation. A close look at the left end of the stop band shows</span>
<span class="sd">    that the requirement for 65 dB attenuation is violated in the first lobe</span>
<span class="sd">    by about 0.125 dB. This is not unusual for the Kaiser window method.</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(w, 20*np.log10(np.abs(deviation)))</span>
<span class="sd">    &gt;&gt;&gt; plt.xlim(0, 0.5*fs)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylim(-90, -60)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-65, color=&#39;r&#39;, ls=&#39;--&#39;, alpha=0.3)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency (Hz)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Deviation from ideal (dB)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lowpass Filter Frequency Response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ripple</span><span class="p">)</span>  <span class="c1"># in case somebody is confused as to what&#39;s meant</span>
    <span class="k">if</span> <span class="n">A</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># Formula for N is not valid in this range.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Requested maximum ripple attentuation </span><span class="si">%f</span><span class="s2"> is too &quot;</span>
                         <span class="s2">&quot;small for the Kaiser formula.&quot;</span> <span class="o">%</span> <span class="n">A</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">kaiser_beta</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># Kaiser&#39;s formula (as given in Oppenheim and Schafer) is for the filter</span>
    <span class="c1"># order, so we have to add 1 to get the number of taps.</span>
    <span class="n">numtaps</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="mf">7.95</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.285</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">numtaps</span><span class="p">)),</span> <span class="n">beta</span>


<div class="viewcode-block" id="firwin"><a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.filter.firwin">[docs]</a><span class="k">def</span> <span class="nf">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
           <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FIR filter design using the window method.</span>

<span class="sd">    This function computes the coefficients of a finite impulse response</span>
<span class="sd">    filter. The filter will have linear phase; it will be Type I if</span>
<span class="sd">    `numtaps` is odd and Type II if `numtaps` is even.</span>

<span class="sd">    Type II filters always have zero response at the Nyquist frequency, so a</span>
<span class="sd">    ValueError exception is raised if firwin is called with `numtaps` even and</span>
<span class="sd">    having a passband whose right end is at the Nyquist frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numtaps : int</span>
<span class="sd">        Length of the filter (number of coefficients, i.e. the filter</span>
<span class="sd">        order + 1).  `numtaps` must be odd if a passband includes the</span>
<span class="sd">        Nyquist frequency.</span>
<span class="sd">    cutoff : float or 1-D array_like</span>
<span class="sd">        Cutoff frequency of filter (expressed in the same units as `fs`)</span>
<span class="sd">        OR an array of cutoff frequencies (that is, band edges). In the</span>
<span class="sd">        latter case, the frequencies in `cutoff` should be positive and</span>
<span class="sd">        monotonically increasing between 0 and `fs/2`. The values 0 and</span>
<span class="sd">        `fs/2` must not be included in `cutoff`.</span>
<span class="sd">    width : float or None, optional</span>
<span class="sd">        If `width` is not None, then assume it is the approximate width</span>
<span class="sd">        of the transition region (expressed in the same units as `fs`)</span>
<span class="sd">        for use in Kaiser FIR filter design. In this case, the `window`</span>
<span class="sd">        argument is ignored.</span>
<span class="sd">    window : string or tuple of string and parameter values, optional</span>
<span class="sd">        Desired window to use. See `scipy.signal.get_window` for a list</span>
<span class="sd">        of windows and required parameters.</span>
<span class="sd">    pass_zero : {True, False, &#39;bandpass&#39;, &#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        If True, the gain at the frequency 0 (i.e., the &quot;DC gain&quot;) is 1.</span>
<span class="sd">        If False, the DC gain is 0. Can also be a string argument for the</span>
<span class="sd">        desired filter type (equivalent to ``btype`` in IIR design functions).</span>

<span class="sd">        .. versionadded:: 1.3.0</span>
<span class="sd">           Support for string arguments.</span>
<span class="sd">    scale : bool, optional</span>
<span class="sd">        Set to True to scale the coefficients so that the frequency</span>
<span class="sd">        response is exactly unity at a certain frequency.</span>
<span class="sd">        That frequency is either:</span>

<span class="sd">        - 0 (DC) if the first passband starts at 0 (i.e. pass_zero</span>
<span class="sd">          is True)</span>
<span class="sd">        - `fs/2` (the Nyquist frequency) if the first passband ends at</span>
<span class="sd">          `fs/2` (i.e the filter is a single band highpass filter);</span>
<span class="sd">          center of first passband otherwise</span>

<span class="sd">    nyq : float, optional</span>
<span class="sd">        *Deprecated. Use `fs` instead.* This is the Nyquist frequency.</span>
<span class="sd">        Each frequency in `cutoff` must be between 0 and `nyq`. Default</span>
<span class="sd">        is 1.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the signal. Each frequency in `cutoff`</span>
<span class="sd">        must be between 0 and ``fs/2``.  Default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h : (numtaps,) ndarray</span>
<span class="sd">        Coefficients of length `numtaps` FIR filter.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any value in `cutoff` is less than or equal to 0 or greater</span>
<span class="sd">        than or equal to ``fs/2``, if the values in `cutoff` are not strictly</span>
<span class="sd">        monotonically increasing, or if `numtaps` is even but a passband</span>
<span class="sd">        includes the Nyquist frequency.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    firwin2</span>
<span class="sd">    firls</span>
<span class="sd">    minimum_phase</span>
<span class="sd">    remez</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Low-pass from 0 to f:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; numtaps = 3</span>
<span class="sd">    &gt;&gt;&gt; f = 0.1</span>
<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, f)</span>
<span class="sd">    array([ 0.06799017,  0.86401967,  0.06799017])</span>

<span class="sd">    Use a specific window function:</span>

<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, f, window=&#39;nuttall&#39;)</span>
<span class="sd">    array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</span>

<span class="sd">    High-pass (&#39;stop&#39; from 0 to f):</span>

<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, f, pass_zero=False)</span>
<span class="sd">    array([-0.00859313,  0.98281375, -0.00859313])</span>

<span class="sd">    Band-pass:</span>

<span class="sd">    &gt;&gt;&gt; f1, f2 = 0.1, 0.2</span>
<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2], pass_zero=False)</span>
<span class="sd">    array([ 0.06301614,  0.88770441,  0.06301614])</span>

<span class="sd">    Band-stop:</span>

<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2])</span>
<span class="sd">    array([-0.00801395,  1.0160279 , -0.00801395])</span>

<span class="sd">    Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</span>

<span class="sd">    &gt;&gt;&gt; f3, f4 = 0.3, 0.4</span>
<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4])</span>
<span class="sd">    array([-0.01376344,  1.02752689, -0.01376344])</span>

<span class="sd">    Multi-band (passbands are [f1, f2] and [f3,f4]):</span>

<span class="sd">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)</span>
<span class="sd">    array([ 0.04890915,  0.91284326,  0.04890915])</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="c1"># The major enhancements to this function added in November 2010 were</span>
    <span class="c1"># developed by Tom Krauss (see ticket #902).</span>

    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">_get_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">nyq</span><span class="p">)</span>

    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nyq</span><span class="p">)</span>

    <span class="c1"># Check for invalid input.</span>
    <span class="k">if</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The cutoff argument must be at most &quot;</span>
                         <span class="s2">&quot;one-dimensional.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one cutoff frequency must be given.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cutoff frequency: frequencies must be &quot;</span>
                         <span class="s2">&quot;greater than 0 and less than fs/2.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cutoff frequencies: the frequencies &quot;</span>
                         <span class="s2">&quot;must be strictly increasing.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># A width was given.  Find the beta parameter of the Kaiser window</span>
        <span class="c1"># and set `window`.  This overrides the value of `window` passed in.</span>
        <span class="n">atten</span> <span class="o">=</span> <span class="n">kaiser_atten</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="n">nyq</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">kaiser_beta</span><span class="p">(</span><span class="n">atten</span><span class="p">)</span>
        <span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pass_zero</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pass_zero</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bandstop&#39;</span><span class="p">,</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pass_zero</span> <span class="o">==</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cutoff must have one element if &#39;</span>
                                     <span class="s1">&#39;pass_zero==&quot;lowpass&quot;, got </span><span class="si">%s</span><span class="s1">&#39;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">cutoff</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
            <span class="k">elif</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cutoff must have at least two elements if &#39;</span>
                                 <span class="s1">&#39;pass_zero==&quot;bandstop&quot;, got </span><span class="si">%s</span><span class="s1">&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">cutoff</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
            <span class="n">pass_zero</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">pass_zero</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="s1">&#39;highpass&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pass_zero</span> <span class="o">==</span> <span class="s1">&#39;highpass&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cutoff must have one element if &#39;</span>
                                     <span class="s1">&#39;pass_zero==&quot;highpass&quot;, got </span><span class="si">%s</span><span class="s1">&#39;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">cutoff</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
            <span class="k">elif</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cutoff must have at least two elements if &#39;</span>
                                 <span class="s1">&#39;pass_zero==&quot;bandpass&quot;, got </span><span class="si">%s</span><span class="s1">&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">cutoff</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
            <span class="n">pass_zero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pass_zero must be True, False, &quot;bandpass&quot;, &#39;</span>
                             <span class="s1">&#39;&quot;lowpass&quot;, &quot;highpass&quot;, or &quot;bandstop&quot;, got &#39;</span>
                             <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pass_zero</span><span class="p">,))</span>
    <span class="n">pass_zero</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pass_zero</span><span class="p">))</span>  <span class="c1"># ensure bool-like</span>

    <span class="n">pass_nyquist</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">pass_zero</span>
    <span class="k">if</span> <span class="n">pass_nyquist</span> <span class="ow">and</span> <span class="n">numtaps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A filter with an even number of coefficients must &quot;</span>
                         <span class="s2">&quot;have zero response at the Nyquist frequency.&quot;</span><span class="p">)</span>

    <span class="c1"># Insert 0 and/or 1 at the ends of cutoff so that the length of cutoff</span>
    <span class="c1"># is even, and each pair in cutoff corresponds to passband.</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pass_zero</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pass_nyquist</span><span class="p">))</span>

    <span class="c1"># `bands` is a 2-D array; each row gives the left and right edges of</span>
    <span class="c1"># a passband.</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Build up the coefficients.</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">numtaps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numtaps</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">*</span> <span class="n">sinc</span><span class="p">(</span><span class="n">right</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">-=</span> <span class="n">left</span> <span class="o">*</span> <span class="n">sinc</span><span class="p">(</span><span class="n">left</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># Get and apply the window function.</span>
    <span class="kn">from</span> <span class="nn">.signaltools</span> <span class="kn">import</span> <span class="n">get_window</span>
    <span class="n">win</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">numtaps</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">*=</span> <span class="n">win</span>

    <span class="c1"># Now handle scaling if desired.</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="c1"># Get the first passband.</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">bands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scale_frequency</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale_frequency</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_frequency</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">m</span> <span class="o">*</span> <span class="n">scale_frequency</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">/=</span> <span class="n">s</span>

    <span class="k">return</span> <span class="n">h</span></div>


<span class="c1"># Original version of firwin2 from scipy ticket #457, submitted by &quot;tash&quot;.</span>
<span class="c1">#</span>
<span class="c1"># Rewritten by Warren Weckesser, 2010.</span>

<span class="k">def</span> <span class="nf">firwin2</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">nfreqs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">antisymmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FIR filter design using the window method.</span>

<span class="sd">    From the given frequencies `freq` and corresponding gains `gain`,</span>
<span class="sd">    this function constructs an FIR filter with linear phase and</span>
<span class="sd">    (approximately) the given frequency response.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numtaps : int</span>
<span class="sd">        The number of taps in the FIR filter.  `numtaps` must be less than</span>
<span class="sd">        `nfreqs`.</span>
<span class="sd">    freq : array_like, 1-D</span>
<span class="sd">        The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being</span>
<span class="sd">        Nyquist.  The Nyquist frequency is half `fs`.</span>
<span class="sd">        The values in `freq` must be nondecreasing. A value can be repeated</span>
<span class="sd">        once to implement a discontinuity. The first value in `freq` must</span>
<span class="sd">        be 0, and the last value must be ``fs/2``. Values 0 and ``fs/2`` must</span>
<span class="sd">        not be repeated.</span>
<span class="sd">    gain : array_like</span>
<span class="sd">        The filter gains at the frequency sampling points. Certain</span>
<span class="sd">        constraints to gain values, depending on the filter type, are applied,</span>
<span class="sd">        see Notes for details.</span>
<span class="sd">    nfreqs : int, optional</span>
<span class="sd">        The size of the interpolation mesh used to construct the filter.</span>
<span class="sd">        For most efficient behavior, this should be a power of 2 plus 1</span>
<span class="sd">        (e.g, 129, 257, etc). The default is one more than the smallest</span>
<span class="sd">        power of 2 that is not less than `numtaps`. `nfreqs` must be greater</span>
<span class="sd">        than `numtaps`.</span>
<span class="sd">    window : string or (string, float) or float, or None, optional</span>
<span class="sd">        Window function to use. Default is &quot;hamming&quot;. See</span>
<span class="sd">        `scipy.signal.get_window` for the complete list of possible values.</span>
<span class="sd">        If None, no window function is applied.</span>
<span class="sd">    nyq : float, optional</span>
<span class="sd">        *Deprecated. Use `fs` instead.* This is the Nyquist frequency.</span>
<span class="sd">        Each frequency in `freq` must be between 0 and `nyq`.  Default is 1.</span>
<span class="sd">    antisymmetric : bool, optional</span>
<span class="sd">        Whether resulting impulse response is symmetric/antisymmetric.</span>
<span class="sd">        See Notes for more details.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the signal. Each frequency in `cutoff`</span>
<span class="sd">        must be between 0 and ``fs/2``. Default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    taps : ndarray</span>
<span class="sd">        The filter coefficients of the FIR filter, as a 1-D array of length</span>
<span class="sd">        `numtaps`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    firls</span>
<span class="sd">    firwin</span>
<span class="sd">    minimum_phase</span>
<span class="sd">    remez</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    From the given set of frequencies and gains, the desired response is</span>
<span class="sd">    constructed in the frequency domain. The inverse FFT is applied to the</span>
<span class="sd">    desired response to create the associated convolution kernel, and the</span>
<span class="sd">    first `numtaps` coefficients of this kernel, scaled by `window`, are</span>
<span class="sd">    returned.</span>

<span class="sd">    The FIR filter will have linear phase. The type of filter is determined by</span>
<span class="sd">    the value of &#39;numtaps` and `antisymmetric` flag.</span>
<span class="sd">    There are four possible combinations:</span>

<span class="sd">       - odd  `numtaps`, `antisymmetric` is False, type I filter is produced</span>
<span class="sd">       - even `numtaps`, `antisymmetric` is False, type II filter is produced</span>
<span class="sd">       - odd  `numtaps`, `antisymmetric` is True, type III filter is produced</span>
<span class="sd">       - even `numtaps`, `antisymmetric` is True, type IV filter is produced</span>

<span class="sd">    Magnitude response of all but type I filters are subjects to following</span>
<span class="sd">    constraints:</span>

<span class="sd">       - type II  -- zero at the Nyquist frequency</span>
<span class="sd">       - type III -- zero at zero and Nyquist frequencies</span>
<span class="sd">       - type IV  -- zero at zero frequency</span>

<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Oppenheim, A. V. and Schafer, R. W., &quot;Discrete-Time Signal</span>
<span class="sd">       Processing&quot;, Prentice-Hall, Englewood Cliffs, New Jersey (1989).</span>
<span class="sd">       (See, for example, Section 7.4.)</span>

<span class="sd">    .. [2] Smith, Steven W., &quot;The Scientist and Engineer&#39;s Guide to Digital</span>
<span class="sd">       Signal Processing&quot;, Ch. 17. http://www.dspguide.com/ch17/1.htm</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and</span>
<span class="sd">    that decreases linearly on [0.5, 1.0] from 1 to 0:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; print(taps[72:78])</span>
<span class="sd">    [-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">_get_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">nyq</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gain</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;freq and gain must be of same length.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nfreqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">numtaps</span> <span class="o">&gt;=</span> <span class="n">nfreqs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;ntaps must be less than nfreqs, but firwin2 was &#39;</span>
                          <span class="s1">&#39;called with ntaps=</span><span class="si">%d</span><span class="s1"> and nfreqs=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">nfreqs</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nyq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;freq must start with 0 and end with fs/2.&#39;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The values in freq must be nondecreasing.&#39;</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;A value in freq must not occur more than twice.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value 0 must not be repeated in freq&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">nyq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value fs/2 must not be repeated in freq&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">antisymmetric</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">numtaps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">numtaps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">gain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A Type II filter must have zero gain at the &quot;</span>
                         <span class="s2">&quot;Nyquist frequency.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">gain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A Type III filter must have zero gain at zero &quot;</span>
                         <span class="s2">&quot;and Nyquist frequencies.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">gain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A Type IV filter must have zero gain at zero &quot;</span>
                         <span class="s2">&quot;frequency.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nfreqs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nfreqs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># Tweak any repeated values in freq so that interp works.</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">nyq</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">freq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">freq</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">freq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">eps</span>
                <span class="n">freq</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span>
        <span class="c1"># Check if freq is strictly increasing after tweak</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;freq cannot contain numbers that are too close &quot;</span>
                             <span class="s2">&quot;(within eps * (fs/2): &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">) to a repeated value&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>

    <span class="c1"># Linearly interpolate the desired response on a uniform mesh `x`.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">nyq</span><span class="p">,</span> <span class="n">nfreqs</span><span class="p">)</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">gain</span><span class="p">)</span>

    <span class="c1"># Adjust the phases of the coefficients so that the first `ntaps` of the</span>
    <span class="c1"># inverse FFT are the desired filter coefficients.</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">numtaps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">*</span> <span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="n">nyq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">*=</span> <span class="mi">1</span><span class="n">j</span>

    <span class="n">fx2</span> <span class="o">=</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">shift</span>

    <span class="c1"># Use irfft to compute the inverse FFT.</span>
    <span class="n">out_full</span> <span class="o">=</span> <span class="n">irfft</span><span class="p">(</span><span class="n">fx2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Create the window to apply to the filter coefficients.</span>
        <span class="kn">from</span> <span class="nn">.signaltools</span> <span class="kn">import</span> <span class="n">get_window</span>
        <span class="n">wind</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">numtaps</span><span class="p">,</span> <span class="n">fftbins</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wind</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Keep only the first `numtaps` coefficients in `out`, and multiply by</span>
    <span class="c1"># the window.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out_full</span><span class="p">[:</span><span class="n">numtaps</span><span class="p">]</span> <span class="o">*</span> <span class="n">wind</span>

    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">remez</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">desired</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Hz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span>
          <span class="n">maxiter</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">grid_density</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the minimax optimal filter using the Remez exchange algorithm.</span>

<span class="sd">    Calculate the filter-coefficients for the finite impulse response</span>
<span class="sd">    (FIR) filter whose transfer function minimizes the maximum error</span>
<span class="sd">    between the desired gain and the realized gain in the specified</span>
<span class="sd">    frequency bands using the Remez exchange algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numtaps : int</span>
<span class="sd">        The desired number of taps in the filter. The number of taps is</span>
<span class="sd">        the number of terms in the filter, or the filter order plus one.</span>
<span class="sd">    bands : array_like</span>
<span class="sd">        A monotonic sequence containing the band edges.</span>
<span class="sd">        All elements must be non-negative and less than half the sampling</span>
<span class="sd">        frequency as given by `fs`.</span>
<span class="sd">    desired : array_like</span>
<span class="sd">        A sequence half the size of bands containing the desired gain</span>
<span class="sd">        in each of the specified bands.</span>
<span class="sd">    weight : array_like, optional</span>
<span class="sd">        A relative weighting to give to each band region. The length of</span>
<span class="sd">        `weight` has to be half the length of `bands`.</span>
<span class="sd">    Hz : scalar, optional</span>
<span class="sd">        *Deprecated.  Use `fs` instead.*</span>
<span class="sd">        The sampling frequency in Hz. Default is 1.</span>
<span class="sd">    type : {&#39;bandpass&#39;, &#39;differentiator&#39;, &#39;hilbert&#39;}, optional</span>
<span class="sd">        The type of filter:</span>

<span class="sd">          * &#39;bandpass&#39; : flat response in bands. This is the default.</span>

<span class="sd">          * &#39;differentiator&#39; : frequency proportional response in bands.</span>

<span class="sd">          * &#39;hilbert&#39; : filter with odd symmetry, that is, type III</span>
<span class="sd">                        (for even order) or type IV (for odd order)</span>
<span class="sd">                        linear phase filters.</span>

<span class="sd">    maxiter : int, optional</span>
<span class="sd">        Maximum number of iterations of the algorithm. Default is 25.</span>
<span class="sd">    grid_density : int, optional</span>
<span class="sd">        Grid density. The dense grid used in `remez` is of size</span>
<span class="sd">        ``(numtaps + 1) * grid_density``. Default is 16.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the signal.  Default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A rank-1 array containing the coefficients of the optimal</span>
<span class="sd">        (in a minimax sense) filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    firls</span>
<span class="sd">    firwin</span>
<span class="sd">    firwin2</span>
<span class="sd">    minimum_phase</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. H. McClellan and T. W. Parks, &quot;A unified approach to the</span>
<span class="sd">           design of optimum FIR linear phase digital filters&quot;,</span>
<span class="sd">           IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.</span>
<span class="sd">    .. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, &quot;A Computer</span>
<span class="sd">           Program for Designing Optimum FIR Linear Phase Digital</span>
<span class="sd">           Filters&quot;, IEEE Trans. Audio Electroacoust., vol. AU-21,</span>
<span class="sd">           pp. 506-525, 1973.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In these examples `remez` gets used creating a bandpass, bandstop, lowpass</span>
<span class="sd">    and highpass filter. The used parameters are the filter order, an array</span>
<span class="sd">    with according frequency boundaries, the desired attenuation values and the</span>
<span class="sd">    sampling frequency. Using `freqz` the corresponding frequency response</span>
<span class="sd">    gets calculated and plotted.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; def plot_response(fs, w, h, title):</span>
<span class="sd">    ...     &quot;Utility function to plot response functions&quot;</span>
<span class="sd">    ...     fig = plt.figure()</span>
<span class="sd">    ...     ax = fig.add_subplot(111)</span>
<span class="sd">    ...     ax.plot(0.5*fs*w/np.pi, 20*np.log10(np.abs(h)))</span>
<span class="sd">    ...     ax.set_ylim(-40, 5)</span>
<span class="sd">    ...     ax.set_xlim(0, 0.5*fs)</span>
<span class="sd">    ...     ax.grid(True)</span>
<span class="sd">    ...     ax.set_xlabel(&#39;Frequency (Hz)&#39;)</span>
<span class="sd">    ...     ax.set_ylabel(&#39;Gain (dB)&#39;)</span>
<span class="sd">    ...     ax.set_title(title)</span>

<span class="sd">    This example shows a steep low pass transition according to the small</span>
<span class="sd">    transition width and high filter order:</span>

<span class="sd">    &gt;&gt;&gt; fs = 22050.0       # Sample rate, Hz</span>
<span class="sd">    &gt;&gt;&gt; cutoff = 8000.0    # Desired cutoff frequency, Hz</span>
<span class="sd">    &gt;&gt;&gt; trans_width = 100  # Width of transition from pass band to stop band, Hz</span>
<span class="sd">    &gt;&gt;&gt; numtaps = 400      # Size of the FIR filter.</span>
<span class="sd">    &gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff, cutoff + trans_width, 0.5*fs], [1, 0], Hz=fs)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span>
<span class="sd">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;Low-pass Filter&quot;)</span>

<span class="sd">    This example shows a high pass filter:</span>

<span class="sd">    &gt;&gt;&gt; fs = 22050.0       # Sample rate, Hz</span>
<span class="sd">    &gt;&gt;&gt; cutoff = 2000.0    # Desired cutoff frequency, Hz</span>
<span class="sd">    &gt;&gt;&gt; trans_width = 250  # Width of transition from pass band to stop band, Hz</span>
<span class="sd">    &gt;&gt;&gt; numtaps = 125      # Size of the FIR filter.</span>
<span class="sd">    &gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff - trans_width, cutoff, 0.5*fs],</span>
<span class="sd">    ...                     [0, 1], Hz=fs)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span>
<span class="sd">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;High-pass Filter&quot;)</span>

<span class="sd">    For a signal sampled with 22 kHz a bandpass filter with a pass band of 2-5</span>
<span class="sd">    kHz gets calculated using the Remez algorithm. The transition width is 260</span>
<span class="sd">    Hz and the filter order 10:</span>

<span class="sd">    &gt;&gt;&gt; fs = 22000.0         # Sample rate, Hz</span>
<span class="sd">    &gt;&gt;&gt; band = [2000, 5000]  # Desired pass band, Hz</span>
<span class="sd">    &gt;&gt;&gt; trans_width = 260    # Width of transition from pass band to stop band, Hz</span>
<span class="sd">    &gt;&gt;&gt; numtaps = 10        # Size of the FIR filter.</span>
<span class="sd">    &gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1],</span>
<span class="sd">    ...          band[1] + trans_width, 0.5*fs]</span>
<span class="sd">    &gt;&gt;&gt; taps = signal.remez(numtaps, edges, [0, 1, 0], Hz=fs)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span>
<span class="sd">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;Band-pass Filter&quot;)</span>

<span class="sd">    It can be seen that for this bandpass filter, the low order leads to higher</span>
<span class="sd">    ripple and less steep transitions. There is very low attenuation in the</span>
<span class="sd">    stop band and little overshoot in the pass band.  Of course the desired</span>
<span class="sd">    gain can be better approximated with a higher filter order.</span>

<span class="sd">    The next example shows a bandstop filter. Because of the high filter order</span>
<span class="sd">    the transition is quite steep:</span>

<span class="sd">    &gt;&gt;&gt; fs = 20000.0         # Sample rate, Hz</span>
<span class="sd">    &gt;&gt;&gt; band = [6000, 8000]  # Desired stop band, Hz</span>
<span class="sd">    &gt;&gt;&gt; trans_width = 200    # Width of transition from pass band to stop band, Hz</span>
<span class="sd">    &gt;&gt;&gt; numtaps = 175        # Size of the FIR filter.</span>
<span class="sd">    &gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1], band[1] + trans_width, 0.5*fs]</span>
<span class="sd">    &gt;&gt;&gt; taps = signal.remez(numtaps, edges, [1, 0, 1], Hz=fs)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span>
<span class="sd">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;Band-stop Filter&quot;)</span>

<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Hz</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">Hz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values cannot be given for both &#39;Hz&#39; and &#39;fs&#39;.&quot;</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">Hz</span>

    <span class="c1"># Convert type</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tnum</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bandpass&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;differentiator&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;hilbert&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}[</span><span class="nb">type</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Type must be &#39;bandpass&#39;, &#39;differentiator&#39;, &quot;</span>
                         <span class="s2">&quot;or &#39;hilbert&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="c1"># Convert weight</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">desired</span><span class="p">)</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_remez</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">desired</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">tnum</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span>
                           <span class="n">maxiter</span><span class="p">,</span> <span class="n">grid_density</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">firls</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">desired</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FIR filter design using least-squares error minimization.</span>

<span class="sd">    Calculate the filter coefficients for the linear-phase finite</span>
<span class="sd">    impulse response (FIR) filter which has the best approximation</span>
<span class="sd">    to the desired frequency response described by `bands` and</span>
<span class="sd">    `desired` in the least squares sense (i.e., the integral of the</span>
<span class="sd">    weighted mean-squared error within the specified bands is</span>
<span class="sd">    minimized).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numtaps : int</span>
<span class="sd">        The number of taps in the FIR filter. `numtaps` must be odd.</span>
<span class="sd">    bands : array_like</span>
<span class="sd">        A monotonic nondecreasing sequence containing the band edges in</span>
<span class="sd">        Hz. All elements must be non-negative and less than or equal to</span>
<span class="sd">        the Nyquist frequency given by `nyq`.</span>
<span class="sd">    desired : array_like</span>
<span class="sd">        A sequence the same size as `bands` containing the desired gain</span>
<span class="sd">        at the start and end point of each band.</span>
<span class="sd">    weight : array_like, optional</span>
<span class="sd">        A relative weighting to give to each band region when solving</span>
<span class="sd">        the least squares problem. `weight` has to be half the size of</span>
<span class="sd">        `bands`.</span>
<span class="sd">    nyq : float, optional</span>
<span class="sd">        *Deprecated. Use `fs` instead.*</span>
<span class="sd">        Nyquist frequency. Each frequency in `bands` must be between 0</span>
<span class="sd">        and `nyq` (inclusive). Default is 1.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the signal. Each frequency in `bands`</span>
<span class="sd">        must be between 0 and ``fs/2`` (inclusive). Default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coeffs : ndarray</span>
<span class="sd">        Coefficients of the optimal (in a least squares sense) FIR filter.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    firwin</span>
<span class="sd">    firwin2</span>
<span class="sd">    minimum_phase</span>
<span class="sd">    remez</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This implementation follows the algorithm given in [1]_.</span>
<span class="sd">    As noted there, least squares design has multiple advantages:</span>

<span class="sd">        1. Optimal in a least-squares sense.</span>
<span class="sd">        2. Simple, non-iterative method.</span>
<span class="sd">        3. The general solution can obtained by solving a linear</span>
<span class="sd">           system of equations.</span>
<span class="sd">        4. Allows the use of a frequency dependent weighting function.</span>

<span class="sd">    This function constructs a Type I linear phase FIR filter, which</span>
<span class="sd">    contains an odd number of `coeffs` satisfying for :math:`n &lt; numtaps`:</span>

<span class="sd">    .. math:: coeffs(n) = coeffs(numtaps - 1 - n)</span>

<span class="sd">    The odd number of coefficients and filter symmetry avoid boundary</span>
<span class="sd">    conditions that could otherwise occur at the Nyquist and 0 frequencies</span>
<span class="sd">    (e.g., for Type II, III, or IV variants).</span>

<span class="sd">    .. versionadded:: 0.18</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Ivan Selesnick, Linear-Phase Fir Filter Design By Least Squares.</span>
<span class="sd">           OpenStax CNX. Aug 9, 2005.</span>
<span class="sd">           http://cnx.org/contents/eb1ecb35-03a9-4610-ba87-41cd771c95f2@7</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    We want to construct a band-pass filter. Note that the behavior in the</span>
<span class="sd">    frequency ranges between our stop bands and pass bands is unspecified,</span>
<span class="sd">    and thus may overshoot depending on the parameters of our filter:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, axs = plt.subplots(2)</span>
<span class="sd">    &gt;&gt;&gt; fs = 10.0  # Hz</span>
<span class="sd">    &gt;&gt;&gt; desired = (0, 0, 1, 1, 0, 0)</span>
<span class="sd">    &gt;&gt;&gt; for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))):</span>
<span class="sd">    ...     fir_firls = signal.firls(73, bands, desired, fs=fs)</span>
<span class="sd">    ...     fir_remez = signal.remez(73, bands, desired[::2], fs=fs)</span>
<span class="sd">    ...     fir_firwin2 = signal.firwin2(73, bands, desired, fs=fs)</span>
<span class="sd">    ...     hs = list()</span>
<span class="sd">    ...     ax = axs[bi]</span>
<span class="sd">    ...     for fir in (fir_firls, fir_remez, fir_firwin2):</span>
<span class="sd">    ...         freq, response = signal.freqz(fir)</span>
<span class="sd">    ...         hs.append(ax.semilogy(0.5*fs*freq/np.pi, np.abs(response))[0])</span>
<span class="sd">    ...     for band, gains in zip(zip(bands[::2], bands[1::2]),</span>
<span class="sd">    ...                            zip(desired[::2], desired[1::2])):</span>
<span class="sd">    ...         ax.semilogy(band, np.maximum(gains, 1e-7), &#39;k--&#39;, linewidth=2)</span>
<span class="sd">    ...     if bi == 0:</span>
<span class="sd">    ...         ax.legend(hs, (&#39;firls&#39;, &#39;remez&#39;, &#39;firwin2&#39;),</span>
<span class="sd">    ...                   loc=&#39;lower center&#39;, frameon=False)</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         ax.set_xlabel(&#39;Frequency (Hz)&#39;)</span>
<span class="sd">    ...     ax.grid(True)</span>
<span class="sd">    ...     ax.set(title=&#39;Band-pass %d-%d Hz&#39; % bands[2:4], ylabel=&#39;Magnitude&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">_get_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">nyq</span><span class="p">)</span>

    <span class="n">numtaps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numtaps</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">numtaps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">numtaps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numtaps must be odd and &gt;= 1&quot;</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">numtaps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># normalize bands 0-&gt;1 and make it 2 columns</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nyq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nyq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nyq must be positive, got </span><span class="si">%s</span><span class="s1"> &lt;= 0.&#39;</span> <span class="o">%</span> <span class="n">nyq</span><span class="p">)</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">/</span> <span class="n">nyq</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bands must contain frequency pairs.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bands</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bands</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bands must be between 0 and 1 relative to Nyquist&quot;</span><span class="p">)</span>
    <span class="n">bands</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># check remaining params</span>
    <span class="n">desired</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desired</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">bands</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">desired</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;desired must have one entry per frequency, got </span><span class="si">%s</span><span class="s2"> &quot;</span>
                         <span class="s2">&quot;gains for </span><span class="si">%s</span><span class="s2"> frequencies.&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">desired</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">bands</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
    <span class="n">desired</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bands</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bands must be monotonically nondecreasing and have &quot;</span>
                         <span class="s2">&quot;width &gt; 0.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bands</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bands</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bands must not overlap.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desired</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;desired must be non-negative.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desired</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">desired</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight must be the same size as the number of &quot;</span>
                         <span class="s2">&quot;band pairs (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">),))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight must be non-negative.&quot;</span><span class="p">)</span>

    <span class="c1"># Set up the linear matrix equation to be solved, Qa = b</span>

    <span class="c1"># We can express Q(k,n) = 0.5 Q1(k,n) + 0.5 Q2(k,n)</span>
    <span class="c1"># where Q1(k,n)=q(k-n) and Q2(k,n)=q(k+n), i.e. a Toeplitz plus Hankel.</span>

    <span class="c1"># We omit the factor of 0.5 above, instead adding it during coefficient</span>
    <span class="c1"># calculation.</span>

    <span class="c1"># We also omit the 1/π from both Q and b equations, as they cancel</span>
    <span class="c1"># during solving.</span>

    <span class="c1"># We have that:</span>
    <span class="c1">#     q(n) = 1/π ∫W(ω)cos(nω)dω (over 0-&gt;π)</span>
    <span class="c1"># Using our nomalization ω=πf and with a constant weight W over each</span>
    <span class="c1"># interval f1-&gt;f2 we get:</span>
    <span class="c1">#     q(n) = W∫cos(πnf)df (0-&gt;1) = Wf sin(πnf)/πnf</span>
    <span class="c1"># integrated over each f1-&gt;f2 pair (i.e., value at f2 - value at f1).</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numtaps</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">bands</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="p">)</span>

    <span class="c1"># Now we assemble our sum of Toeplitz and Hankel</span>
    <span class="n">Q1</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">q</span><span class="p">[:</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Q2</span> <span class="o">=</span> <span class="n">hankel</span><span class="p">(</span><span class="n">q</span><span class="p">[:</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">M</span><span class="p">:])</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">Q1</span> <span class="o">+</span> <span class="n">Q2</span>

    <span class="c1"># Now for b(n) we have that:</span>
    <span class="c1">#     b(n) = 1/π ∫ W(ω)D(ω)cos(nω)dω (over 0-&gt;π)</span>
    <span class="c1"># Using our normalization ω=πf and with a constant weight W over each</span>
    <span class="c1"># interval and a linear term for D(ω) we get (over each f1-&gt;f2 interval):</span>
    <span class="c1">#     b(n) = W ∫ (mf+c)cos(πnf)df</span>
    <span class="c1">#          = f(mf+c)sin(πnf)/πnf + mf**2 cos(nπf)/(πnf)**2</span>
    <span class="c1"># integrated over each f1-&gt;f2 pair (i.e., value at f2 - value at f1).</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[:</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># only need this many coefficients here</span>
    <span class="c1"># Choose m and c such that we are at the start and end weights</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">desired</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">desired</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">bands</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">m</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">bands</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">bands</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">bands</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
    <span class="c1"># Use L&#39;Hospital&#39;s rule here for cos(nπf)/(πnf)**2 @ n=0</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">bands</span> <span class="o">*</span> <span class="n">bands</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bands</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="p">)</span>

    <span class="c1"># Now we can solve the equation</span>
    <span class="k">try</span><span class="p">:</span>  <span class="c1"># try the fast way</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;always&#39;</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sym_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">category</span> <span class="o">==</span> <span class="n">LinAlgWarning</span> <span class="ow">and</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">message</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Ill-conditioned matrix&#39;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ww</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>  <span class="c1"># in case Q is rank deficient</span>
        <span class="c1"># This is faster than pinvh, even though we don&#39;t explicitly use</span>
        <span class="c1"># the symmetry here. gelsy was faster than gelsd and gelss in</span>
        <span class="c1"># some non-exhaustive tests.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lapack_driver</span><span class="o">=</span><span class="s1">&#39;gelsy&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># make coefficients symmetric (linear phase)</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">[:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">return</span> <span class="n">coeffs</span>


<span class="k">def</span> <span class="nf">_dhtm</span><span class="p">(</span><span class="n">mag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the modified 1-D discrete Hilbert transform</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mag : ndarray</span>
<span class="sd">        The magnitude spectrum. Should be 1-D with an even length, and</span>
<span class="sd">        preferably a fast length for FFT/IFFT.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Adapted based on code by Niranjan Damera-Venkata,</span>
    <span class="c1"># Brian L. Evans and Shawn R. McCaslin (see refs for `minimum_phase`)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mag</span><span class="p">))</span>
    <span class="c1"># Leave Nyquist and DC at 0, knowing np.abs(fftfreq(N)[midpt]) == 0.5</span>
    <span class="n">midpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">midpt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sig</span><span class="p">[</span><span class="n">midpt</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># eventually if we want to support complex filters, we will need a</span>
    <span class="c1"># np.abs() on the mag inside the log, and should remove the .real</span>
    <span class="n">recon</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">mag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">sig</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mag</span><span class="p">)))))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">return</span> <span class="n">recon</span>


<span class="k">def</span> <span class="nf">minimum_phase</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;homomorphic&#39;</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a linear-phase FIR filter to minimum phase</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : array</span>
<span class="sd">        Linear-phase FIR filter coefficients.</span>
<span class="sd">    method : {&#39;hilbert&#39;, &#39;homomorphic&#39;}</span>
<span class="sd">        The method to use:</span>

<span class="sd">            &#39;homomorphic&#39; (default)</span>
<span class="sd">                This method [4]_ [5]_ works best with filters with an</span>
<span class="sd">                odd number of taps, and the resulting minimum phase filter</span>
<span class="sd">                will have a magnitude response that approximates the square</span>
<span class="sd">                root of the the original filter&#39;s magnitude response.</span>

<span class="sd">            &#39;hilbert&#39;</span>
<span class="sd">                This method [1]_ is designed to be used with equiripple</span>
<span class="sd">                filters (e.g., from `remez`) with unity or zero gain</span>
<span class="sd">                regions.</span>

<span class="sd">    n_fft : int</span>
<span class="sd">        The number of points to use for the FFT. Should be at least a</span>
<span class="sd">        few times larger than the signal length (see Notes).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h_minimum : array</span>
<span class="sd">        The minimum-phase version of the filter, with length</span>
<span class="sd">        ``(length(h) + 1) // 2``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    firwin</span>
<span class="sd">    firwin2</span>
<span class="sd">    remez</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Both the Hilbert [1]_ or homomorphic [4]_ [5]_ methods require selection</span>
<span class="sd">    of an FFT length to estimate the complex cepstrum of the filter.</span>

<span class="sd">    In the case of the Hilbert method, the deviation from the ideal</span>
<span class="sd">    spectrum ``epsilon`` is related to the number of stopband zeros</span>
<span class="sd">    ``n_stop`` and FFT length ``n_fft`` as::</span>

<span class="sd">        epsilon = 2. * n_stop / n_fft</span>

<span class="sd">    For example, with 100 stopband zeros and a FFT length of 2048,</span>
<span class="sd">    ``epsilon = 0.0976``. If we conservatively assume that the number of</span>
<span class="sd">    stopband zeros is one less than the filter length, we can take the FFT</span>
<span class="sd">    length to be the next power of 2 that satisfies ``epsilon=0.01`` as::</span>

<span class="sd">        n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01)))</span>

<span class="sd">    This gives reasonable results for both the Hilbert and homomorphic</span>
<span class="sd">    methods, and gives the value used when ``n_fft=None``.</span>

<span class="sd">    Alternative implementations exist for creating minimum-phase filters,</span>
<span class="sd">    including zero inversion [2]_ and spectral factorization [3]_ [4]_.</span>
<span class="sd">    For more information, see:</span>

<span class="sd">        http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an optimal linear-phase filter, then convert it to minimum phase:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import remez, minimum_phase, freqz, group_delay</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; freq = [0, 0.2, 0.3, 1.0]</span>
<span class="sd">    &gt;&gt;&gt; desired = [1, 0]</span>
<span class="sd">    &gt;&gt;&gt; h_linear = remez(151, freq, desired, Hz=2.)</span>

<span class="sd">    Convert it to minimum phase:</span>

<span class="sd">    &gt;&gt;&gt; h_min_hom = minimum_phase(h_linear, method=&#39;homomorphic&#39;)</span>
<span class="sd">    &gt;&gt;&gt; h_min_hil = minimum_phase(h_linear, method=&#39;hilbert&#39;)</span>

<span class="sd">    Compare the three filters:</span>

<span class="sd">    &gt;&gt;&gt; fig, axs = plt.subplots(4, figsize=(4, 8))</span>
<span class="sd">    &gt;&gt;&gt; for h, style, color in zip((h_linear, h_min_hom, h_min_hil),</span>
<span class="sd">    ...                            (&#39;-&#39;, &#39;-&#39;, &#39;--&#39;), (&#39;k&#39;, &#39;r&#39;, &#39;c&#39;)):</span>
<span class="sd">    ...     w, H = freqz(h)</span>
<span class="sd">    ...     w, gd = group_delay((h, 1))</span>
<span class="sd">    ...     w /= np.pi</span>
<span class="sd">    ...     axs[0].plot(h, color=color, linestyle=style)</span>
<span class="sd">    ...     axs[1].plot(w, np.abs(H), color=color, linestyle=style)</span>
<span class="sd">    ...     axs[2].plot(w, 20 * np.log10(np.abs(H)), color=color, linestyle=style)</span>
<span class="sd">    ...     axs[3].plot(w, gd, color=color, linestyle=style)</span>
<span class="sd">    &gt;&gt;&gt; for ax in axs:</span>
<span class="sd">    ...     ax.grid(True, color=&#39;0.5&#39;)</span>
<span class="sd">    ...     ax.fill_between(freq[1:3], *ax.get_ylim(), color=&#39;#ffeeaa&#39;, zorder=1)</span>
<span class="sd">    &gt;&gt;&gt; axs[0].set(xlim=[0, len(h_linear) - 1], ylabel=&#39;Amplitude&#39;, xlabel=&#39;Samples&#39;)</span>
<span class="sd">    &gt;&gt;&gt; axs[1].legend([&#39;Linear&#39;, &#39;Min-Hom&#39;, &#39;Min-Hil&#39;], title=&#39;Phase&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for ax, ylim in zip(axs[1:], ([0, 1.1], [-150, 10], [-60, 60])):</span>
<span class="sd">    ...     ax.set(xlim=[0, 1], ylim=ylim, xlabel=&#39;Frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; axs[1].set(ylabel=&#39;Magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; axs[2].set(ylabel=&#39;Magnitude (dB)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; axs[3].set(ylabel=&#39;Group delay&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] N. Damera-Venkata and B. L. Evans, &quot;Optimal design of real and</span>
<span class="sd">           complex minimum phase digital FIR filters,&quot; Acoustics, Speech,</span>
<span class="sd">           and Signal Processing, 1999. Proceedings., 1999 IEEE International</span>
<span class="sd">           Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3.</span>
<span class="sd">           :doi:`10.1109/ICASSP.1999.756179`</span>
<span class="sd">    .. [2] X. Chen and T. W. Parks, &quot;Design of optimal minimum phase FIR</span>
<span class="sd">           filters by direct factorization,&quot; Signal Processing,</span>
<span class="sd">           vol. 10, no. 4, pp. 369-383, Jun. 1986.</span>
<span class="sd">    .. [3] T. Saramaki, &quot;Finite Impulse Response Filter Design,&quot; in</span>
<span class="sd">           Handbook for Digital Signal Processing, chapter 4,</span>
<span class="sd">           New York: Wiley-Interscience, 1993.</span>
<span class="sd">    .. [4] J. S. Lim, Advanced Topics in Signal Processing.</span>
<span class="sd">           Englewood Cliffs, N.J.: Prentice Hall, 1988.</span>
<span class="sd">    .. [5] A. V. Oppenheim, R. W. Schafer, and J. R. Buck,</span>
<span class="sd">           &quot;Discrete-Time Signal Processing,&quot; 2nd edition.</span>
<span class="sd">           Upper Saddle River, N.J.: Prentice Hall, 1999.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Complex filters not supported&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;h must be 1-D and at least 2 samples long&#39;</span><span class="p">)</span>
    <span class="n">n_half</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="o">-</span><span class="n">n_half</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">[:</span><span class="n">n_half</span><span class="p">]):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;h does not appear to by symmetric, conversion may &#39;</span>
                      <span class="s1">&#39;fail&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> \
            <span class="p">(</span><span class="s1">&#39;homomorphic&#39;</span><span class="p">,</span> <span class="s1">&#39;hilbert&#39;</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;method must be &quot;homomorphic&quot; or &quot;hilbert&quot;, got </span><span class="si">%r</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">n_fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.01</span><span class="p">)))</span>
    <span class="n">n_fft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_fft</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_fft</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_fft must be at least len(h)==</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hilbert&#39;</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_fft</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">n_fft</span> <span class="o">*</span> <span class="n">n_half</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span><span class="p">))</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="mf">4.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">dp</span><span class="o">+</span><span class="n">ds</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dp</span><span class="o">+</span><span class="n">ds</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="n">ds</span>
        <span class="n">H</span> <span class="o">*=</span> <span class="n">S</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="mf">1e-10</span>  <span class="c1"># ensure that the log does not explode</span>
        <span class="n">h_minimum</span> <span class="o">=</span> <span class="n">_dhtm</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># method == &#39;homomorphic&#39;</span>
        <span class="c1"># zero-pad; calculate the DFT</span>
        <span class="n">h_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">))</span>
        <span class="c1"># take 0.25*log(|H|**2) = 0.5*log(|H|)</span>
        <span class="n">h_temp</span> <span class="o">+=</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">h_temp</span><span class="p">[</span><span class="n">h_temp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>  <span class="c1"># don&#39;t let log blow up</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">h_temp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">h_temp</span><span class="p">)</span>
        <span class="n">h_temp</span> <span class="o">*=</span> <span class="mf">0.5</span>
        <span class="c1"># IDFT</span>
        <span class="n">h_temp</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">h_temp</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># multiply pointwise by the homomorphic filter</span>
        <span class="c1"># lmin[n] = 2u[n] - d[n]</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_fft</span><span class="p">)</span>
        <span class="n">win</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">win</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">win</span><span class="p">[</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h_temp</span> <span class="o">*=</span> <span class="n">win</span>
        <span class="n">h_temp</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">h_temp</span><span class="p">)))</span>
        <span class="n">h_minimum</span> <span class="o">=</span> <span class="n">h_temp</span><span class="o">.</span><span class="n">real</span>
    <span class="n">n_out</span> <span class="o">=</span> <span class="n">n_half</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">h_minimum</span><span class="p">[:</span><span class="n">n_out</span><span class="p">]</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, California Department of Water Resources.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>