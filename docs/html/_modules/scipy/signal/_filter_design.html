<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.signal._filter_design &#8212; vtools 0.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script src="../../../_static/documentation_options.js?v=7026087e"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/logo.png" border="0" alt="py4sci"/></a>
</div>



      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo"/>
            </a></p>
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/dwrsmall.jpg" alt="Logo" />
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Introduction and concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../daylight_savings.html">Daylight Savings conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html">Averging, Filtering and Low Passing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/filters.html#Filters">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/tidal_envelope.html">Tidal Envelope Extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/climatology.html">Fitting and using a climatology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/merge_splice.html">Merging and Splicing Time Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/merge_splice.html#ts_merge:-strict-priority-option"><code class="docutils literal notranslate"><span class="pre">ts_merge</span></code>: strict priority option</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/extrapolation.html">Extrapolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/transition.html">Transitioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scipy.signal._filter_design</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Filter design.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyval</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span>
                   <span class="n">resize</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">absolute</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">log10</span><span class="p">,</span>
                   <span class="n">arcsinh</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">arccosh</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span>
                   <span class="n">zeros</span><span class="p">,</span> <span class="n">sinh</span><span class="p">,</span> <span class="n">append</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">full</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span>
                   <span class="n">mintypecode</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial.polynomial</span> <span class="kn">import</span> <span class="n">polyval</span> <span class="k">as</span> <span class="n">npp_polyval</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial.polynomial</span> <span class="kn">import</span> <span class="n">polyvalfromroots</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span><span class="p">,</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">fft</span> <span class="k">as</span> <span class="n">sp_fft</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="kn">from</span> <span class="nn">scipy._lib._util</span> <span class="kn">import</span> <span class="n">float_factorial</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;findfreqs&#39;</span><span class="p">,</span> <span class="s1">&#39;freqs&#39;</span><span class="p">,</span> <span class="s1">&#39;freqz&#39;</span><span class="p">,</span> <span class="s1">&#39;tf2zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;zpk2tf&#39;</span><span class="p">,</span> <span class="s1">&#39;normalize&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lp2lp&#39;</span><span class="p">,</span> <span class="s1">&#39;lp2hp&#39;</span><span class="p">,</span> <span class="s1">&#39;lp2bp&#39;</span><span class="p">,</span> <span class="s1">&#39;lp2bs&#39;</span><span class="p">,</span> <span class="s1">&#39;bilinear&#39;</span><span class="p">,</span> <span class="s1">&#39;iirdesign&#39;</span><span class="p">,</span>
           <span class="s1">&#39;iirfilter&#39;</span><span class="p">,</span> <span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby1&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby2&#39;</span><span class="p">,</span> <span class="s1">&#39;ellip&#39;</span><span class="p">,</span> <span class="s1">&#39;bessel&#39;</span><span class="p">,</span>
           <span class="s1">&#39;band_stop_obj&#39;</span><span class="p">,</span> <span class="s1">&#39;buttord&#39;</span><span class="p">,</span> <span class="s1">&#39;cheb1ord&#39;</span><span class="p">,</span> <span class="s1">&#39;cheb2ord&#39;</span><span class="p">,</span> <span class="s1">&#39;ellipord&#39;</span><span class="p">,</span>
           <span class="s1">&#39;buttap&#39;</span><span class="p">,</span> <span class="s1">&#39;cheb1ap&#39;</span><span class="p">,</span> <span class="s1">&#39;cheb2ap&#39;</span><span class="p">,</span> <span class="s1">&#39;ellipap&#39;</span><span class="p">,</span> <span class="s1">&#39;besselap&#39;</span><span class="p">,</span>
           <span class="s1">&#39;BadCoefficients&#39;</span><span class="p">,</span> <span class="s1">&#39;freqs_zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;freqz_zpk&#39;</span><span class="p">,</span>
           <span class="s1">&#39;tf2sos&#39;</span><span class="p">,</span> <span class="s1">&#39;sos2tf&#39;</span><span class="p">,</span> <span class="s1">&#39;zpk2sos&#39;</span><span class="p">,</span> <span class="s1">&#39;sos2zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;group_delay&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sosfreqz&#39;</span><span class="p">,</span> <span class="s1">&#39;iirnotch&#39;</span><span class="p">,</span> <span class="s1">&#39;iirpeak&#39;</span><span class="p">,</span> <span class="s1">&#39;bilinear_zpk&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lp2lp_zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;lp2hp_zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;lp2bp_zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;lp2bs_zpk&#39;</span><span class="p">,</span>
           <span class="s1">&#39;gammatone&#39;</span><span class="p">,</span> <span class="s1">&#39;iircomb&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">BadCoefficients</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Warning about badly conditioned filter coefficients&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="nb">abs</span> <span class="o">=</span> <span class="n">absolute</span>


<span class="k">def</span> <span class="nf">_is_int_type</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if input is of a scalar integer type (so ``5`` and ``array(5)`` will</span>
<span class="sd">    pass, while ``5.0`` and ``array([5])`` will fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Older versions of NumPy did not raise for np.array([1]).__index__()</span>
        <span class="c1"># This is safe to remove when support for those versions is dropped</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">findfreqs</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find array of frequencies for computing the response of an analog filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num, den : array_like, 1-D</span>
<span class="sd">        The polynomial coefficients of the numerator and denominator of the</span>
<span class="sd">        transfer function of the filter or LTI system, where the coefficients</span>
<span class="sd">        are ordered from highest to lowest degree. Or, the roots  of the</span>
<span class="sd">        transfer function numerator and denominator (i.e., zeroes and poles).</span>
<span class="sd">    N : int</span>
<span class="sd">        The length of the array to be computed.</span>
<span class="sd">    kind : str {&#39;ba&#39;, &#39;zp&#39;}, optional</span>
<span class="sd">        Specifies whether the numerator and denominator are specified by their</span>
<span class="sd">        polynomial coefficients (&#39;ba&#39;), or their roots (&#39;zp&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (N,) ndarray</span>
<span class="sd">        A 1-D array of frequencies, logarithmically spaced.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find a set of nine frequencies that span the &quot;interesting part&quot; of the</span>
<span class="sd">    frequency response for the filter with the transfer function</span>

<span class="sd">        H(s) = s / (s^2 + 8s + 25)</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; signal.findfreqs([1, 0], [1, 8, 25], N=9)</span>
<span class="sd">    array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,</span>
<span class="sd">             3.16227766e-01,   1.00000000e+00,   3.16227766e+00,</span>
<span class="sd">             1.00000000e+01,   3.16227766e+01,   1.00000000e+02])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ba&#39;</span><span class="p">:</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">roots</span><span class="p">(</span><span class="n">den</span><span class="p">))</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">roots</span><span class="p">(</span><span class="n">num</span><span class="p">))</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;zp&#39;</span><span class="p">:</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">den</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input must be one of {&#39;ba&#39;, &#39;zp&#39;}&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>

    <span class="n">ez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ep</span><span class="p">[</span><span class="n">ep</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tz</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tz</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)]]</span>

    <span class="n">integ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ez</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
    <span class="n">hfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ez</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">integ</span><span class="p">)</span> <span class="o">+</span>
                                     <span class="mf">1.5</span> <span class="o">*</span> <span class="n">ez</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">lfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">ez</span> <span class="o">+</span> <span class="n">integ</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span>
                                           <span class="mi">2</span> <span class="o">*</span> <span class="n">ez</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">lfreq</span><span class="p">,</span> <span class="n">hfreq</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">freqs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute frequency response of analog filter.</span>

<span class="sd">    Given the M-order numerator `b` and N-order denominator `a` of an analog</span>
<span class="sd">    filter, compute its frequency response::</span>

<span class="sd">             b[0]*(jw)**M + b[1]*(jw)**(M-1) + ... + b[M]</span>
<span class="sd">     H(w) = ----------------------------------------------</span>
<span class="sd">             a[0]*(jw)**N + a[1]*(jw)**(N-1) + ... + a[N]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator of a linear filter.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator of a linear filter.</span>
<span class="sd">    worN : {None, int, array_like}, optional</span>
<span class="sd">        If None, then compute at 200 frequencies around the interesting parts</span>
<span class="sd">        of the response curve (determined by pole-zero locations). If a single</span>
<span class="sd">        integer, then compute at that many frequencies. Otherwise, compute the</span>
<span class="sd">        response at the angular frequencies (e.g., rad/s) given in `worN`.</span>
<span class="sd">    plot : callable, optional</span>
<span class="sd">        A callable that takes two arguments. If given, the return parameters</span>
<span class="sd">        `w` and `h` are passed to plot. Useful for plotting the frequency</span>
<span class="sd">        response inside `freqs`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        The angular frequencies at which `h` was computed.</span>
<span class="sd">    h : ndarray</span>
<span class="sd">        The frequency response.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    freqz : Compute the frequency response of a digital filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Using Matplotlib&#39;s &quot;plot&quot; function as the callable for `plot` produces</span>
<span class="sd">    unexpected results, this plots the real part of the complex transfer</span>
<span class="sd">    function, not the magnitude. Try ``lambda w, h: plot(w, abs(h))``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import freqs, iirfilter</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype=&#39;cheby1&#39;)</span>

<span class="sd">    &gt;&gt;&gt; w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude response [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">worN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">findfreqs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_is_int_type</span><span class="p">(</span><span class="n">worN</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">findfreqs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">worN</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">worN</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">polyval</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">polyval</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">freqs_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute frequency response of analog filter.</span>

<span class="sd">    Given the zeros `z`, poles `p`, and gain `k` of a filter, compute its</span>
<span class="sd">    frequency response::</span>

<span class="sd">                (jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1])</span>
<span class="sd">     H(w) = k * ----------------------------------------</span>
<span class="sd">                (jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1])</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeroes of a linear filter</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of a linear filter</span>
<span class="sd">    k : scalar</span>
<span class="sd">        Gain of a linear filter</span>
<span class="sd">    worN : {None, int, array_like}, optional</span>
<span class="sd">        If None, then compute at 200 frequencies around the interesting parts</span>
<span class="sd">        of the response curve (determined by pole-zero locations). If a single</span>
<span class="sd">        integer, then compute at that many frequencies. Otherwise, compute the</span>
<span class="sd">        response at the angular frequencies (e.g., rad/s) given in `worN`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        The angular frequencies at which `h` was computed.</span>
<span class="sd">    h : ndarray</span>
<span class="sd">        The frequency response.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    freqs : Compute the frequency response of an analog filter in TF form</span>
<span class="sd">    freqz : Compute the frequency response of a digital filter in TF form</span>
<span class="sd">    freqz_zpk : Compute the frequency response of a digital filter in ZPK form</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import freqs_zpk, iirfilter</span>

<span class="sd">    &gt;&gt;&gt; z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype=&#39;cheby1&#39;,</span>
<span class="sd">    ...                     output=&#39;zpk&#39;)</span>

<span class="sd">    &gt;&gt;&gt; w, h = freqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000))</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude response [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be a single scalar gain&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">worN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">findfreqs</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zp&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_is_int_type</span><span class="p">(</span><span class="n">worN</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">findfreqs</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">worN</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;zp&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">worN</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">num</span><span class="o">/</span><span class="n">den</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>


<div class="viewcode-block" id="freqz">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.filter.freqz">[docs]</a>
<span class="k">def</span> <span class="nf">freqz</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">whole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span>
          <span class="n">include_nyquist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the frequency response of a digital filter.</span>

<span class="sd">    Given the M-order numerator `b` and N-order denominator `a` of a digital</span>
<span class="sd">    filter, compute its frequency response::</span>

<span class="sd">                 jw                 -jw              -jwM</span>
<span class="sd">        jw    B(e  )    b[0] + b[1]e    + ... + b[M]e</span>
<span class="sd">     H(e  ) = ------ = -----------------------------------</span>
<span class="sd">                 jw                 -jw              -jwN</span>
<span class="sd">              A(e  )    a[0] + a[1]e    + ... + a[N]e</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator of a linear filter. If `b` has dimension greater than 1,</span>
<span class="sd">        it is assumed that the coefficients are stored in the first dimension,</span>
<span class="sd">        and ``b.shape[1:]``, ``a.shape[1:]``, and the shape of the frequencies</span>
<span class="sd">        array must be compatible for broadcasting.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator of a linear filter. If `b` has dimension greater than 1,</span>
<span class="sd">        it is assumed that the coefficients are stored in the first dimension,</span>
<span class="sd">        and ``b.shape[1:]``, ``a.shape[1:]``, and the shape of the frequencies</span>
<span class="sd">        array must be compatible for broadcasting.</span>
<span class="sd">    worN : {None, int, array_like}, optional</span>
<span class="sd">        If a single integer, then compute at that many frequencies (default is</span>
<span class="sd">        N=512). This is a convenient alternative to::</span>

<span class="sd">            np.linspace(0, fs if whole else fs/2, N, endpoint=include_nyquist)</span>

<span class="sd">        Using a number that is fast for FFT computations can result in</span>
<span class="sd">        faster computations (see Notes).</span>

<span class="sd">        If an array_like, compute the response at the frequencies given.</span>
<span class="sd">        These are in the same units as `fs`.</span>
<span class="sd">    whole : bool, optional</span>
<span class="sd">        Normally, frequencies are computed from 0 to the Nyquist frequency,</span>
<span class="sd">        fs/2 (upper-half of unit-circle). If `whole` is True, compute</span>
<span class="sd">        frequencies from 0 to fs. Ignored if worN is array_like.</span>
<span class="sd">    plot : callable</span>
<span class="sd">        A callable that takes two arguments. If given, the return parameters</span>
<span class="sd">        `w` and `h` are passed to plot. Useful for plotting the frequency</span>
<span class="sd">        response inside `freqz`.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system. Defaults to 2*pi</span>
<span class="sd">        radians/sample (so w is from 0 to pi).</span>

<span class="sd">        .. versionadded:: 1.2.0</span>
<span class="sd">    include_nyquist : bool, optional</span>
<span class="sd">        If `whole` is False and `worN` is an integer, setting `include_nyquist`</span>
<span class="sd">        to True will include the last frequency (Nyquist frequency) and is</span>
<span class="sd">        otherwise ignored.</span>

<span class="sd">        .. versionadded:: 1.5.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        The frequencies at which `h` was computed, in the same units as `fs`.</span>
<span class="sd">        By default, `w` is normalized to the range [0, pi) (radians/sample).</span>
<span class="sd">    h : ndarray</span>
<span class="sd">        The frequency response, as complex numbers.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    freqz_zpk</span>
<span class="sd">    sosfreqz</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Using Matplotlib&#39;s :func:`matplotlib.pyplot.plot` function as the callable</span>
<span class="sd">    for `plot` produces unexpected results, as this plots the real part of the</span>
<span class="sd">    complex transfer function, not the magnitude.</span>
<span class="sd">    Try ``lambda w, h: plot(w, np.abs(h))``.</span>

<span class="sd">    A direct computation via (R)FFT is used to compute the frequency response</span>
<span class="sd">    when the following conditions are met:</span>

<span class="sd">    1. An integer value is given for `worN`.</span>
<span class="sd">    2. `worN` is fast to compute via FFT (i.e.,</span>
<span class="sd">       `next_fast_len(worN) &lt;scipy.fft.next_fast_len&gt;` equals `worN`).</span>
<span class="sd">    3. The denominator coefficients are a single value (``a.shape[0] == 1``).</span>
<span class="sd">    4. `worN` is at least as long as the numerator coefficients</span>
<span class="sd">       (``worN &gt;= b.shape[0]``).</span>
<span class="sd">    5. If ``b.ndim &gt; 1``, then ``b.shape[-1] == 1``.</span>

<span class="sd">    For long FIR filters, the FFT approach can have lower error and be much</span>
<span class="sd">    faster than the equivalent direct polynomial calculation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; b = signal.firwin(80, 0.5, window=(&#39;kaiser&#39;, 8))</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax1 = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;Digital filter frequency response&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ax1.plot(w, 20 * np.log10(abs(h)), &#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_ylabel(&#39;Amplitude [dB]&#39;, color=&#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_xlabel(&#39;Frequency [rad/sample]&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ax2 = ax1.twinx()</span>
<span class="sd">    &gt;&gt;&gt; angles = np.unwrap(np.angle(h))</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(w, angles, &#39;g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_ylabel(&#39;Angle (radians)&#39;, color=&#39;g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax2.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Broadcasting Examples</span>

<span class="sd">    Suppose we have two FIR filters whose coefficients are stored in the</span>
<span class="sd">    rows of an array with shape (2, 25). For this demonstration, we&#39;ll</span>
<span class="sd">    use random data:</span>

<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; b = rng.random((2, 25))</span>

<span class="sd">    To compute the frequency response for these two filters with one call</span>
<span class="sd">    to `freqz`, we must pass in ``b.T``, because `freqz` expects the first</span>
<span class="sd">    axis to hold the coefficients. We must then extend the shape with a</span>
<span class="sd">    trivial dimension of length 1 to allow broadcasting with the array</span>
<span class="sd">    of frequencies.  That is, we pass in ``b.T[..., np.newaxis]``, which has</span>
<span class="sd">    shape (25, 2, 1):</span>

<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b.T[..., np.newaxis], worN=1024)</span>
<span class="sd">    &gt;&gt;&gt; w.shape</span>
<span class="sd">    (1024,)</span>
<span class="sd">    &gt;&gt;&gt; h.shape</span>
<span class="sd">    (2, 1024)</span>

<span class="sd">    Now, suppose we have two transfer functions, with the same numerator</span>
<span class="sd">    coefficients ``b = [0.5, 0.5]``. The coefficients for the two denominators</span>
<span class="sd">    are stored in the first dimension of the 2-D array  `a`::</span>

<span class="sd">        a = [   1      1  ]</span>
<span class="sd">            [ -0.25, -0.5 ]</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([0.5, 0.5])</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [-0.25, -0.5]])</span>

<span class="sd">    Only `a` is more than 1-D. To make it compatible for</span>
<span class="sd">    broadcasting with the frequencies, we extend it with a trivial dimension</span>
<span class="sd">    in the call to `freqz`:</span>

<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b, a[..., np.newaxis], worN=1024)</span>
<span class="sd">    &gt;&gt;&gt; w.shape</span>
<span class="sd">    (1024,)</span>
<span class="sd">    &gt;&gt;&gt; h.shape</span>
<span class="sd">    (2, 1024)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">worN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="n">worN</span> <span class="o">=</span> <span class="mi">512</span>

    <span class="n">h</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">_is_int_type</span><span class="p">(</span><span class="n">worN</span><span class="p">):</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">worN</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">worN</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;worN must be nonnegative, got </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">lastpoint</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="k">if</span> <span class="n">whole</span> <span class="k">else</span> <span class="n">pi</span>
        <span class="c1"># if include_nyquist is true and whole is false, w should</span>
        <span class="c1"># include end point</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lastpoint</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
                        <span class="n">endpoint</span><span class="o">=</span><span class="n">include_nyquist</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">whole</span><span class="p">)</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">N</span> <span class="k">if</span> <span class="n">whole</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">include_nyquist</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">n_fft</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">n_fft</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># TODO: review threshold acc. to benchmark?</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="n">fft_func</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">rfft</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fft_func</span> <span class="o">=</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">fft</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">fft_func</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">N</span><span class="p">]</span>
            <span class="n">h</span> <span class="o">/=</span> <span class="n">a</span>
            <span class="k">if</span> <span class="n">fft_func</span> <span class="ow">is</span> <span class="n">sp_fft</span><span class="o">.</span><span class="n">rfft</span> <span class="ow">and</span> <span class="n">whole</span><span class="p">:</span>
                <span class="c1"># exclude DC and maybe Nyquist (no need to use axis_reverse</span>
                <span class="c1"># here because we can build reversal with the truncation)</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">n_fft</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">2</span>
                <span class="n">h_flip</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">h_flip</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Last axis of h has length 1, so drop it.</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Move the first axis of h to the end.</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">worN</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">worN</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">w</span><span class="o">/</span><span class="n">fs</span>

    <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># still need to compute using freqs w</span>
        <span class="n">zm1</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">npp_polyval</span><span class="p">(</span><span class="n">zm1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">/</span>
             <span class="n">npp_polyval</span><span class="p">(</span><span class="n">zm1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span></div>



<span class="k">def</span> <span class="nf">freqz_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">whole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the frequency response of a digital filter in ZPK form.</span>

<span class="sd">    Given the Zeros, Poles and Gain of a digital filter, compute its frequency</span>
<span class="sd">    response:</span>

<span class="sd">    :math:`H(z)=k \prod_i (z - Z[i]) / \prod_j (z - P[j])`</span>

<span class="sd">    where :math:`k` is the `gain`, :math:`Z` are the `zeros` and :math:`P` are</span>
<span class="sd">    the `poles`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeroes of a linear filter</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of a linear filter</span>
<span class="sd">    k : scalar</span>
<span class="sd">        Gain of a linear filter</span>
<span class="sd">    worN : {None, int, array_like}, optional</span>
<span class="sd">        If a single integer, then compute at that many frequencies (default is</span>
<span class="sd">        N=512).</span>

<span class="sd">        If an array_like, compute the response at the frequencies given.</span>
<span class="sd">        These are in the same units as `fs`.</span>
<span class="sd">    whole : bool, optional</span>
<span class="sd">        Normally, frequencies are computed from 0 to the Nyquist frequency,</span>
<span class="sd">        fs/2 (upper-half of unit-circle). If `whole` is True, compute</span>
<span class="sd">        frequencies from 0 to fs. Ignored if w is array_like.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system. Defaults to 2*pi</span>
<span class="sd">        radians/sample (so w is from 0 to pi).</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        The frequencies at which `h` was computed, in the same units as `fs`.</span>
<span class="sd">        By default, `w` is normalized to the range [0, pi) (radians/sample).</span>
<span class="sd">    h : ndarray</span>
<span class="sd">        The frequency response, as complex numbers.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    freqs : Compute the frequency response of an analog filter in TF form</span>
<span class="sd">    freqs_zpk : Compute the frequency response of an analog filter in ZPK form</span>
<span class="sd">    freqz : Compute the frequency response of a digital filter in TF form</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design a 4th-order digital Butterworth filter with cut-off of 100 Hz in a</span>
<span class="sd">    system with sample rate of 1000 Hz, and plot the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; z, p, k = signal.butter(4, 100, output=&#39;zpk&#39;, fs=1000)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz_zpk(z, p, k, fs=1000)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax1 = fig.add_subplot(1, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;Digital filter frequency response&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ax1.plot(w, 20 * np.log10(abs(h)), &#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_ylabel(&#39;Amplitude [dB]&#39;, color=&#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_xlabel(&#39;Frequency [Hz]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.grid(True)</span>

<span class="sd">    &gt;&gt;&gt; ax2 = ax1.twinx()</span>
<span class="sd">    &gt;&gt;&gt; angles = np.unwrap(np.angle(h))</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(w, angles, &#39;g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_ylabel(&#39;Angle [radians]&#39;, color=&#39;g&#39;)</span>

<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">whole</span><span class="p">:</span>
        <span class="n">lastpoint</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lastpoint</span> <span class="o">=</span> <span class="n">pi</span>

    <span class="k">if</span> <span class="n">worN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lastpoint</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_is_int_type</span><span class="p">(</span><span class="n">worN</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lastpoint</span><span class="p">,</span> <span class="n">worN</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">worN</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">w</span><span class="o">/</span><span class="n">fs</span>

    <span class="n">zm1</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">zm1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">polyvalfromroots</span><span class="p">(</span><span class="n">zm1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">group_delay</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">whole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the group delay of a digital filter.</span>

<span class="sd">    The group delay measures by how many samples amplitude envelopes of</span>
<span class="sd">    various spectral components of a signal are delayed by a filter.</span>
<span class="sd">    It is formally defined as the derivative of continuous (unwrapped) phase::</span>

<span class="sd">               d        jw</span>
<span class="sd">     D(w) = - -- arg H(e)</span>
<span class="sd">              dw</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    system : tuple of array_like (b, a)</span>
<span class="sd">        Numerator and denominator coefficients of a filter transfer function.</span>
<span class="sd">    w : {None, int, array_like}, optional</span>
<span class="sd">        If a single integer, then compute at that many frequencies (default is</span>
<span class="sd">        N=512).</span>

<span class="sd">        If an array_like, compute the delay at the frequencies given. These</span>
<span class="sd">        are in the same units as `fs`.</span>
<span class="sd">    whole : bool, optional</span>
<span class="sd">        Normally, frequencies are computed from 0 to the Nyquist frequency,</span>
<span class="sd">        fs/2 (upper-half of unit-circle). If `whole` is True, compute</span>
<span class="sd">        frequencies from 0 to fs. Ignored if w is array_like.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system. Defaults to 2*pi</span>
<span class="sd">        radians/sample (so w is from 0 to pi).</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        The frequencies at which group delay was computed, in the same units</span>
<span class="sd">        as `fs`.  By default, `w` is normalized to the range [0, pi)</span>
<span class="sd">        (radians/sample).</span>
<span class="sd">    gd : ndarray</span>
<span class="sd">        The group delay.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    freqz : Frequency response of a digital filter</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The similar function in MATLAB is called `grpdelay`.</span>

<span class="sd">    If the transfer function :math:`H(z)` has zeros or poles on the unit</span>
<span class="sd">    circle, the group delay at corresponding frequencies is undefined.</span>
<span class="sd">    When such a case arises the warning is raised and the group delay</span>
<span class="sd">    is set to 0 at those frequencies.</span>

<span class="sd">    For the details of numerical computation of the group delay refer to [1]_.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Richard G. Lyons, &quot;Understanding Digital Signal Processing,</span>
<span class="sd">           3rd edition&quot;, p. 830.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.iirdesign(0.1, 0.3, 5, 50, ftype=&#39;cheby1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, gd = signal.group_delay((b, a))</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Digital filter group delay&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w, gd)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Group delay [samples]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [rad/sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">512</span>

    <span class="k">if</span> <span class="n">_is_int_type</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">whole</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">w</span><span class="o">/</span><span class="n">fs</span>

    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">cr</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">cr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">c</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">gd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">gd</span><span class="p">)</span>
    <span class="n">near_singular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">den</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">EPSILON</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">singular</span><span class="p">):</span>
        <span class="n">gd</span><span class="p">[</span><span class="n">singular</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The group delay is singular at frequencies [</span><span class="si">{}</span><span class="s2">], setting to 0&quot;</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ws</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">w</span><span class="p">[</span><span class="n">singular</span><span class="p">])),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">near_singular</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The filter&#39;s denominator is extremely small at frequencies [</span><span class="si">{}</span><span class="s2">], </span><span class="se">\</span>
<span class="s2">            around which a singularity may be present&quot;</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ws</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">w</span><span class="p">[</span><span class="n">near_singular</span><span class="p">])),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">gd</span>


<span class="k">def</span> <span class="nf">_validate_sos</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to validate a SOS input&quot;&quot;&quot;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos array must be 2D&#39;</span><span class="p">)</span>
    <span class="n">n_sections</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos array must be shape (n_sections, 6)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sos</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos[:, 3] should be all ones&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sos</span><span class="p">,</span> <span class="n">n_sections</span>


<span class="k">def</span> <span class="nf">sosfreqz</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">whole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the frequency response of a digital filter in SOS format.</span>

<span class="sd">    Given `sos`, an array with shape (n, 6) of second order sections of</span>
<span class="sd">    a digital filter, compute the frequency response of the system function::</span>

<span class="sd">               B0(z)   B1(z)         B{n-1}(z)</span>
<span class="sd">        H(z) = ----- * ----- * ... * ---------</span>
<span class="sd">               A0(z)   A1(z)         A{n-1}(z)</span>

<span class="sd">    for z = exp(omega*1j), where B{k}(z) and A{k}(z) are numerator and</span>
<span class="sd">    denominator of the transfer function of the k-th second order section.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. Each row corresponds to a second-order</span>
<span class="sd">        section, with the first three columns providing the numerator</span>
<span class="sd">        coefficients and the last three providing the denominator</span>
<span class="sd">        coefficients.</span>
<span class="sd">    worN : {None, int, array_like}, optional</span>
<span class="sd">        If a single integer, then compute at that many frequencies (default is</span>
<span class="sd">        N=512).  Using a number that is fast for FFT computations can result</span>
<span class="sd">        in faster computations (see Notes of `freqz`).</span>

<span class="sd">        If an array_like, compute the response at the frequencies given (must</span>
<span class="sd">        be 1-D). These are in the same units as `fs`.</span>
<span class="sd">    whole : bool, optional</span>
<span class="sd">        Normally, frequencies are computed from 0 to the Nyquist frequency,</span>
<span class="sd">        fs/2 (upper-half of unit-circle). If `whole` is True, compute</span>
<span class="sd">        frequencies from 0 to fs.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system. Defaults to 2*pi</span>
<span class="sd">        radians/sample (so w is from 0 to pi).</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : ndarray</span>
<span class="sd">        The frequencies at which `h` was computed, in the same units as `fs`.</span>
<span class="sd">        By default, `w` is normalized to the range [0, pi) (radians/sample).</span>
<span class="sd">    h : ndarray</span>
<span class="sd">        The frequency response, as complex numbers.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    freqz, sosfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design a 15th-order bandpass filter in SOS format.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; sos = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype=&#39;bandpass&#39;,</span>
<span class="sd">    ...                    output=&#39;sos&#39;)</span>

<span class="sd">    Compute the frequency response at 1500 points from DC to Nyquist.</span>

<span class="sd">    &gt;&gt;&gt; w, h = signal.sosfreqz(sos, worN=1500)</span>

<span class="sd">    Plot the response.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; db = 20*np.log10(np.maximum(np.abs(h), 1e-5))</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w/np.pi, db)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylim(-75, 5)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.yticks([0, -20, -40, -60])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Gain [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Frequency Response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w/np.pi, np.angle(h))</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi],</span>
<span class="sd">    ...            [r&#39;$-\pi$&#39;, r&#39;$-\pi/2$&#39;, &#39;0&#39;, r&#39;$\pi/2$&#39;, r&#39;$\pi$&#39;])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Phase [rad]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Normalized frequency (1.0 = Nyquist)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    If the same filter is implemented as a single transfer function,</span>
<span class="sd">    numerical error corrupts the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype=&#39;bandpass&#39;,</span>
<span class="sd">    ...                    output=&#39;ba&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b, a, worN=1500)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; db = 20*np.log10(np.maximum(np.abs(h), 1e-5))</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w/np.pi, db)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylim(-75, 5)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.yticks([0, -20, -40, -60])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Gain [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Frequency Response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.subplot(2, 1, 2)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w/np.pi, np.angle(h))</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi],</span>
<span class="sd">    ...            [r&#39;$-\pi$&#39;, r&#39;$-\pi/2$&#39;, &#39;0&#39;, r&#39;$\pi/2$&#39;, r&#39;$\pi$&#39;])</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Phase [rad]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Normalized frequency (1.0 = Nyquist)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sos</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">_validate_sos</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_sections</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute frequencies with no sections&#39;</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">sos</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">rowh</span> <span class="o">=</span> <span class="n">freqz</span><span class="p">(</span><span class="n">row</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">:],</span> <span class="n">worN</span><span class="o">=</span><span class="n">worN</span><span class="p">,</span> <span class="n">whole</span><span class="o">=</span><span class="n">whole</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">*=</span> <span class="n">rowh</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_cplxreal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split into complex and real parts, combining conjugate pairs.</span>

<span class="sd">    The 1-D input vector `z` is split up into its complex (`zc`) and real (`zr`)</span>
<span class="sd">    elements. Every complex element must be part of a complex-conjugate pair,</span>
<span class="sd">    which are combined into a single number (with positive imaginary part) in</span>
<span class="sd">    the output. Two complex numbers are considered a conjugate pair if their</span>
<span class="sd">    real and imaginary parts differ in magnitude by less than ``tol * abs(z)``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Vector of complex numbers to be sorted and split</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Relative tolerance for testing realness and conjugate equality.</span>
<span class="sd">        Default is ``100 * spacing(1)`` of `z`&#39;s data type (i.e., 2e-14 for</span>
<span class="sd">        float64)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zc : ndarray</span>
<span class="sd">        Complex elements of `z`, with each pair represented by a single value</span>
<span class="sd">        having positive imaginary part, sorted first by real part, and then</span>
<span class="sd">        by magnitude of imaginary part. The pairs are averaged when combined</span>
<span class="sd">        to reduce error.</span>
<span class="sd">    zr : ndarray</span>
<span class="sd">        Real elements of `z` (those having imaginary part less than</span>
<span class="sd">        `tol` times their magnitude), sorted by value.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are any complex numbers in `z` for which a conjugate</span>
<span class="sd">        cannot be found.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    _cplxpair</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal._filter_design import _cplxreal</span>
<span class="sd">    &gt;&gt;&gt; a = [4, 3, 1, 2-2j, 2+2j, 2-1j, 2+1j, 2-1j, 2+1j, 1+1j, 1-1j]</span>
<span class="sd">    &gt;&gt;&gt; zc, zr = _cplxreal(a)</span>
<span class="sd">    &gt;&gt;&gt; print(zc)</span>
<span class="sd">    [ 1.+1.j  2.+1.j  2.+1.j  2.+2.j]</span>
<span class="sd">    &gt;&gt;&gt; print(zr)</span>
<span class="sd">    [ 1.  3.  4.]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span>
    <span class="k">elif</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_cplxreal only accepts 1-D input&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get tolerance from dtype of input</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="c1"># Sort by real part, magnitude of imaginary part (speed up further sorting)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">))]</span>

    <span class="c1"># Split reals from conjugate pairs</span>
    <span class="n">real_indices</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">zr</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">real_indices</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="c1"># Input is entirely real</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([]),</span> <span class="n">zr</span>

    <span class="c1"># Split positive and negative halves of conjugates</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="o">~</span><span class="n">real_indices</span><span class="p">]</span>
    <span class="n">zp</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">zn</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">zn</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Array contains complex value with no matching &#39;</span>
                         <span class="s1">&#39;conjugate.&#39;</span><span class="p">)</span>

    <span class="c1"># Find runs of (approximately) the same real part</span>
    <span class="n">same_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">zp</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">same_real</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="n">run_starts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">diffs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">run_stops</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">diffs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Sort each run by their imaginary parts</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run_starts</span><span class="p">)):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">run_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">run_stops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="p">(</span><span class="n">zp</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">],</span> <span class="n">zn</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]):</span>
            <span class="n">chunk</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">imag</span><span class="p">)])]</span>

    <span class="c1"># Check that negatives match positives</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">zp</span> <span class="o">-</span> <span class="n">zn</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zn</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Array contains complex value with no matching &#39;</span>
                         <span class="s1">&#39;conjugate.&#39;</span><span class="p">)</span>

    <span class="c1"># Average out numerical inaccuracy in real vs imag parts of pairs</span>
    <span class="n">zc</span> <span class="o">=</span> <span class="p">(</span><span class="n">zp</span> <span class="o">+</span> <span class="n">zn</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">zc</span><span class="p">,</span> <span class="n">zr</span>


<span class="k">def</span> <span class="nf">_cplxpair</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort into pairs of complex conjugates.</span>

<span class="sd">    Complex conjugates in `z` are sorted by increasing real part. In each</span>
<span class="sd">    pair, the number with negative imaginary part appears first.</span>

<span class="sd">    If pairs have identical real parts, they are sorted by increasing</span>
<span class="sd">    imaginary magnitude.</span>

<span class="sd">    Two complex numbers are considered a conjugate pair if their real and</span>
<span class="sd">    imaginary parts differ in magnitude by less than ``tol * abs(z)``.  The</span>
<span class="sd">    pairs are forced to be exact complex conjugates by averaging the positive</span>
<span class="sd">    and negative values.</span>

<span class="sd">    Purely real numbers are also sorted, but placed after the complex</span>
<span class="sd">    conjugate pairs. A number is considered real if its imaginary part is</span>
<span class="sd">    smaller than `tol` times the magnitude of the number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        1-D input array to be sorted.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Relative tolerance for testing realness and conjugate equality.</span>
<span class="sd">        Default is ``100 * spacing(1)`` of `z`&#39;s data type (i.e., 2e-14 for</span>
<span class="sd">        float64)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        Complex conjugate pairs followed by real numbers.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there are any complex numbers in `z` for which a conjugate</span>
<span class="sd">        cannot be found.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    _cplxreal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal._filter_design import _cplxpair</span>
<span class="sd">    &gt;&gt;&gt; a = [4, 3, 1, 2-2j, 2+2j, 2-1j, 2+1j, 2-1j, 2+1j, 1+1j, 1-1j]</span>
<span class="sd">    &gt;&gt;&gt; z = _cplxpair(a)</span>
<span class="sd">    &gt;&gt;&gt; print(z)</span>
<span class="sd">    [ 1.-1.j  1.+1.j  2.-1.j  2.+1.j  2.-1.j  2.+1.j  2.-2.j  2.+2.j  1.+0.j</span>
<span class="sd">      3.+0.j  4.+0.j]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;z must be 1-D&#39;</span><span class="p">)</span>

    <span class="n">zc</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">_cplxreal</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="c1"># Interleave complex values and their conjugates, with negative imaginary</span>
    <span class="c1"># parts first in each pair</span>
    <span class="n">zc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">zc</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">zc</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zc</span><span class="p">,</span> <span class="n">zr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span> <span class="nf">tf2zpk</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return zero, pole, gain (z, p, k) representation from a numerator,</span>
<span class="sd">    denominator representation of a linear filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If some values of `b` are too close to 0, they are removed. In that case,</span>
<span class="sd">    a BadCoefficients warning is emitted.</span>

<span class="sd">    The `b` and `a` arrays are interpreted as coefficients for positive,</span>
<span class="sd">    descending powers of the transfer function variable. So the inputs</span>
<span class="sd">    :math:`b = [b_0, b_1, ..., b_M]` and :math:`a =[a_0, a_1, ..., a_N]`</span>
<span class="sd">    can represent an analog filter of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">        H(s) = \frac</span>
<span class="sd">        {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}</span>
<span class="sd">        {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}</span>

<span class="sd">    or a discrete-time filter of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">        H(z) = \frac</span>
<span class="sd">        {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}</span>
<span class="sd">        {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}</span>

<span class="sd">    This &quot;positive powers&quot; form is found more commonly in controls</span>
<span class="sd">    engineering. If `M` and `N` are equal (which is true for all filters</span>
<span class="sd">    generated by the bilinear transform), then this happens to be equivalent</span>
<span class="sd">    to the &quot;negative powers&quot; discrete-time form preferred in DSP:</span>

<span class="sd">    .. math::</span>

<span class="sd">        H(z) = \frac</span>
<span class="sd">        {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}</span>
<span class="sd">        {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}</span>

<span class="sd">    Although this is true for common filters, remember that this is not true</span>
<span class="sd">    in the general case. If `M` and `N` are not equal, the discrete-time</span>
<span class="sd">    transfer function coefficients must first be converted to the &quot;positive</span>
<span class="sd">    powers&quot; form before finding the poles and zeros.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the zeroes, poles and gain of </span>
<span class="sd">    a filter with the transfer function</span>

<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        H(s) = \frac{3s^2}{s^2 + 5s + 13}</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import tf2zpk</span>
<span class="sd">    &gt;&gt;&gt; tf2zpk([3, 0, 0], [1, 5, 13])</span>
<span class="sd">    (   array([ 0.               ,  0.              ]), </span>
<span class="sd">        array([ -2.5+2.59807621j ,  -2.5-2.59807621j]), </span>
<span class="sd">        3.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">/=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">zpk2tf</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return polynomial transfer function representation from zeros and poles</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the polynomial representation of a transfer function H(s)</span>
<span class="sd">    using its &#39;zpk&#39; (Zero-Pole-Gain) representation.</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">            </span>
<span class="sd">        H(z) = 5 \frac</span>
<span class="sd">        { (s - 2)(s - 6) }</span>
<span class="sd">        { (s - 1)(s - 8) }</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import zpk2tf</span>
<span class="sd">    &gt;&gt;&gt; z   = [2,   6]</span>
<span class="sd">    &gt;&gt;&gt; p   = [1,   8]</span>
<span class="sd">    &gt;&gt;&gt; k   = 5</span>
<span class="sd">    &gt;&gt;&gt; zpk2tf(z, p, k)</span>
<span class="sd">    (   array([  5., -40.,  60.]), array([ 1., -9.,  8.]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">temp</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">poly</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">poly</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="c1"># Use real output if possible. Copied from numpy.poly, since</span>
    <span class="c1"># we can&#39;t depend on a specific version of numpy.</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="c1"># if complex roots are all complex conjugates, the roots are real.</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="n">pos_roots</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">roots</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roots</span><span class="p">)</span>
        <span class="n">neg_roots</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">roots</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roots</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_roots</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_roots</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">(</span><span class="n">neg_roots</span><span class="p">)</span> <span class="o">==</span>
                         <span class="n">numpy</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">(</span><span class="n">pos_roots</span><span class="p">)):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="c1"># if complex roots are all complex conjugates, the roots are real.</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="n">pos_roots</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">roots</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roots</span><span class="p">)</span>
        <span class="n">neg_roots</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">roots</span><span class="o">.</span><span class="n">imag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roots</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_roots</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_roots</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">(</span><span class="n">neg_roots</span><span class="p">)</span> <span class="o">==</span>
                         <span class="n">numpy</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">(</span><span class="n">pos_roots</span><span class="p">)):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">tf2sos</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">pairing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return second-order sections from transfer function representation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    pairing : {None, &#39;nearest&#39;, &#39;keep_odd&#39;, &#39;minimal&#39;}, optional</span>
<span class="sd">        The method to use to combine pairs of poles and zeros into sections.</span>
<span class="sd">        See `zpk2sos` for information and restrictions on `pairing` and</span>
<span class="sd">        `analog` arguments.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        If True, system is analog, otherwise discrete.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Array of second-order filter coefficients, with shape</span>
<span class="sd">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span>
<span class="sd">        specification.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zpk2sos, sosfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is generally discouraged to convert from TF to SOS format, since doing</span>
<span class="sd">    so usually will not improve numerical precision errors. Instead, consider</span>
<span class="sd">    designing filters in ZPK format and converting directly to SOS. TF is</span>
<span class="sd">    converted to SOS by first converting to ZPK format, then converting</span>
<span class="sd">    ZPK to SOS.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the &#39;sos&#39; (second-order sections) of the transfer function H(s)</span>
<span class="sd">    using its polynomial representation.</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        H(s) = \frac{s^2 - 3.5s - 2}{s^4 + 3s^3 - 15s^2 - 19s + 30}</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import tf2sos</span>
<span class="sd">    &gt;&gt;&gt; tf2sos([1, -3.5, -2], [1, 3, -15, -19, 30], analog=True)</span>
<span class="sd">    array([[  0. ,   0. ,   1. ,   1. ,   2. , -15. ],</span>
<span class="sd">           [  1. ,  -3.5,  -2. ,   1. ,   1. ,  -2. ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">zpk2sos</span><span class="p">(</span><span class="o">*</span><span class="n">tf2zpk</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">pairing</span><span class="o">=</span><span class="n">pairing</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sos2tf</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a single transfer function from a series of second-order sections</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span>
<span class="sd">        specification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the polynomial representation of an elliptic filter </span>
<span class="sd">    using its &#39;sos&#39; (second-order sections) format.</span>
<span class="sd">   </span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import sos2tf</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; sos = signal.ellip(1, 0.001, 50, 0.1, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sos2tf(sos)</span>
<span class="sd">    (   array([0.91256522, 0.91256522, 0.        ]),</span>
<span class="sd">        array([1.        , 0.82513043, 0.        ]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="n">result_type</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">result_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;bui&#39;</span><span class="p">:</span>
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_type</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_type</span><span class="p">)</span>
    <span class="n">n_sections</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">sos2zpk</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return zeros, poles, and gain of a series of second-order sections</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span>
<span class="sd">        specification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The number of zeros and poles returned will be ``n_sections * 2``</span>
<span class="sd">    even if some of these are (effectively) zero.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="n">n_sections</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sections</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sections</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
        <span class="n">zpk</span> <span class="o">=</span> <span class="n">tf2zpk</span><span class="p">(</span><span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:])</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">section</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">section</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">zpk</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">zpk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">section</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">section</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">zpk</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">zpk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">*=</span> <span class="n">zpk</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">_nearest_real_complex_idx</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the next closest real or complex element based on distance&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">which</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fro</span> <span class="o">-</span> <span class="n">to</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;any&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">fro</span><span class="p">[</span><span class="n">order</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
        <span class="k">return</span> <span class="n">order</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_single_zpksos</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create one second-order section from up to two zeros and poles&quot;&quot;&quot;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">zpk2tf</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">sos</span><span class="p">[</span><span class="mi">3</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">sos</span><span class="p">[</span><span class="mi">6</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">sos</span>


<span class="k">def</span> <span class="nf">zpk2sos</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">pairing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return second-order sections from zeros, poles, and gain of a system</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain.</span>
<span class="sd">    pairing : {None, &#39;nearest&#39;, &#39;keep_odd&#39;, &#39;minimal&#39;}, optional</span>
<span class="sd">        The method to use to combine pairs of poles and zeros into sections.</span>
<span class="sd">        If analog is False and pairing is None, pairing is set to &#39;nearest&#39;;</span>
<span class="sd">        if analog is True, pairing must be &#39;minimal&#39;, and is set to that if</span>
<span class="sd">        it is None.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        If True, system is analog, otherwise discrete.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Array of second-order filter coefficients, with shape</span>
<span class="sd">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span>
<span class="sd">        specification.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sosfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm used to convert ZPK to SOS format is designed to</span>
<span class="sd">    minimize errors due to numerical precision issues. The pairing</span>
<span class="sd">    algorithm attempts to minimize the peak gain of each biquadratic</span>
<span class="sd">    section. This is done by pairing poles with the nearest zeros, starting</span>
<span class="sd">    with the poles closest to the unit circle for discrete-time systems, and</span>
<span class="sd">    poles closest to the imaginary axis for continuous-time systems.</span>

<span class="sd">    ``pairing=&#39;minimal&#39;`` outputs may not be suitable for `sosfilt`,</span>
<span class="sd">    and ``analog=True`` outputs will never be suitable for `sosfilt`.</span>

<span class="sd">    *Algorithms*</span>

<span class="sd">    The steps in the ``pairing=&#39;nearest&#39;``, ``pairing=&#39;keep_odd&#39;``,</span>
<span class="sd">    and ``pairing=&#39;minimal&#39;`` algorithms are mostly shared. The</span>
<span class="sd">    ``&#39;nearest&#39;`` algorithm attempts to minimize the peak gain, while</span>
<span class="sd">    ``&#39;keep_odd&#39;`` minimizes peak gain under the constraint that</span>
<span class="sd">    odd-order systems should retain one section as first order.</span>
<span class="sd">    ``&#39;minimal&#39;`` is similar to ``&#39;keep_odd&#39;``, but no additional</span>
<span class="sd">    poles or zeros are introduced</span>

<span class="sd">    The algorithm steps are as follows:</span>

<span class="sd">    As a pre-processing step for ``pairing=&#39;nearest&#39;``,</span>
<span class="sd">    ``pairing=&#39;keep_odd&#39;``, add poles or zeros to the origin as</span>
<span class="sd">    necessary to obtain the same number of poles and zeros for</span>
<span class="sd">    pairing.  If ``pairing == &#39;nearest&#39;`` and there are an odd number</span>
<span class="sd">    of poles, add an additional pole and a zero at the origin.</span>

<span class="sd">    The following steps are then iterated over until no more poles or</span>
<span class="sd">    zeros remain:</span>

<span class="sd">    1. Take the (next remaining) pole (complex or real) closest to the</span>
<span class="sd">       unit circle (or imaginary axis, for ``analog=True``) to</span>
<span class="sd">       begin a new filter section.</span>

<span class="sd">    2. If the pole is real and there are no other remaining real poles [#]_,</span>
<span class="sd">       add the closest real zero to the section and leave it as a first</span>
<span class="sd">       order section. Note that after this step we are guaranteed to be</span>
<span class="sd">       left with an even number of real poles, complex poles, real zeros,</span>
<span class="sd">       and complex zeros for subsequent pairing iterations.</span>

<span class="sd">    3. Else:</span>

<span class="sd">        1. If the pole is complex and the zero is the only remaining real</span>
<span class="sd">           zero*, then pair the pole with the *next* closest zero</span>
<span class="sd">           (guaranteed to be complex). This is necessary to ensure that</span>
<span class="sd">           there will be a real zero remaining to eventually create a</span>
<span class="sd">           first-order section (thus keeping the odd order).</span>

<span class="sd">        2. Else pair the pole with the closest remaining zero (complex or</span>
<span class="sd">           real).</span>

<span class="sd">        3. Proceed to complete the second-order section by adding another</span>
<span class="sd">           pole and zero to the current pole and zero in the section:</span>

<span class="sd">            1. If the current pole and zero are both complex, add their</span>
<span class="sd">               conjugates.</span>

<span class="sd">            2. Else if the pole is complex and the zero is real, add the</span>
<span class="sd">               conjugate pole and the next closest real zero.</span>

<span class="sd">            3. Else if the pole is real and the zero is complex, add the</span>
<span class="sd">               conjugate zero and the real pole closest to those zeros.</span>

<span class="sd">            4. Else (we must have a real pole and real zero) add the next</span>
<span class="sd">               real pole closest to the unit circle, and then add the real</span>
<span class="sd">               zero closest to that pole.</span>

<span class="sd">    .. [#] This conditional can only be met for specific odd-order inputs</span>
<span class="sd">           with the ``pairing = &#39;keep_odd&#39;`` or ``&#39;minimal&#39;`` methods.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Design a 6th order low-pass elliptic digital filter for a system with a</span>
<span class="sd">    sampling rate of 8000 Hz that has a pass-band corner frequency of</span>
<span class="sd">    1000 Hz. The ripple in the pass-band should not exceed 0.087 dB, and</span>
<span class="sd">    the attenuation in the stop-band should be at least 90 dB.</span>

<span class="sd">    In the following call to `ellip`, we could use ``output=&#39;sos&#39;``,</span>
<span class="sd">    but for this example, we&#39;ll use ``output=&#39;zpk&#39;``, and then convert</span>
<span class="sd">    to SOS format with `zpk2sos`:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output=&#39;zpk&#39;)</span>

<span class="sd">    Now convert to SOS format.</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.zpk2sos(z, p, k)</span>

<span class="sd">    The coefficients of the numerators of the sections:</span>

<span class="sd">    &gt;&gt;&gt; sos[:, :3]</span>
<span class="sd">    array([[0.0014152 , 0.00248677, 0.0014152 ],</span>
<span class="sd">           [1.        , 0.72976874, 1.        ],</span>
<span class="sd">           [1.        , 0.17607852, 1.        ]])</span>

<span class="sd">    The symmetry in the coefficients occurs because all the zeros are on the</span>
<span class="sd">    unit circle.</span>

<span class="sd">    The coefficients of the denominators of the sections:</span>

<span class="sd">    &gt;&gt;&gt; sos[:, 3:]</span>
<span class="sd">    array([[ 1.        , -1.32544025,  0.46989976],</span>
<span class="sd">           [ 1.        , -1.26118294,  0.62625924],</span>
<span class="sd">           [ 1.        , -1.2570723 ,  0.8619958 ]])</span>

<span class="sd">    The next example shows the effect of the `pairing` option.  We have a</span>
<span class="sd">    system with three poles and three zeros, so the SOS array will have</span>
<span class="sd">    shape (2, 6). The means there is, in effect, an extra pole and an extra</span>
<span class="sd">    zero at the origin in the SOS representation.</span>

<span class="sd">    &gt;&gt;&gt; z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j])</span>
<span class="sd">    &gt;&gt;&gt; p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j])</span>

<span class="sd">    With ``pairing=&#39;nearest&#39;`` (the default), we obtain</span>

<span class="sd">    &gt;&gt;&gt; signal.zpk2sos(z1, p1, 1)</span>
<span class="sd">    array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ],</span>
<span class="sd">           [ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]])</span>

<span class="sd">    The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles</span>
<span class="sd">    {0, 0.75}, and the second section has the zeros {-1, 0} and poles</span>
<span class="sd">    {0.8+0.1j, 0.8-0.1j}. Note that the extra pole and zero at the origin</span>
<span class="sd">    have been assigned to different sections.</span>

<span class="sd">    With ``pairing=&#39;keep_odd&#39;``, we obtain:</span>

<span class="sd">    &gt;&gt;&gt; signal.zpk2sos(z1, p1, 1, pairing=&#39;keep_odd&#39;)</span>
<span class="sd">    array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ],</span>
<span class="sd">           [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])</span>

<span class="sd">    The extra pole and zero at the origin are in the same section.</span>
<span class="sd">    The first section is, in effect, a first-order section.</span>

<span class="sd">    With ``pairing=&#39;minimal&#39;``, the first-order section doesn&#39;t have</span>
<span class="sd">    the extra pole and zero at the origin:</span>

<span class="sd">    &gt;&gt;&gt; signal.zpk2sos(z1, p1, 1, pairing=&#39;minimal&#39;)</span>
<span class="sd">    array([[ 0.  ,  1.  ,  1.  ,  0.  ,  1.  , -0.75],</span>
<span class="sd">           [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO in the near future:</span>
    <span class="c1"># 1. Add SOS capability to `filtfilt`, `freqz`, etc. somehow (#3259).</span>
    <span class="c1"># 2. Make `decimate` use `sosfilt` instead of `lfilter`.</span>
    <span class="c1"># 3. Make sosfilt automatically simplify sections to first order</span>
    <span class="c1">#    when possible. Note this might make `sosfiltfilt` a bit harder (ICs).</span>
    <span class="c1"># 4. Further optimizations of the section ordering / pole-zero pairing.</span>
    <span class="c1"># See the wiki for other potential issues.</span>

    <span class="k">if</span> <span class="n">pairing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pairing</span> <span class="o">=</span> <span class="s1">&#39;minimal&#39;</span> <span class="k">if</span> <span class="n">analog</span> <span class="k">else</span> <span class="s1">&#39;nearest&#39;</span>

    <span class="n">valid_pairings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;keep_odd&#39;</span><span class="p">,</span> <span class="s1">&#39;minimal&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pairing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_pairings</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;pairing must be one of </span><span class="si">{</span><span class="n">valid_pairings</span><span class="si">}</span><span class="s1">, not </span><span class="si">{</span><span class="n">pairing</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">analog</span> <span class="ow">and</span> <span class="n">pairing</span> <span class="o">!=</span> <span class="s1">&#39;minimal&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;for analog zpk2sos conversion, &#39;</span>
                         <span class="s1">&#39;pairing must be &quot;minimal&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">analog</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">pairing</span> <span class="o">!=</span> <span class="s1">&#39;minimal&#39;</span><span class="p">:</span>
        <span class="c1"># ensure we have the same number of poles and zeros, and make copies</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">))))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="mi">0</span><span class="p">))))</span>
        <span class="n">n_sections</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pairing</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;for analog zpk2sos conversion, &#39;</span>
                             <span class="s1">&#39;must have len(p)&gt;=len(z)&#39;</span><span class="p">)</span>

        <span class="n">n_sections</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Ensure we have complex conjugate pairs</span>
    <span class="c1"># (note that _cplxreal only gives us one element of each complex pair):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">_cplxreal</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">_cplxreal</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be real&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">analog</span><span class="p">:</span>
        <span class="c1"># digital: &quot;worst&quot; is the closest to the unit circle</span>
        <span class="k">def</span> <span class="nf">idx_worst</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># analog: &quot;worst&quot; is the closest to the imaginary axis</span>
        <span class="k">def</span> <span class="nf">idx_worst</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>

    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_sections</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="c1"># Construct the system, reversing order so the &quot;worst&quot; are last</span>
    <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Select the next &quot;worst&quot; pole</span>
        <span class="n">p1_idx</span> <span class="o">=</span> <span class="n">idx_worst</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">p1_idx</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p1_idx</span><span class="p">)</span>

        <span class="c1"># Pair that pole with a zero</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Special case (1): last remaining real pole</span>
            <span class="k">if</span> <span class="n">pairing</span> <span class="o">!=</span> <span class="s1">&#39;minimal&#39;</span><span class="p">:</span>
                <span class="n">z1_idx</span> <span class="o">=</span> <span class="n">_nearest_real_complex_idx</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">)</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z1_idx</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z1_idx</span><span class="p">)</span>
                <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([</span><span class="n">z1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">z1_idx</span> <span class="o">=</span> <span class="n">_nearest_real_complex_idx</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">)</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z1_idx</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z1_idx</span><span class="p">)</span>
                <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([</span><span class="n">z1</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([],</span> <span class="p">[</span><span class="n">p1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
              <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
              <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
              <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># Special case (2): there&#39;s one real pole and one real zero</span>
            <span class="c1"># left, and an equal number of poles and zeros to pair up.</span>
            <span class="c1"># We *must* pair with a complex zero</span>

            <span class="n">z1_idx</span> <span class="o">=</span> <span class="n">_nearest_real_complex_idx</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z1_idx</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z1_idx</span><span class="p">)</span>
            <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([</span><span class="n">z1</span><span class="p">,</span> <span class="n">z1</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">p1</span><span class="p">):</span>
                <span class="n">prealidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="n">p2_idx</span> <span class="o">=</span> <span class="n">prealidx</span><span class="p">[</span><span class="n">idx_worst</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">prealidx</span><span class="p">])]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">p2_idx</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p2_idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

            <span class="c1"># find closest zero</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">z1_idx</span> <span class="o">=</span> <span class="n">_nearest_real_complex_idx</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">)</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z1_idx</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z1_idx</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">z1</span><span class="p">):</span>
                    <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([</span><span class="n">z1</span><span class="p">,</span> <span class="n">z1</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">z2_idx</span> <span class="o">=</span> <span class="n">_nearest_real_complex_idx</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">)</span>
                        <span class="n">z2</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z2_idx</span><span class="p">]</span>
                        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">z2</span><span class="p">)</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z2_idx</span><span class="p">)</span>
                        <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([</span><span class="n">z1</span><span class="p">],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># no more zeros</span>
                <span class="n">sos</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">_single_zpksos</span><span class="p">([],</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># we&#39;ve consumed all poles and zeros</span>
    <span class="k">del</span> <span class="n">p</span><span class="p">,</span> <span class="n">z</span>

    <span class="c1"># put gain in first sos</span>
    <span class="n">sos</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">k</span>
    <span class="k">return</span> <span class="n">sos</span>


<span class="k">def</span> <span class="nf">_align_nums</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aligns the shapes of multiple numerators.</span>

<span class="sd">    Given an array of numerator coefficient arrays [[a_1, a_2,...,</span>
<span class="sd">    a_n],..., [b_1, b_2,..., b_m]], this function pads shorter numerator</span>
<span class="sd">    arrays with zero&#39;s so that all numerators have the same length. Such</span>
<span class="sd">    alignment is necessary for functions like &#39;tf2ss&#39;, which needs the</span>
<span class="sd">    alignment when dealing with SIMO transfer functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nums: array_like</span>
<span class="sd">        Numerator or list of numerators. Not necessarily with same length.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nums: array</span>
<span class="sd">        The numerator. If `nums` input was a list of numerators then a 2-D</span>
<span class="sd">        array with padded zeros for shorter numerators is returned. Otherwise</span>
<span class="sd">        returns ``np.asarray(nums)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># The statement can throw a ValueError if one</span>
        <span class="c1"># of the numerators is a single digit and another</span>
        <span class="c1"># is array-like e.g. if nums = [5, [1, 2, 3]]</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dtype of numerator is non-numeric&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nums</span>

    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>
        <span class="n">max_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">)</span>

        <span class="c1"># pre-allocate</span>
        <span class="n">aligned_nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="n">max_width</span><span class="p">))</span>

        <span class="c1"># Create numerators with padded zeros</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">aligned_nums</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">num</span>

        <span class="k">return</span> <span class="n">aligned_nums</span>


<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalize numerator/denominator of a continuous-time transfer function.</span>

<span class="sd">    If values of `b` are too close to 0, they are removed. In that case, a</span>
<span class="sd">    BadCoefficients warning is emitted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b: array_like</span>
<span class="sd">        Numerator of the transfer function. Can be a 2-D array to normalize</span>
<span class="sd">        multiple transfer functions.</span>
<span class="sd">    a: array_like</span>
<span class="sd">        Denominator of the transfer function. At most 1-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num: array</span>
<span class="sd">        The numerator of the normalized transfer function. At least a 1-D</span>
<span class="sd">        array. A 2-D array if the input `num` is a 2-D array.</span>
<span class="sd">    den: 1-D array</span>
<span class="sd">        The denominator of the normalized transfer function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Coefficients for both the numerator and denominator should be specified in</span>
<span class="sd">    descending exponent order (e.g., ``s^2 + 3s + 5`` would be represented as</span>
<span class="sd">    ``[1, 3, 5]``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import normalize</span>

<span class="sd">    Normalize the coefficients of the transfer function</span>
<span class="sd">    ``(3*s^2 - 2*s + 5) / (2*s^2 + 3*s + 1)``:</span>

<span class="sd">    &gt;&gt;&gt; b = [3, -2, 5]</span>
<span class="sd">    &gt;&gt;&gt; a = [2, 3, 1]</span>
<span class="sd">    &gt;&gt;&gt; normalize(b, a)</span>
<span class="sd">    (array([ 1.5, -1. ,  2.5]), array([1. , 1.5, 0.5]))</span>

<span class="sd">    A warning is generated if, for example, the first coefficient of</span>
<span class="sd">    `b` is 0.  In the following example, the result is as expected:</span>

<span class="sd">    &gt;&gt;&gt; import warnings</span>
<span class="sd">    &gt;&gt;&gt; with warnings.catch_warnings(record=True) as w:</span>
<span class="sd">    ...     num, den = normalize([0, 3, 6], [2, -5, 4])</span>

<span class="sd">    &gt;&gt;&gt; num</span>
<span class="sd">    array([1.5, 3. ])</span>
<span class="sd">    &gt;&gt;&gt; den</span>
<span class="sd">    array([ 1. , -2.5,  2. ])</span>

<span class="sd">    &gt;&gt;&gt; print(w[0].message)</span>
<span class="sd">    Badly conditioned filter coefficients (numerator): the results may be meaningless</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>

    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">_align_nums</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">den</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator polynomial must be rank-1 array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numerator polynomial must be rank-1 or&quot;</span>
                         <span class="s2">&quot; rank-2 array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">den</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator must have at least on nonzero element.&quot;</span><span class="p">)</span>

    <span class="c1"># Trim leading zeros in denominator, leave at least one.</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>

    <span class="c1"># Normalize transfer function</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">den</span> <span class="o">/</span> <span class="n">den</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Count numerator columns that are all zero</span>
    <span class="n">leading_zeros</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">num</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">):</span>
            <span class="n">leading_zeros</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Trim leading zeros of numerator</span>
    <span class="k">if</span> <span class="n">leading_zeros</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Badly conditioned filter coefficients (numerator): the &quot;</span>
                      <span class="s2">&quot;results may be meaningless&quot;</span><span class="p">,</span>
                      <span class="n">BadCoefficients</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Make sure at least one column remains</span>
        <span class="k">if</span> <span class="n">leading_zeros</span> <span class="o">==</span> <span class="n">num</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">leading_zeros</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">[:,</span> <span class="n">leading_zeros</span><span class="p">:]</span>

    <span class="c1"># Squeeze first dimension if singular</span>
    <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span>


<span class="k">def</span> <span class="nf">lp2lp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a different frequency.</span>

<span class="sd">    Return an analog low-pass filter with cutoff frequency `wo`</span>
<span class="sd">    from an analog low-pass filter prototype with unity cutoff frequency, in</span>
<span class="sd">    transfer function (&#39;ba&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired cutoff, as angular frequency (e.g. rad/s).</span>
<span class="sd">        Defaults to no change.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients of the transformed low-pass filter.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients of the transformed low-pass filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2hp, lp2bp, lp2bs, bilinear</span>
<span class="sd">    lp2lp_zpk</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{s}{\omega_0}</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; lp2 = signal.lti(*signal.lp2lp(lp.num, lp.den, 2))</span>
<span class="sd">    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode()</span>
<span class="sd">    &gt;&gt;&gt; w, mag_lp2, p_lp2 = lp2.bode(w)</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_lp, label=&#39;Lowpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_lp2, label=&#39;Transformed Lowpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx()</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [rad/s]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">pwo</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">start1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">start2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">pwo</span><span class="p">[</span><span class="n">start1</span><span class="p">]</span> <span class="o">/</span> <span class="n">pwo</span><span class="p">[</span><span class="n">start2</span><span class="p">:]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">pwo</span><span class="p">[</span><span class="n">start1</span><span class="p">]</span> <span class="o">/</span> <span class="n">pwo</span><span class="p">[</span><span class="n">start1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lp2hp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a highpass filter.</span>

<span class="sd">    Return an analog high-pass filter with cutoff frequency `wo`</span>
<span class="sd">    from an analog low-pass filter prototype with unity cutoff frequency, in</span>
<span class="sd">    transfer function (&#39;ba&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired cutoff, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients of the transformed high-pass filter.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients of the transformed high-pass filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp, lp2bp, lp2bs, bilinear</span>
<span class="sd">    lp2hp_zpk</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{\omega_0}{s}</span>

<span class="sd">    This maintains symmetry of the lowpass and highpass responses on a</span>
<span class="sd">    logarithmic scale.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; hp = signal.lti(*signal.lp2hp(lp.num, lp.den))</span>
<span class="sd">    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode()</span>
<span class="sd">    &gt;&gt;&gt; w, mag_hp, p_hp = hp.bode(w)</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_lp, label=&#39;Lowpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_hp, label=&#39;Highpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx()</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [rad/s]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wo</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pwo</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">max</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">))))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pwo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">max</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)),</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">outa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pwo</span>
        <span class="n">outb</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="p">,))</span>
        <span class="n">outb</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">outb</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pwo</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outb</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pwo</span>
        <span class="n">outa</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,))</span>
        <span class="n">outa</span><span class="p">[</span><span class="n">d</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">outa</span><span class="p">[:</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pwo</span><span class="p">[:</span><span class="n">d</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">outb</span><span class="p">,</span> <span class="n">outa</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lp2bp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a bandpass filter.</span>

<span class="sd">    Return an analog band-pass filter with center frequency `wo` and</span>
<span class="sd">    bandwidth `bw` from an analog low-pass filter prototype with unity</span>
<span class="sd">    cutoff frequency, in transfer function (&#39;ba&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired passband center, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>
<span class="sd">    bw : float</span>
<span class="sd">        Desired passband width, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients of the transformed band-pass filter.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients of the transformed band-pass filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp, lp2hp, lp2bs, bilinear</span>
<span class="sd">    lp2bp_zpk</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}</span>

<span class="sd">    This is the &quot;wideband&quot; transformation, producing a passband with</span>
<span class="sd">    geometric (log frequency) symmetry about `wo`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; bp = signal.lti(*signal.lp2bp(lp.num, lp.den))</span>
<span class="sd">    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode()</span>
<span class="sd">    &gt;&gt;&gt; w, mag_bp, p_bp = bp.bode(w)</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_lp, label=&#39;Lowpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_bp, label=&#39;Bandpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx()</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [rad/s]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">artype</span> <span class="o">=</span> <span class="n">mintypecode</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">])</span>
    <span class="n">Np</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="n">ma</span>
    <span class="n">Dp</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">ma</span>
    <span class="n">bprime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">artype</span><span class="p">)</span>
    <span class="n">aprime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Dp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">artype</span><span class="p">)</span>
    <span class="n">wosq</span> <span class="o">=</span> <span class="n">wo</span> <span class="o">*</span> <span class="n">wo</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ma</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">+=</span> <span class="n">comb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">wosq</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="n">bw</span> <span class="o">**</span> <span class="n">i</span>
        <span class="n">bprime</span><span class="p">[</span><span class="n">Np</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ma</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">+=</span> <span class="n">comb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">D</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">wosq</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="n">bw</span> <span class="o">**</span> <span class="n">i</span>
        <span class="n">aprime</span><span class="p">[</span><span class="n">Dp</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">bprime</span><span class="p">,</span> <span class="n">aprime</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lp2bs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a bandstop filter.</span>

<span class="sd">    Return an analog band-stop filter with center frequency `wo` and</span>
<span class="sd">    bandwidth `bw` from an analog low-pass filter prototype with unity</span>
<span class="sd">    cutoff frequency, in transfer function (&#39;ba&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired stopband center, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>
<span class="sd">    bw : float</span>
<span class="sd">        Desired stopband width, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients of the transformed band-stop filter.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients of the transformed band-stop filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp, lp2hp, lp2bp, bilinear</span>
<span class="sd">    lp2bs_zpk</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}</span>

<span class="sd">    This is the &quot;wideband&quot; transformation, producing a stopband with</span>
<span class="sd">    geometric (log frequency) symmetry about `wo`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.5])</span>
<span class="sd">    &gt;&gt;&gt; bs = signal.lti(*signal.lp2bs(lp.num, lp.den))</span>
<span class="sd">    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode()</span>
<span class="sd">    &gt;&gt;&gt; w, mag_bs, p_bs = bs.bode(w)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_lp, label=&#39;Lowpass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w, mag_bs, label=&#39;Bandstop&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx()</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [rad/s]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">artype</span> <span class="o">=</span> <span class="n">mintypecode</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">])</span>
    <span class="n">Np</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">M</span>
    <span class="n">Dp</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">M</span>
    <span class="n">bprime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">artype</span><span class="p">)</span>
    <span class="n">aprime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Dp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">artype</span><span class="p">)</span>
    <span class="n">wosq</span> <span class="o">=</span> <span class="n">wo</span> <span class="o">*</span> <span class="n">wo</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">+=</span> <span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">wosq</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">bprime</span><span class="p">[</span><span class="n">Np</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">+=</span> <span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">D</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">wosq</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">aprime</span><span class="p">[</span><span class="n">Dp</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">bprime</span><span class="p">,</span> <span class="n">aprime</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bilinear</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a digital IIR filter from an analog one using a bilinear transform.</span>

<span class="sd">    Transform a set of poles and zeros from the analog s-plane to the digital</span>
<span class="sd">    z-plane using Tustin&#39;s method, which substitutes ``2*fs*(z-1) / (z+1)`` for</span>
<span class="sd">    ``s``, maintaining the shape of the frequency response.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator of the analog filter transfer function.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator of the analog filter transfer function.</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sample rate, as ordinary frequency (e.g., hertz). No prewarping is</span>
<span class="sd">        done in this function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator of the transformed digital filter transfer function.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator of the transformed digital filter transfer function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp, lp2hp, lp2bp, lp2bs</span>
<span class="sd">    bilinear_zpk</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; fs = 100</span>
<span class="sd">    &gt;&gt;&gt; bf = 2 * np.pi * np.array([7, 13])</span>
<span class="sd">    &gt;&gt;&gt; filts = signal.lti(*signal.butter(4, bf, btype=&#39;bandpass&#39;,</span>
<span class="sd">    ...                                   analog=True))</span>
<span class="sd">    &gt;&gt;&gt; filtz = signal.lti(*signal.bilinear(filts.num, filts.den, fs))</span>
<span class="sd">    &gt;&gt;&gt; wz, hz = signal.freqz(filtz.num, filtz.den)</span>
<span class="sd">    &gt;&gt;&gt; ws, hs = signal.freqs(filts.num, filts.den, worN=fs*wz)</span>

<span class="sd">    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hz).clip(1e-15)),</span>
<span class="sd">    ...              label=r&#39;$|H_z(e^{j \omega})|$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hs).clip(1e-15)),</span>
<span class="sd">    ...              label=r&#39;$|H(j \omega)|$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [Hz]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">artype</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">])</span>
    <span class="n">Np</span> <span class="o">=</span> <span class="n">M</span>
    <span class="n">Dp</span> <span class="o">=</span> <span class="n">M</span>
    <span class="n">bprime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">artype</span><span class="p">)</span>
    <span class="n">aprime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Dp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">artype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">+=</span> <span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span>
                                <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">bprime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">+=</span> <span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">D</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span>
                                <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">aprime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">real</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">bprime</span><span class="p">,</span> <span class="n">aprime</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">gpass</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gpass should be larger than 0.0&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">gstop</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gstop should be larger than 0.0&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">gpass</span> <span class="o">&gt;</span> <span class="n">gstop</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gpass should be smaller than gstop&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iirdesign</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;ellip&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span>
              <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complete IIR digital and analog filter design.</span>

<span class="sd">    Given passband and stopband frequencies and gains, construct an analog or</span>
<span class="sd">    digital IIR filter of minimum order for a given basic type. Return the</span>
<span class="sd">    output in numerator, denominator (&#39;ba&#39;), pole-zero (&#39;zpk&#39;) or second order</span>
<span class="sd">    sections (&#39;sos&#39;) form.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wp, ws : float or array like, shape (2,)</span>
<span class="sd">        Passband and stopband edge frequencies. Possible values are scalars</span>
<span class="sd">        (for lowpass and highpass filters) or ranges (for bandpass and bandstop</span>
<span class="sd">        filters).</span>
<span class="sd">        For digital filters, these are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. For example:</span>

<span class="sd">            - Lowpass:   wp = 0.2,          ws = 0.3</span>
<span class="sd">            - Highpass:  wp = 0.3,          ws = 0.2</span>
<span class="sd">            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</span>
<span class="sd">            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</span>

<span class="sd">        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).</span>
<span class="sd">        Note, that for bandpass and bandstop filters passband must lie strictly</span>
<span class="sd">        inside stopband or vice versa.</span>
<span class="sd">    gpass : float</span>
<span class="sd">        The maximum loss in the passband (dB).</span>
<span class="sd">    gstop : float</span>
<span class="sd">        The minimum attenuation in the stopband (dB).</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    ftype : str, optional</span>
<span class="sd">        The type of IIR filter to design:</span>

<span class="sd">            - Butterworth   : &#39;butter&#39;</span>
<span class="sd">            - Chebyshev I   : &#39;cheby1&#39;</span>
<span class="sd">            - Chebyshev II  : &#39;cheby2&#39;</span>
<span class="sd">            - Cauer/elliptic: &#39;ellip&#39;</span>

<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Filter form of the output:</span>

<span class="sd">            - second-order sections (recommended): &#39;sos&#39;</span>
<span class="sd">            - numerator/denominator (default)    : &#39;ba&#39;</span>
<span class="sd">            - pole-zero                          : &#39;zpk&#39;</span>

<span class="sd">        In general the second-order sections (&#39;sos&#39;) form  is</span>
<span class="sd">        recommended because inferring the coefficients for the</span>
<span class="sd">        numerator/denominator form (&#39;ba&#39;) suffers from numerical</span>
<span class="sd">        instabilities. For reasons of backward compatibility the default</span>
<span class="sd">        form is the numerator/denominator form (&#39;ba&#39;), where the &#39;b&#39;</span>
<span class="sd">        and the &#39;a&#39; in &#39;ba&#39; refer to the commonly used names of the</span>
<span class="sd">        coefficients used.</span>

<span class="sd">        Note: Using the second-order sections form (&#39;sos&#39;) is sometimes</span>
<span class="sd">        associated with additional computational costs: for</span>
<span class="sd">        data-intense use cases it is therefore recommended to also</span>
<span class="sd">        investigate the numerator/denominator form (&#39;ba&#39;).</span>

<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    butter : Filter design using order and critical points</span>
<span class="sd">    cheby1, cheby2, ellip, bessel</span>
<span class="sd">    buttord : Find order and critical points from passband and stopband spec</span>
<span class="sd">    cheb1ord, cheb2ord, ellipord</span>
<span class="sd">    iirfilter : General filter design using order and critical frequencies</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.ticker</span>

<span class="sd">    &gt;&gt;&gt; wp = 0.2</span>
<span class="sd">    &gt;&gt;&gt; ws = 0.3</span>
<span class="sd">    &gt;&gt;&gt; gpass = 1</span>
<span class="sd">    &gt;&gt;&gt; gstop = 40</span>

<span class="sd">    &gt;&gt;&gt; system = signal.iirdesign(wp, ws, gpass, gstop)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(*system)</span>

<span class="sd">    &gt;&gt;&gt; fig, ax1 = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;Digital filter frequency response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(w, 20 * np.log10(abs(h)), &#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_ylabel(&#39;Amplitude [dB]&#39;, color=&#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_xlabel(&#39;Frequency [rad/sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_ylim([-120, 20])</span>
<span class="sd">    &gt;&gt;&gt; ax2 = ax1.twinx()</span>
<span class="sd">    &gt;&gt;&gt; angles = np.unwrap(np.angle(h))</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(w, angles, &#39;g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_ylabel(&#39;Angle (radians)&#39;, color=&#39;g&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax2.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_ylim([-6, 1])</span>
<span class="sd">    &gt;&gt;&gt; nticks = 8</span>
<span class="sd">    &gt;&gt;&gt; ax1.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))</span>
<span class="sd">    &gt;&gt;&gt; ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ordfunc</span> <span class="o">=</span> <span class="n">filter_dict</span><span class="p">[</span><span class="n">ftype</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid IIR filter type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ftype</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not have order selection. Use &quot;</span>
                          <span class="s2">&quot;iirfilter function.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">ftype</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="n">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">)</span>

    <span class="n">wp</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">wp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">wp</span><span class="o">.</span><span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wp and ws must have one or two elements each, and&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;the same shape, got </span><span class="si">{</span><span class="n">wp</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">ws</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">ws</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values for wp, ws must be greater than 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">analog</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wp</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">ws</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values for wp, ws must be less than 1&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">wp</span> <span class="o">&gt;=</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">ws</span> <span class="o">&gt;=</span> <span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values for wp, ws must be less than fs/2&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; (fs=</span><span class="si">{</span><span class="n">fs</span><span class="si">}</span><span class="s2"> -&gt; fs/2=</span><span class="si">{</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">wp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">wp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span>
               <span class="p">(</span><span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">wp</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Passband must lie strictly inside stopband&quot;</span>
                             <span class="s2">&quot; or vice versa&quot;</span><span class="p">)</span>

    <span class="n">band_type</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">band_type</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">band_type</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">btype</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span>
             <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">}[</span><span class="n">band_type</span><span class="p">]</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">ordfunc</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="n">gpass</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span>
                     <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IIR digital and analog filter design given order and critical points.</span>

<span class="sd">    Design an Nth-order digital or analog filter and return the filter</span>
<span class="sd">    coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">    Wn : array_like</span>
<span class="sd">        A scalar or length-2 sequence giving the critical frequencies.</span>

<span class="sd">        For digital filters, `Wn` are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`Wn` is thus in</span>
<span class="sd">        half-cycles / sample.)</span>

<span class="sd">        For analog filters, `Wn` is an angular frequency (e.g., rad/s).</span>

<span class="sd">        When Wn is a length-2 sequence, ``Wn[0]`` must be less than ``Wn[1]``.</span>
<span class="sd">    rp : float, optional</span>
<span class="sd">        For Chebyshev and elliptic filters, provides the maximum ripple</span>
<span class="sd">        in the passband. (dB)</span>
<span class="sd">    rs : float, optional</span>
<span class="sd">        For Chebyshev and elliptic filters, provides the minimum attenuation</span>
<span class="sd">        in the stop band. (dB)</span>
<span class="sd">    btype : {&#39;bandpass&#39;, &#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        The type of filter.  Default is &#39;bandpass&#39;.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    ftype : str, optional</span>
<span class="sd">        The type of IIR filter to design:</span>

<span class="sd">            - Butterworth   : &#39;butter&#39;</span>
<span class="sd">            - Chebyshev I   : &#39;cheby1&#39;</span>
<span class="sd">            - Chebyshev II  : &#39;cheby2&#39;</span>
<span class="sd">            - Cauer/elliptic: &#39;ellip&#39;</span>
<span class="sd">            - Bessel/Thomson: &#39;bessel&#39;</span>

<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Filter form of the output:</span>

<span class="sd">            - second-order sections (recommended): &#39;sos&#39;</span>
<span class="sd">            - numerator/denominator (default)    : &#39;ba&#39;</span>
<span class="sd">            - pole-zero                          : &#39;zpk&#39;</span>

<span class="sd">        In general the second-order sections (&#39;sos&#39;) form  is</span>
<span class="sd">        recommended because inferring the coefficients for the</span>
<span class="sd">        numerator/denominator form (&#39;ba&#39;) suffers from numerical</span>
<span class="sd">        instabilities. For reasons of backward compatibility the default</span>
<span class="sd">        form is the numerator/denominator form (&#39;ba&#39;), where the &#39;b&#39;</span>
<span class="sd">        and the &#39;a&#39; in &#39;ba&#39; refer to the commonly used names of the</span>
<span class="sd">        coefficients used.</span>

<span class="sd">        Note: Using the second-order sections form (&#39;sos&#39;) is sometimes</span>
<span class="sd">        associated with additional computational costs: for</span>
<span class="sd">        data-intense use cases it is therefore recommended to also</span>
<span class="sd">        investigate the numerator/denominator form (&#39;ba&#39;).</span>

<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    butter : Filter design using order and critical points</span>
<span class="sd">    cheby1, cheby2, ellip, bessel</span>
<span class="sd">    buttord : Find order and critical points from passband and stopband spec</span>
<span class="sd">    cheb1ord, cheb2ord, ellipord</span>
<span class="sd">    iirdesign : General filter design using passband and stopband spec</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate a 17th-order Chebyshev II analog bandpass filter from 50 Hz to</span>
<span class="sd">    200 Hz and plot the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.iirfilter(17, [2*np.pi*50, 2*np.pi*200], rs=60,</span>
<span class="sd">    ...                         btype=&#39;band&#39;, analog=True, ftype=&#39;cheby2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a, 1000)</span>
<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax.semilogx(w / (2*np.pi), 20 * np.log10(np.maximum(abs(h), 1e-5)))</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(&#39;Chebyshev Type II bandpass frequency response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlabel(&#39;Frequency [Hz]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.axis((10, 1000, -100, 10))</span>
<span class="sd">    &gt;&gt;&gt; ax.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Create a digital filter with the same properties, in a system with</span>
<span class="sd">    sampling rate of 2000 Hz, and plot the frequency response. (Second-order</span>
<span class="sd">    sections implementation is required to ensure stability of a filter of</span>
<span class="sd">    this order):</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.iirfilter(17, [50, 200], rs=60, btype=&#39;band&#39;,</span>
<span class="sd">    ...                        analog=False, ftype=&#39;cheby2&#39;, fs=2000,</span>
<span class="sd">    ...                        output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.sosfreqz(sos, 2000, fs=2000)</span>
<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax.semilogx(w, 20 * np.log10(np.maximum(abs(h), 1e-5)))</span>
<span class="sd">    &gt;&gt;&gt; ax.set_title(&#39;Chebyshev Type II bandpass frequency response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlabel(&#39;Frequency [Hz]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.axis((10, 1000, -100, 10))</span>
<span class="sd">    &gt;&gt;&gt; ax.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ftype</span><span class="p">,</span> <span class="n">btype</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ftype</span><span class="p">,</span> <span class="n">btype</span><span class="p">,</span> <span class="n">output</span><span class="p">))</span>
    <span class="n">Wn</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Wn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">analog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fs cannot be specified for an analog filter&quot;</span><span class="p">)</span>
        <span class="n">Wn</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">Wn</span><span class="o">/</span><span class="n">fs</span>

    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Wn</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filter critical frequencies must be greater than 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Wn</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Wn</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wn[0] must be less than Wn[1]&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">btype</span> <span class="o">=</span> <span class="n">band_dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is an invalid bandtype for filter.&quot;</span> <span class="o">%</span> <span class="n">btype</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">typefunc</span> <span class="o">=</span> <span class="n">filter_dict</span><span class="p">[</span><span class="n">ftype</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid basic IIR filter.&quot;</span> <span class="o">%</span> <span class="n">ftype</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="s1">&#39;zpk&#39;</span><span class="p">,</span> <span class="s1">&#39;sos&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid output form.&quot;</span> <span class="o">%</span> <span class="n">output</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;passband ripple (rp) must be positive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stopband attenuation (rs) must be positive&quot;</span><span class="p">)</span>

    <span class="c1"># Get analog lowpass prototype</span>
    <span class="k">if</span> <span class="n">typefunc</span> <span class="o">==</span> <span class="n">buttap</span><span class="p">:</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">typefunc</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">typefunc</span> <span class="o">==</span> <span class="n">besselap</span><span class="p">:</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">typefunc</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">bessel_norms</span><span class="p">[</span><span class="n">ftype</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">typefunc</span> <span class="o">==</span> <span class="n">cheb1ap</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;passband ripple (rp) must be provided to &quot;</span>
                             <span class="s2">&quot;design a Chebyshev I filter.&quot;</span><span class="p">)</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">typefunc</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">typefunc</span> <span class="o">==</span> <span class="n">cheb2ap</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stopband attenuation (rs) must be provided to &quot;</span>
                             <span class="s2">&quot;design an Chebyshev II filter.&quot;</span><span class="p">)</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">typefunc</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">typefunc</span> <span class="o">==</span> <span class="n">ellipap</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both rp and rs must be provided to design an &quot;</span>
                             <span class="s2">&quot;elliptic filter.&quot;</span><span class="p">)</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">typefunc</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; not implemented in iirfilter.&quot;</span> <span class="o">%</span> <span class="n">ftype</span><span class="p">)</span>

    <span class="c1"># Pre-warp frequencies for digital filter design</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">analog</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Wn</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Wn</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Digital filter critical frequencies must &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;be 0 &lt; Wn &lt; fs/2 (fs=</span><span class="si">{</span><span class="n">fs</span><span class="si">}</span><span class="s2"> -&gt; fs/2=</span><span class="si">{</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Digital filter critical frequencies &quot;</span>
                             <span class="s2">&quot;must be 0 &lt; Wn &lt; 1&quot;</span><span class="p">)</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">warped</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">tan</span><span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">Wn</span> <span class="o">/</span> <span class="n">fs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warped</span> <span class="o">=</span> <span class="n">Wn</span>

    <span class="c1"># transform to lowpass, bandpass, highpass, or bandstop</span>
    <span class="k">if</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;lowpass&#39;</span><span class="p">,</span> <span class="s1">&#39;highpass&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Wn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify a single critical frequency Wn &#39;</span>
                             <span class="s1">&#39;for lowpass or highpass filter&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lp2lp_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="n">warped</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;highpass&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lp2hp_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="n">warped</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="n">warped</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">warped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wo</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">warped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">warped</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wn must specify start and stop frequencies for &#39;</span>
                             <span class="s1">&#39;bandpass or bandstop filter&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">if</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lp2bp_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="n">wo</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">:</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lp2bs_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="n">wo</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; not implemented in iirfilter.&quot;</span> <span class="o">%</span> <span class="n">btype</span><span class="p">)</span>

    <span class="c1"># Find discrete equivalent if necessary</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">analog</span><span class="p">:</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">bilinear_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>

    <span class="c1"># Transform to proper out type (pole-zero, state-space, numer-denom)</span>
    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;zpk&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>
    <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;ba&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">zpk2tf</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;sos&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">zpk2sos</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_relative_degree</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return relative degree of transfer function from zeros and poles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Improper transfer function. &quot;</span>
                         <span class="s2">&quot;Must have at least as many poles as zeros.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">degree</span>


<span class="k">def</span> <span class="nf">bilinear_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a digital IIR filter from an analog one using a bilinear transform.</span>

<span class="sd">    Transform a set of poles and zeros from the analog s-plane to the digital</span>
<span class="sd">    z-plane using Tustin&#39;s method, which substitutes ``2*fs*(z-1) / (z+1)`` for</span>
<span class="sd">    ``s``, maintaining the shape of the frequency response.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the analog filter transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the analog filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the analog filter transfer function.</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sample rate, as ordinary frequency (e.g., hertz). No prewarping is</span>
<span class="sd">        done in this function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transformed digital filter transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transformed digital filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the transformed digital filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, lp2bs_zpk</span>
<span class="sd">    bilinear</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.1.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; fs = 100</span>
<span class="sd">    &gt;&gt;&gt; bf = 2 * np.pi * np.array([7, 13])</span>
<span class="sd">    &gt;&gt;&gt; filts = signal.lti(*signal.butter(4, bf, btype=&#39;bandpass&#39;, analog=True,</span>
<span class="sd">    ...                                   output=&#39;zpk&#39;))</span>
<span class="sd">    &gt;&gt;&gt; filtz = signal.lti(*signal.bilinear_zpk(filts.zeros, filts.poles,</span>
<span class="sd">    ...                                         filts.gain, fs))</span>
<span class="sd">    &gt;&gt;&gt; wz, hz = signal.freqz_zpk(filtz.zeros, filtz.poles, filtz.gain)</span>
<span class="sd">    &gt;&gt;&gt; ws, hs = signal.freqs_zpk(filts.zeros, filts.poles, filts.gain,</span>
<span class="sd">    ...                           worN=fs*wz)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hz).clip(1e-15)),</span>
<span class="sd">    ...              label=r&#39;$|H_z(e^{j \omega})|$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hs).clip(1e-15)),</span>
<span class="sd">    ...              label=r&#39;$|H(j \omega)|$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [Hz]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">_relative_degree</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">fs2</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">fs</span>

    <span class="c1"># Bilinear transform the poles and zeros</span>
    <span class="n">z_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs2</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs2</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">p_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs2</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs2</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Any zeros that were at infinity get moved to the Nyquist frequency</span>
    <span class="n">z_z</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">z_z</span><span class="p">,</span> <span class="o">-</span><span class="n">ones</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>

    <span class="c1"># Compensate for gain change</span>
    <span class="n">k_z</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">real</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">fs2</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">prod</span><span class="p">(</span><span class="n">fs2</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">z_z</span><span class="p">,</span> <span class="n">p_z</span><span class="p">,</span> <span class="n">k_z</span>


<span class="k">def</span> <span class="nf">lp2lp_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a different frequency.</span>

<span class="sd">    Return an analog low-pass filter with cutoff frequency `wo`</span>
<span class="sd">    from an analog low-pass filter prototype with unity cutoff frequency,</span>
<span class="sd">    using zeros, poles, and gain (&#39;zpk&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the analog filter transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the analog filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the analog filter transfer function.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired cutoff, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transformed low-pass filter transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transformed low-pass filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the transformed low-pass filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2hp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear</span>
<span class="sd">    lp2lp</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{s}{\omega_0}</span>

<span class="sd">    .. versionadded:: 1.1.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use the &#39;zpk&#39; (Zero-Pole-Gain) representation of a lowpass filter to </span>
<span class="sd">    transform it to a new &#39;zpk&#39; representation associated with a cutoff frequency wo.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import lp2lp_zpk</span>
<span class="sd">    &gt;&gt;&gt; z   = [7,   2]</span>
<span class="sd">    &gt;&gt;&gt; p   = [5,   13]</span>
<span class="sd">    &gt;&gt;&gt; k   = 0.8</span>
<span class="sd">    &gt;&gt;&gt; wo  = 0.4</span>
<span class="sd">    &gt;&gt;&gt; lp2lp_zpk(z, p, k, wo)</span>
<span class="sd">    (   array([2.8, 0.8]), array([2. , 5.2]), 0.8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>  <span class="c1"># Avoid int wraparound</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">_relative_degree</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Scale all points radially from origin to shift cutoff frequency</span>
    <span class="n">z_lp</span> <span class="o">=</span> <span class="n">wo</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">p_lp</span> <span class="o">=</span> <span class="n">wo</span> <span class="o">*</span> <span class="n">p</span>

    <span class="c1"># Each shifted pole decreases gain by wo, each shifted zero increases it.</span>
    <span class="c1"># Cancel out the net change to keep overall gain the same</span>
    <span class="n">k_lp</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">wo</span><span class="o">**</span><span class="n">degree</span>

    <span class="k">return</span> <span class="n">z_lp</span><span class="p">,</span> <span class="n">p_lp</span><span class="p">,</span> <span class="n">k_lp</span>


<span class="k">def</span> <span class="nf">lp2hp_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a highpass filter.</span>

<span class="sd">    Return an analog high-pass filter with cutoff frequency `wo`</span>
<span class="sd">    from an analog low-pass filter prototype with unity cutoff frequency,</span>
<span class="sd">    using zeros, poles, and gain (&#39;zpk&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the analog filter transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the analog filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the analog filter transfer function.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired cutoff, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transformed high-pass filter transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transformed high-pass filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the transformed high-pass filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear</span>
<span class="sd">    lp2hp</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{\omega_0}{s}</span>

<span class="sd">    This maintains symmetry of the lowpass and highpass responses on a</span>
<span class="sd">    logarithmic scale.</span>

<span class="sd">    .. versionadded:: 1.1.0</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use the &#39;zpk&#39; (Zero-Pole-Gain) representation of a lowpass filter to </span>
<span class="sd">    transform it to a highpass filter with a cutoff frequency wo.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import lp2hp_zpk</span>
<span class="sd">    &gt;&gt;&gt; z   = [ -2 + 3j ,  -0.5 - 0.8j ]</span>
<span class="sd">    &gt;&gt;&gt; p   = [ -1      ,  -4          ]</span>
<span class="sd">    &gt;&gt;&gt; k   = 10</span>
<span class="sd">    &gt;&gt;&gt; wo  = 0.6</span>
<span class="sd">    &gt;&gt;&gt; lp2hp_zpk(z, p, k, wo)</span>
<span class="sd">    (   array([-0.09230769-0.13846154j, -0.33707865+0.53932584j]),</span>
<span class="sd">        array([-0.6 , -0.15]),</span>
<span class="sd">        8.5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">_relative_degree</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Invert positions radially about unit circle to convert LPF to HPF</span>
    <span class="c1"># Scale all points radially from origin to shift cutoff frequency</span>
    <span class="n">z_hp</span> <span class="o">=</span> <span class="n">wo</span> <span class="o">/</span> <span class="n">z</span>
    <span class="n">p_hp</span> <span class="o">=</span> <span class="n">wo</span> <span class="o">/</span> <span class="n">p</span>

    <span class="c1"># If lowpass had zeros at infinity, inverting moves them to origin.</span>
    <span class="n">z_hp</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">z_hp</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>

    <span class="c1"># Cancel out gain change caused by inversion</span>
    <span class="n">k_hp</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">real</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">z_hp</span><span class="p">,</span> <span class="n">p_hp</span><span class="p">,</span> <span class="n">k_hp</span>


<span class="k">def</span> <span class="nf">lp2bp_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a bandpass filter.</span>

<span class="sd">    Return an analog band-pass filter with center frequency `wo` and</span>
<span class="sd">    bandwidth `bw` from an analog low-pass filter prototype with unity</span>
<span class="sd">    cutoff frequency, using zeros, poles, and gain (&#39;zpk&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the analog filter transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the analog filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the analog filter transfer function.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired passband center, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>
<span class="sd">    bw : float</span>
<span class="sd">        Desired passband width, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transformed band-pass filter transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transformed band-pass filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the transformed band-pass filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp_zpk, lp2hp_zpk, lp2bs_zpk, bilinear</span>
<span class="sd">    lp2bp</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}</span>

<span class="sd">    This is the &quot;wideband&quot; transformation, producing a passband with</span>
<span class="sd">    geometric (log frequency) symmetry about `wo`.</span>

<span class="sd">    .. versionadded:: 1.1.0</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use the &#39;zpk&#39; (Zero-Pole-Gain) representation of a lowpass filter to </span>
<span class="sd">    transform it to a bandpass filter with a center frequency wo and</span>
<span class="sd">    bandwidth bw.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import lp2bp_zpk</span>
<span class="sd">    &gt;&gt;&gt; z   = [ 5 + 2j ,  5 - 2j ]</span>
<span class="sd">    &gt;&gt;&gt; p   = [ 7      ,  -16    ]</span>
<span class="sd">    &gt;&gt;&gt; k   = 0.8</span>
<span class="sd">    &gt;&gt;&gt; wo  = 0.62</span>
<span class="sd">    &gt;&gt;&gt; bw  = 15</span>
<span class="sd">    &gt;&gt;&gt; lp2bp_zpk(z, p, k, wo, bw)</span>
<span class="sd">    (   array([7.49955815e+01+3.00017676e+01j, 7.49955815e+01-3.00017676e+01j,</span>
<span class="sd">               4.41850748e-03-1.76761126e-03j, 4.41850748e-03+1.76761126e-03j]), </span>
<span class="sd">        array([1.04996339e+02+0.j, -1.60167736e-03+0.j,  3.66108003e-03+0.j,</span>
<span class="sd">               -2.39998398e+02+0.j]), 0.8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bw</span><span class="p">)</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">_relative_degree</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Scale poles and zeros to desired bandwidth</span>
    <span class="n">z_lp</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">bw</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">p_lp</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">bw</span><span class="o">/</span><span class="mi">2</span>

    <span class="c1"># Square root needs to produce complex result, not NaN</span>
    <span class="n">z_lp</span> <span class="o">=</span> <span class="n">z_lp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">p_lp</span> <span class="o">=</span> <span class="n">p_lp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Duplicate poles and zeros and shift from baseband to +wo and -wo</span>
    <span class="n">z_bp</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">z_lp</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">z_lp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                        <span class="n">z_lp</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">z_lp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">p_bp</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">p_lp</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">p_lp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                        <span class="n">p_lp</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">p_lp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>

    <span class="c1"># Move degree zeros to origin, leaving degree zeros at infinity for BPF</span>
    <span class="n">z_bp</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">z_bp</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>

    <span class="c1"># Cancel out gain change from frequency scaling</span>
    <span class="n">k_bp</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">bw</span><span class="o">**</span><span class="n">degree</span>

    <span class="k">return</span> <span class="n">z_bp</span><span class="p">,</span> <span class="n">p_bp</span><span class="p">,</span> <span class="n">k_bp</span>


<span class="k">def</span> <span class="nf">lp2bs_zpk</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">wo</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a lowpass filter prototype to a bandstop filter.</span>

<span class="sd">    Return an analog band-stop filter with center frequency `wo` and</span>
<span class="sd">    stopband width `bw` from an analog low-pass filter prototype with unity</span>
<span class="sd">    cutoff frequency, using zeros, poles, and gain (&#39;zpk&#39;) representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Zeros of the analog filter transfer function.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles of the analog filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the analog filter transfer function.</span>
<span class="sd">    wo : float</span>
<span class="sd">        Desired stopband center, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to no change.</span>
<span class="sd">    bw : float</span>
<span class="sd">        Desired stopband width, as angular frequency (e.g., rad/s).</span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transformed band-stop filter transfer function.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transformed band-stop filter transfer function.</span>
<span class="sd">    k : float</span>
<span class="sd">        System gain of the transformed band-stop filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, bilinear</span>
<span class="sd">    lp2bs</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is derived from the s-plane substitution</span>

<span class="sd">    .. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}</span>

<span class="sd">    This is the &quot;wideband&quot; transformation, producing a stopband with</span>
<span class="sd">    geometric (log frequency) symmetry about `wo`.</span>

<span class="sd">    .. versionadded:: 1.1.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Transform a low-pass filter represented in &#39;zpk&#39; (Zero-Pole-Gain) form </span>
<span class="sd">    into a bandstop filter represented in &#39;zpk&#39; form, with a center frequency wo and</span>
<span class="sd">    bandwidth bw.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import lp2bs_zpk</span>
<span class="sd">    &gt;&gt;&gt; z   = [             ]</span>
<span class="sd">    &gt;&gt;&gt; p   = [ 0.7 ,    -1 ]</span>
<span class="sd">    &gt;&gt;&gt; k   = 9</span>
<span class="sd">    &gt;&gt;&gt; wo  = 0.5</span>
<span class="sd">    &gt;&gt;&gt; bw  = 10</span>
<span class="sd">    &gt;&gt;&gt; lp2bs_zpk(z, p, k, wo, bw)</span>
<span class="sd">    (   array([0.+0.5j, 0.+0.5j, 0.-0.5j, 0.-0.5j]), </span>
<span class="sd">        array([14.2681928 +0.j, -0.02506281+0.j,  0.01752149+0.j, -9.97493719+0.j]), </span>
<span class="sd">        -12.857142857142858)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bw</span><span class="p">)</span>

    <span class="n">degree</span> <span class="o">=</span> <span class="n">_relative_degree</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="c1"># Invert to a highpass filter with desired bandwidth</span>
    <span class="n">z_hp</span> <span class="o">=</span> <span class="p">(</span><span class="n">bw</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">z</span>
    <span class="n">p_hp</span> <span class="o">=</span> <span class="p">(</span><span class="n">bw</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span>

    <span class="c1"># Square root needs to produce complex result, not NaN</span>
    <span class="n">z_hp</span> <span class="o">=</span> <span class="n">z_hp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">p_hp</span> <span class="o">=</span> <span class="n">p_hp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Duplicate poles and zeros and shift from baseband to +wo and -wo</span>
    <span class="n">z_bs</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">z_hp</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">z_hp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                        <span class="n">z_hp</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">z_hp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">p_bs</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">p_hp</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">p_hp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
                        <span class="n">p_hp</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">p_hp</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">wo</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>

    <span class="c1"># Move any zeros that were at infinity to the center of the stopband</span>
    <span class="n">z_bs</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">z_bs</span><span class="p">,</span> <span class="n">full</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">wo</span><span class="p">))</span>
    <span class="n">z_bs</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">z_bs</span><span class="p">,</span> <span class="n">full</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">wo</span><span class="p">))</span>

    <span class="c1"># Cancel out gain change caused by inversion</span>
    <span class="n">k_bs</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">real</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">z_bs</span><span class="p">,</span> <span class="n">p_bs</span><span class="p">,</span> <span class="n">k_bs</span>


<div class="viewcode-block" id="butter">
<a class="viewcode-back" href="../../../vtools.functions.html#vtools.functions.filter.butter">[docs]</a>
<span class="k">def</span> <span class="nf">butter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Butterworth digital and analog filter design.</span>

<span class="sd">    Design an Nth-order digital or analog Butterworth filter and return</span>
<span class="sd">    the filter coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter. For &#39;bandpass&#39; and &#39;bandstop&#39; filters,</span>
<span class="sd">        the resulting order of the final second-order sections (&#39;sos&#39;)</span>
<span class="sd">        matrix is ``2*N``, with `N` the number of biquad sections</span>
<span class="sd">        of the desired system.</span>
<span class="sd">    Wn : array_like</span>
<span class="sd">        The critical frequency or frequencies. For lowpass and highpass</span>
<span class="sd">        filters, Wn is a scalar; for bandpass and bandstop filters,</span>
<span class="sd">        Wn is a length-2 sequence.</span>

<span class="sd">        For a Butterworth filter, this is the point at which the gain</span>
<span class="sd">        drops to 1/sqrt(2) that of the passband (the &quot;-3 dB point&quot;).</span>

<span class="sd">        For digital filters, if `fs` is not specified, `Wn` units are</span>
<span class="sd">        normalized from 0 to 1, where 1 is the Nyquist frequency (`Wn` is</span>
<span class="sd">        thus in half cycles / sample and defined as 2*critical frequencies</span>
<span class="sd">        / `fs`). If `fs` is specified, `Wn` is in the same units as `fs`.</span>

<span class="sd">        For analog filters, `Wn` is an angular frequency (e.g. rad/s).</span>
<span class="sd">    btype : {&#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        The type of filter.  Default is &#39;lowpass&#39;.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Type of output:  numerator/denominator (&#39;ba&#39;), pole-zero (&#39;zpk&#39;), or</span>
<span class="sd">        second-order sections (&#39;sos&#39;). Default is &#39;ba&#39; for backwards</span>
<span class="sd">        compatibility, but &#39;sos&#39; should be used for general-purpose filtering.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    buttord, buttap</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Butterworth filter has maximally flat frequency response in the</span>
<span class="sd">    passband.</span>

<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    If the transfer function form ``[b, a]`` is requested, numerical</span>
<span class="sd">    problems can occur since the conversion between roots and</span>
<span class="sd">    the polynomial coefficients is a numerically sensitive operation,</span>
<span class="sd">    even for N &gt;= 4. It is recommended to work with the SOS</span>
<span class="sd">    representation.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Designing high-order and narrowband IIR filters in TF form can</span>
<span class="sd">        result in unstable or incorrect filtering due to floating point</span>
<span class="sd">        numerical precision issues. Consider inspecting output filter</span>
<span class="sd">        characteristics `freqz` or designing the filters with second-order</span>
<span class="sd">        sections via ``output=&#39;sos&#39;``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design an analog filter and plot its frequency response, showing the</span>
<span class="sd">    critical points:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(4, 100, &#39;low&#39;, analog=True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Butterworth filter frequency response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(100, color=&#39;green&#39;) # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second</span>
<span class="sd">    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(t, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;10 Hz and 20 Hz sinusoids&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2])</span>

<span class="sd">    Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and</span>
<span class="sd">    apply it to the signal. (It&#39;s recommended to use second-order sections</span>
<span class="sd">    format when filtering, to avoid numerical error with transfer function</span>
<span class="sd">    (``ba``) format):</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.butter(10, 15, &#39;hp&#39;, fs=1000, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(t, filtered)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_title(&#39;After 15 Hz high-pass filter&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2])</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_xlabel(&#39;Time [seconds]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span>
                     <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;butter&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">cheby1</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chebyshev type I digital and analog filter design.</span>

<span class="sd">    Design an Nth-order digital or analog Chebyshev type I filter and</span>
<span class="sd">    return the filter coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">    rp : float</span>
<span class="sd">        The maximum ripple allowed below unity gain in the passband.</span>
<span class="sd">        Specified in decibels, as a positive number.</span>
<span class="sd">    Wn : array_like</span>
<span class="sd">        A scalar or length-2 sequence giving the critical frequencies.</span>
<span class="sd">        For Type I filters, this is the point in the transition band at which</span>
<span class="sd">        the gain first drops below -`rp`.</span>

<span class="sd">        For digital filters, `Wn` are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`Wn` is thus in</span>
<span class="sd">        half-cycles / sample.)</span>

<span class="sd">        For analog filters, `Wn` is an angular frequency (e.g., rad/s).</span>
<span class="sd">    btype : {&#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        The type of filter.  Default is &#39;lowpass&#39;.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Type of output:  numerator/denominator (&#39;ba&#39;), pole-zero (&#39;zpk&#39;), or</span>
<span class="sd">        second-order sections (&#39;sos&#39;). Default is &#39;ba&#39; for backwards</span>
<span class="sd">        compatibility, but &#39;sos&#39; should be used for general-purpose filtering.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cheb1ord, cheb1ap</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Chebyshev type I filter maximizes the rate of cutoff between the</span>
<span class="sd">    frequency response&#39;s passband and stopband, at the expense of ripple in</span>
<span class="sd">    the passband and increased ringing in the step response.</span>

<span class="sd">    Type I filters roll off faster than Type II (`cheby2`), but Type II</span>
<span class="sd">    filters do not have any ripple in the passband.</span>

<span class="sd">    The equiripple passband has N maxima or minima (for example, a</span>
<span class="sd">    5th-order filter has 3 maxima and 2 minima). Consequently, the DC gain is</span>
<span class="sd">    unity for odd-order filters, or -rp dB for even-order filters.</span>

<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design an analog filter and plot its frequency response, showing the</span>
<span class="sd">    critical points:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.cheby1(4, 5, 100, &#39;low&#39;, analog=True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chebyshev Type I frequency response (rp=5)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(100, color=&#39;green&#39;) # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-5, color=&#39;green&#39;) # rp</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second</span>
<span class="sd">    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(t, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;10 Hz and 20 Hz sinusoids&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2])</span>

<span class="sd">    Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and</span>
<span class="sd">    apply it to the signal. (It&#39;s recommended to use second-order sections</span>
<span class="sd">    format when filtering, to avoid numerical error with transfer function</span>
<span class="sd">    (``ba``) format):</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.cheby1(10, 1, 15, &#39;hp&#39;, fs=1000, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(t, filtered)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_title(&#39;After 15 Hz high-pass filter&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2])</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_xlabel(&#39;Time [seconds]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="n">rp</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span>
                     <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;cheby1&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cheby2</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chebyshev type II digital and analog filter design.</span>

<span class="sd">    Design an Nth-order digital or analog Chebyshev type II filter and</span>
<span class="sd">    return the filter coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">    rs : float</span>
<span class="sd">        The minimum attenuation required in the stop band.</span>
<span class="sd">        Specified in decibels, as a positive number.</span>
<span class="sd">    Wn : array_like</span>
<span class="sd">        A scalar or length-2 sequence giving the critical frequencies.</span>
<span class="sd">        For Type II filters, this is the point in the transition band at which</span>
<span class="sd">        the gain first reaches -`rs`.</span>

<span class="sd">        For digital filters, `Wn` are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`Wn` is thus in</span>
<span class="sd">        half-cycles / sample.)</span>

<span class="sd">        For analog filters, `Wn` is an angular frequency (e.g., rad/s).</span>
<span class="sd">    btype : {&#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        The type of filter.  Default is &#39;lowpass&#39;.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Type of output:  numerator/denominator (&#39;ba&#39;), pole-zero (&#39;zpk&#39;), or</span>
<span class="sd">        second-order sections (&#39;sos&#39;). Default is &#39;ba&#39; for backwards</span>
<span class="sd">        compatibility, but &#39;sos&#39; should be used for general-purpose filtering.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cheb2ord, cheb2ap</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Chebyshev type II filter maximizes the rate of cutoff between the</span>
<span class="sd">    frequency response&#39;s passband and stopband, at the expense of ripple in</span>
<span class="sd">    the stopband and increased ringing in the step response.</span>

<span class="sd">    Type II filters do not roll off as fast as Type I (`cheby1`).</span>

<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design an analog filter and plot its frequency response, showing the</span>
<span class="sd">    critical points:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.cheby2(4, 40, 100, &#39;low&#39;, analog=True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chebyshev Type II frequency response (rs=40)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(100, color=&#39;green&#39;) # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-40, color=&#39;green&#39;) # rs</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second</span>
<span class="sd">    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(t, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;10 Hz and 20 Hz sinusoids&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2])</span>

<span class="sd">    Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and</span>
<span class="sd">    apply it to the signal. (It&#39;s recommended to use second-order sections</span>
<span class="sd">    format when filtering, to avoid numerical error with transfer function</span>
<span class="sd">    (``ba``) format):</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.cheby2(12, 20, 17, &#39;hp&#39;, fs=1000, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(t, filtered)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_title(&#39;After 17 Hz high-pass filter&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2])</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_xlabel(&#39;Time [seconds]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span>
                     <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;cheby2&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ellip</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Elliptic (Cauer) digital and analog filter design.</span>

<span class="sd">    Design an Nth-order digital or analog elliptic filter and return</span>
<span class="sd">    the filter coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">    rp : float</span>
<span class="sd">        The maximum ripple allowed below unity gain in the passband.</span>
<span class="sd">        Specified in decibels, as a positive number.</span>
<span class="sd">    rs : float</span>
<span class="sd">        The minimum attenuation required in the stop band.</span>
<span class="sd">        Specified in decibels, as a positive number.</span>
<span class="sd">    Wn : array_like</span>
<span class="sd">        A scalar or length-2 sequence giving the critical frequencies.</span>
<span class="sd">        For elliptic filters, this is the point in the transition band at</span>
<span class="sd">        which the gain first drops below -`rp`.</span>

<span class="sd">        For digital filters, `Wn` are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`Wn` is thus in</span>
<span class="sd">        half-cycles / sample.)</span>

<span class="sd">        For analog filters, `Wn` is an angular frequency (e.g., rad/s).</span>
<span class="sd">    btype : {&#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        The type of filter. Default is &#39;lowpass&#39;.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Type of output:  numerator/denominator (&#39;ba&#39;), pole-zero (&#39;zpk&#39;), or</span>
<span class="sd">        second-order sections (&#39;sos&#39;). Default is &#39;ba&#39; for backwards</span>
<span class="sd">        compatibility, but &#39;sos&#39; should be used for general-purpose filtering.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ellipord, ellipap</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Also known as Cauer or Zolotarev filters, the elliptical filter maximizes</span>
<span class="sd">    the rate of transition between the frequency response&#39;s passband and</span>
<span class="sd">    stopband, at the expense of ripple in both, and increased ringing in the</span>
<span class="sd">    step response.</span>

<span class="sd">    As `rp` approaches 0, the elliptical filter becomes a Chebyshev</span>
<span class="sd">    type II filter (`cheby2`). As `rs` approaches 0, it becomes a Chebyshev</span>
<span class="sd">    type I filter (`cheby1`). As both approach 0, it becomes a Butterworth</span>
<span class="sd">    filter (`butter`).</span>

<span class="sd">    The equiripple passband has N maxima or minima (for example, a</span>
<span class="sd">    5th-order filter has 3 maxima and 2 minima). Consequently, the DC gain is</span>
<span class="sd">    unity for odd-order filters, or -rp dB for even-order filters.</span>

<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design an analog filter and plot its frequency response, showing the</span>
<span class="sd">    critical points:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(4, 5, 40, 100, &#39;low&#39;, analog=True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Elliptic filter frequency response (rp=5, rs=40)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(100, color=&#39;green&#39;) # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-40, color=&#39;green&#39;) # rs</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-5, color=&#39;green&#39;) # rp</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second</span>
<span class="sd">    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t)</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(t, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_title(&#39;10 Hz and 20 Hz sinusoids&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2])</span>

<span class="sd">    Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and</span>
<span class="sd">    apply it to the signal. (It&#39;s recommended to use second-order sections</span>
<span class="sd">    format when filtering, to avoid numerical error with transfer function</span>
<span class="sd">    (``ba``) format):</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.ellip(8, 1, 100, 17, &#39;hp&#39;, fs=1000, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig)</span>
<span class="sd">    &gt;&gt;&gt; ax2.plot(t, filtered)</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_title(&#39;After 17 Hz high-pass filter&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2])</span>
<span class="sd">    &gt;&gt;&gt; ax2.set_xlabel(&#39;Time [seconds]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="n">rp</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span>
                     <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;elliptic&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bessel</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span>
           <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bessel/Thomson digital and analog filter design.</span>

<span class="sd">    Design an Nth-order digital or analog Bessel filter and return the</span>
<span class="sd">    filter coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">    Wn : array_like</span>
<span class="sd">        A scalar or length-2 sequence giving the critical frequencies (defined</span>
<span class="sd">        by the `norm` parameter).</span>
<span class="sd">        For analog filters, `Wn` is an angular frequency (e.g., rad/s).</span>

<span class="sd">        For digital filters, `Wn` are in the same units as `fs`.  By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`Wn` is thus in</span>
<span class="sd">        half-cycles / sample.)</span>
<span class="sd">    btype : {&#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;, &#39;bandstop&#39;}, optional</span>
<span class="sd">        The type of filter.  Default is &#39;lowpass&#39;.</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned. (See Notes.)</span>
<span class="sd">    output : {&#39;ba&#39;, &#39;zpk&#39;, &#39;sos&#39;}, optional</span>
<span class="sd">        Type of output:  numerator/denominator (&#39;ba&#39;), pole-zero (&#39;zpk&#39;), or</span>
<span class="sd">        second-order sections (&#39;sos&#39;). Default is &#39;ba&#39;.</span>
<span class="sd">    norm : {&#39;phase&#39;, &#39;delay&#39;, &#39;mag&#39;}, optional</span>
<span class="sd">        Critical frequency normalization:</span>

<span class="sd">        ``phase``</span>
<span class="sd">            The filter is normalized such that the phase response reaches its</span>
<span class="sd">            midpoint at angular (e.g. rad/s) frequency `Wn`. This happens for</span>
<span class="sd">            both low-pass and high-pass filters, so this is the</span>
<span class="sd">            &quot;phase-matched&quot; case.</span>

<span class="sd">            The magnitude response asymptotes are the same as a Butterworth</span>
<span class="sd">            filter of the same order with a cutoff of `Wn`.</span>

<span class="sd">            This is the default, and matches MATLAB&#39;s implementation.</span>

<span class="sd">        ``delay``</span>
<span class="sd">            The filter is normalized such that the group delay in the passband</span>
<span class="sd">            is 1/`Wn` (e.g., seconds). This is the &quot;natural&quot; type obtained by</span>
<span class="sd">            solving Bessel polynomials.</span>

<span class="sd">        ``mag``</span>
<span class="sd">            The filter is normalized such that the gain magnitude is -3 dB at</span>
<span class="sd">            angular frequency `Wn`.</span>

<span class="sd">        .. versionadded:: 0.18.0</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;ba&#39;``.</span>
<span class="sd">    z, p, k : ndarray, ndarray, float</span>
<span class="sd">        Zeros, poles, and system gain of the IIR filter transfer</span>
<span class="sd">        function.  Only returned if ``output=&#39;zpk&#39;``.</span>
<span class="sd">    sos : ndarray</span>
<span class="sd">        Second-order sections representation of the IIR filter.</span>
<span class="sd">        Only returned if ``output=&#39;sos&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Also known as a Thomson filter, the analog Bessel filter has maximally</span>
<span class="sd">    flat group delay and maximally linear phase response, with very little</span>
<span class="sd">    ringing in the step response. [1]_</span>

<span class="sd">    The Bessel is inherently an analog filter. This function generates digital</span>
<span class="sd">    Bessel filters using the bilinear transform, which does not preserve the</span>
<span class="sd">    phase response of the analog filter. As such, it is only approximately</span>
<span class="sd">    correct at frequencies below about fs/4. To get maximally-flat group</span>
<span class="sd">    delay at higher frequencies, the analog Bessel filter must be transformed</span>
<span class="sd">    using phase-preserving techniques.</span>

<span class="sd">    See `besselap` for implementation details and references.</span>

<span class="sd">    The ``&#39;sos&#39;`` output parameter was added in 0.16.0.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Thomson, W.E., &quot;Delay Networks having Maximally Flat Frequency</span>
<span class="sd">           Characteristics&quot;, Proceedings of the Institution of Electrical</span>
<span class="sd">           Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Plot the phase-normalized frequency response, showing the relationship</span>
<span class="sd">    to the Butterworth&#39;s cutoff frequency (green):</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(4, 100, &#39;low&#39;, analog=True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h)), color=&#39;silver&#39;, ls=&#39;dashed&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.bessel(4, 100, &#39;low&#39;, analog=True, norm=&#39;phase&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Bessel filter magnitude response (with Butterworth)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(100, color=&#39;green&#39;)  # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    and the phase midpoint:</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, np.unwrap(np.angle(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(100, color=&#39;green&#39;)  # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-np.pi, color=&#39;red&#39;)  # phase midpoint</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Bessel filter phase response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Phase [radians]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Plot the magnitude-normalized frequency response, showing the -3 dB cutoff:</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.bessel(3, 10, &#39;low&#39;, analog=True, norm=&#39;mag&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(-3, color=&#39;red&#39;)  # -3 dB magnitude</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(10, color=&#39;green&#39;)  # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Magnitude-normalized Bessel filter frequency response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Plot the delay-normalized filter, showing the maximally-flat group delay</span>
<span class="sd">    at 0.1 seconds:</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.bessel(5, 1/0.1, &#39;low&#39;, analog=True, norm=&#39;delay&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))</span>
<span class="sd">    &gt;&gt;&gt; plt.axhline(0.1, color=&#39;red&#39;)  # 0.1 seconds group delay</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Bessel filter group delay&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Group delay [seconds]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">iirfilter</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="n">btype</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span>
                     <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;bessel_&#39;</span><span class="o">+</span><span class="n">norm</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">maxflat</span><span class="p">():</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">yulewalk</span><span class="p">():</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">band_stop_obj</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Band Stop Objective Function for order minimization.</span>

<span class="sd">    Returns the non-integer order for an analog band stop filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wp : scalar</span>
<span class="sd">        Edge of passband `passb`.</span>
<span class="sd">    ind : int, {0, 1}</span>
<span class="sd">        Index specifying which `passb` edge to vary (0 or 1).</span>
<span class="sd">    passb : ndarray</span>
<span class="sd">        Two element sequence of fixed passband edges.</span>
<span class="sd">    stopb : ndarray</span>
<span class="sd">        Two element sequence of fixed stopband edges.</span>
<span class="sd">    gstop : float</span>
<span class="sd">        Amount of attenuation in stopband in dB.</span>
<span class="sd">    gpass : float</span>
<span class="sd">        Amount of ripple in the passband in dB.</span>
<span class="sd">    type : {&#39;butter&#39;, &#39;cheby&#39;, &#39;ellip&#39;}</span>
<span class="sd">        Type of filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : scalar</span>
<span class="sd">        Filter order (possibly non-integer).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">)</span>

    <span class="n">passbC</span> <span class="o">=</span> <span class="n">passb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">passbC</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">wp</span>
    <span class="n">nat</span> <span class="o">=</span> <span class="p">(</span><span class="n">stopb</span> <span class="o">*</span> <span class="p">(</span><span class="n">passbC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">passbC</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span>
           <span class="p">(</span><span class="n">stopb</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">passbC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">passbC</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">nat</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">nat</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;butter&#39;</span><span class="p">:</span>
        <span class="n">GSTOP</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gstop</span><span class="p">))</span>
        <span class="n">GPASS</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gpass</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">log10</span><span class="p">((</span><span class="n">GSTOP</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log10</span><span class="p">(</span><span class="n">nat</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;cheby&#39;</span><span class="p">:</span>
        <span class="n">GSTOP</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gstop</span><span class="p">))</span>
        <span class="n">GPASS</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gpass</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">arccosh</span><span class="p">(</span><span class="n">sqrt</span><span class="p">((</span><span class="n">GSTOP</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)))</span> <span class="o">/</span> <span class="n">arccosh</span><span class="p">(</span><span class="n">nat</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;ellip&#39;</span><span class="p">:</span>
        <span class="n">GSTOP</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">gstop</span><span class="p">)</span>
        <span class="n">GPASS</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">gpass</span><span class="p">)</span>
        <span class="n">arg1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GSTOP</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">arg0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">nat</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">([</span><span class="n">arg0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">arg0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">([</span><span class="n">arg1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">arg1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">d0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">d0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span>


<span class="k">def</span> <span class="nf">_pre_warp</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">analog</span><span class="p">):</span>
    <span class="c1"># Pre-warp frequencies for digital filter design</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">analog</span><span class="p">:</span>
        <span class="n">passb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">wp</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">stopb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ws</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">passb</span> <span class="o">=</span> <span class="n">wp</span> <span class="o">*</span> <span class="mf">1.0</span>
        <span class="n">stopb</span> <span class="o">=</span> <span class="n">ws</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span>


<span class="k">def</span> <span class="nf">_validate_wp_ws</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">analog</span><span class="p">):</span>
    <span class="n">wp</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">analog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fs cannot be specified for an analog filter&quot;</span><span class="p">)</span>
        <span class="n">wp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wp</span> <span class="o">/</span> <span class="n">fs</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ws</span> <span class="o">/</span> <span class="n">fs</span>

    <span class="n">filter_type</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">wp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">filter_type</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">filter_type</span>


<span class="k">def</span> <span class="nf">_find_nat_freq</span><span class="p">(</span><span class="n">stopb</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">filter_kind</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>            <span class="c1"># low</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">stopb</span> <span class="o">/</span> <span class="n">passb</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>          <span class="c1"># high</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">passb</span> <span class="o">/</span> <span class="n">stopb</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>          <span class="c1"># stop</span>

       <span class="c1">### breakpoint()</span>

        <span class="n">wp0</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="n">band_stop_obj</span><span class="p">,</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stopb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1e-12</span><span class="p">,</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span>
                                       <span class="n">filter_kind</span><span class="p">),</span>
                                 <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wp0</span>
        <span class="n">wp1</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="n">band_stop_obj</span><span class="p">,</span> <span class="n">stopb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span>
                                       <span class="n">filter_kind</span><span class="p">),</span>
                                 <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wp1</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="p">((</span><span class="n">stopb</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span>
               <span class="p">(</span><span class="n">stopb</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>          <span class="c1"># pass</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="p">((</span><span class="n">stopb</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span>
               <span class="p">(</span><span class="n">stopb</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;should not happen: </span><span class="si">{</span><span class="n">filter_type</span><span class="w"> </span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="n">nat</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">nat</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nat</span><span class="p">,</span> <span class="n">passb</span>


<span class="k">def</span> <span class="nf">_postprocess_wn</span><span class="p">(</span><span class="n">WN</span><span class="p">,</span> <span class="n">analog</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="n">wn</span> <span class="o">=</span> <span class="n">WN</span> <span class="k">if</span> <span class="n">analog</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">WN</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">pi</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">wn</span> <span class="o">=</span> <span class="n">wn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wn</span> <span class="o">=</span> <span class="n">wn</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">wn</span>


<span class="k">def</span> <span class="nf">buttord</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Butterworth filter order selection.</span>

<span class="sd">    Return the order of the lowest order digital or analog Butterworth filter</span>
<span class="sd">    that loses no more than `gpass` dB in the passband and has at least</span>
<span class="sd">    `gstop` dB attenuation in the stopband.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wp, ws : float</span>
<span class="sd">        Passband and stopband edge frequencies.</span>

<span class="sd">        For digital filters, these are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in</span>
<span class="sd">        half-cycles / sample.) For example:</span>

<span class="sd">            - Lowpass:   wp = 0.2,          ws = 0.3</span>
<span class="sd">            - Highpass:  wp = 0.3,          ws = 0.2</span>
<span class="sd">            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</span>
<span class="sd">            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</span>

<span class="sd">        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).</span>
<span class="sd">    gpass : float</span>
<span class="sd">        The maximum loss in the passband (dB).</span>
<span class="sd">    gstop : float</span>
<span class="sd">        The minimum attenuation in the stopband (dB).</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ord : int</span>
<span class="sd">        The lowest order for a Butterworth filter which meets specs.</span>
<span class="sd">    wn : ndarray or float</span>
<span class="sd">        The Butterworth natural frequency (i.e. the &quot;3dB frequency&quot;). Should</span>
<span class="sd">        be used with `butter` to give filter results. If `fs` is specified,</span>
<span class="sd">        this is in the same units, and `fs` must also be passed to `butter`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    butter : Filter design using order and critical points</span>
<span class="sd">    cheb1ord : Find order and critical points from passband and stopband spec</span>
<span class="sd">    cheb2ord, ellipord</span>
<span class="sd">    iirfilter : General filter design using order and critical frequencies</span>
<span class="sd">    iirdesign : General filter design using passband and stopband spec</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design an analog bandpass filter with passband within 3 dB from 20 to</span>
<span class="sd">    50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s.</span>
<span class="sd">    Plot its frequency response, showing the passband and stopband</span>
<span class="sd">    constraints in gray.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True)</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(N, Wn, &#39;band&#39;, True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a, np.logspace(1, 2, 500))</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Butterworth bandpass filter fit to constraints&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], &#39;0.9&#39;, lw=0) # stop</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], &#39;0.9&#39;, lw=0) # pass</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], &#39;0.9&#39;, lw=0) # stop</span>
<span class="sd">    &gt;&gt;&gt; plt.axis([10, 100, -60, 3])</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">)</span>
    <span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">filter_type</span> <span class="o">=</span> <span class="n">_validate_wp_ws</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span> <span class="o">=</span> <span class="n">_pre_warp</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">nat</span><span class="p">,</span> <span class="n">passb</span> <span class="o">=</span> <span class="n">_find_nat_freq</span><span class="p">(</span><span class="n">stopb</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="s1">&#39;butter&#39;</span><span class="p">)</span>

    <span class="n">GSTOP</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gstop</span><span class="p">))</span>
    <span class="n">GPASS</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gpass</span><span class="p">))</span>
    <span class="nb">ord</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log10</span><span class="p">((</span><span class="n">GSTOP</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log10</span><span class="p">(</span><span class="n">nat</span><span class="p">))))</span>

    <span class="c1"># Find the Butterworth natural frequency WN (or the &quot;3dB&quot; frequency&quot;)</span>
    <span class="c1"># to give exactly gpass at passb.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="p">(</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">ord</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Order is zero...check input parameters.&quot;</span><span class="p">,</span>
                      <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># now convert this frequency back from lowpass prototype</span>
    <span class="c1"># to the original analog filter</span>

    <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># low</span>
        <span class="n">WN</span> <span class="o">=</span> <span class="n">W0</span> <span class="o">*</span> <span class="n">passb</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># high</span>
        <span class="n">WN</span> <span class="o">=</span> <span class="n">passb</span> <span class="o">/</span> <span class="n">W0</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># stop</span>
        <span class="n">WN</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">discr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                     <span class="mi">4</span> <span class="o">*</span> <span class="n">W0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">WN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">discr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">W0</span><span class="p">)</span>
        <span class="n">WN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">discr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">W0</span><span class="p">)</span>
        <span class="n">WN</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">WN</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># pass</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">W0</span><span class="p">,</span> <span class="n">W0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">WN</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">W0</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span>
              <span class="n">sqrt</span><span class="p">(</span><span class="n">W0</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                   <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">WN</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">WN</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filter_type</span><span class="p">)</span>

    <span class="n">wn</span> <span class="o">=</span> <span class="n">_postprocess_wn</span><span class="p">(</span><span class="n">WN</span><span class="p">,</span> <span class="n">analog</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">wn</span>


<span class="k">def</span> <span class="nf">cheb1ord</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Chebyshev type I filter order selection.</span>

<span class="sd">    Return the order of the lowest order digital or analog Chebyshev Type I</span>
<span class="sd">    filter that loses no more than `gpass` dB in the passband and has at</span>
<span class="sd">    least `gstop` dB attenuation in the stopband.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wp, ws : float</span>
<span class="sd">        Passband and stopband edge frequencies.</span>

<span class="sd">        For digital filters, these are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in</span>
<span class="sd">        half-cycles / sample.)  For example:</span>

<span class="sd">            - Lowpass:   wp = 0.2,          ws = 0.3</span>
<span class="sd">            - Highpass:  wp = 0.3,          ws = 0.2</span>
<span class="sd">            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</span>
<span class="sd">            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</span>

<span class="sd">        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).</span>
<span class="sd">    gpass : float</span>
<span class="sd">        The maximum loss in the passband (dB).</span>
<span class="sd">    gstop : float</span>
<span class="sd">        The minimum attenuation in the stopband (dB).</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ord : int</span>
<span class="sd">        The lowest order for a Chebyshev type I filter that meets specs.</span>
<span class="sd">    wn : ndarray or float</span>
<span class="sd">        The Chebyshev natural frequency (the &quot;3dB frequency&quot;) for use with</span>
<span class="sd">        `cheby1` to give filter results. If `fs` is specified,</span>
<span class="sd">        this is in the same units, and `fs` must also be passed to `cheby1`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cheby1 : Filter design using order and critical points</span>
<span class="sd">    buttord : Find order and critical points from passband and stopband spec</span>
<span class="sd">    cheb2ord, ellipord</span>
<span class="sd">    iirfilter : General filter design using order and critical frequencies</span>
<span class="sd">    iirdesign : General filter design using passband and stopband spec</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design a digital lowpass filter such that the passband is within 3 dB up</span>
<span class="sd">    to 0.2*(fs/2), while rejecting at least -40 dB above 0.3*(fs/2). Plot its</span>
<span class="sd">    frequency response, showing the passband and stopband constraints in gray.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40)</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.cheby1(N, 3, Wn, &#39;low&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chebyshev I lowpass filter fit to constraints&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Normalized frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], &#39;0.9&#39;, lw=0) # stop</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], &#39;0.9&#39;, lw=0) # pass</span>
<span class="sd">    &gt;&gt;&gt; plt.axis([0.08, 1, -60, 3])</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">)</span>
    <span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">filter_type</span> <span class="o">=</span> <span class="n">_validate_wp_ws</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span> <span class="o">=</span> <span class="n">_pre_warp</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">nat</span><span class="p">,</span> <span class="n">passb</span> <span class="o">=</span> <span class="n">_find_nat_freq</span><span class="p">(</span><span class="n">stopb</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="s1">&#39;cheby&#39;</span><span class="p">)</span>

    <span class="n">GSTOP</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gstop</span><span class="p">))</span>
    <span class="n">GPASS</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gpass</span><span class="p">))</span>
    <span class="n">v_pass_stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">GSTOP</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)))</span>
    <span class="nb">ord</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">v_pass_stop</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">(</span><span class="n">nat</span><span class="p">)))</span>

    <span class="c1"># Natural frequencies are just the passband edges</span>
    <span class="n">wn</span> <span class="o">=</span> <span class="n">_postprocess_wn</span><span class="p">(</span><span class="n">passb</span><span class="p">,</span> <span class="n">analog</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">wn</span>


<span class="k">def</span> <span class="nf">cheb2ord</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Chebyshev type II filter order selection.</span>

<span class="sd">    Return the order of the lowest order digital or analog Chebyshev Type II</span>
<span class="sd">    filter that loses no more than `gpass` dB in the passband and has at least</span>
<span class="sd">    `gstop` dB attenuation in the stopband.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wp, ws : float</span>
<span class="sd">        Passband and stopband edge frequencies.</span>

<span class="sd">        For digital filters, these are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in</span>
<span class="sd">        half-cycles / sample.)  For example:</span>

<span class="sd">            - Lowpass:   wp = 0.2,          ws = 0.3</span>
<span class="sd">            - Highpass:  wp = 0.3,          ws = 0.2</span>
<span class="sd">            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</span>
<span class="sd">            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</span>

<span class="sd">        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).</span>
<span class="sd">    gpass : float</span>
<span class="sd">        The maximum loss in the passband (dB).</span>
<span class="sd">    gstop : float</span>
<span class="sd">        The minimum attenuation in the stopband (dB).</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ord : int</span>
<span class="sd">        The lowest order for a Chebyshev type II filter that meets specs.</span>
<span class="sd">    wn : ndarray or float</span>
<span class="sd">        The Chebyshev natural frequency (the &quot;3dB frequency&quot;) for use with</span>
<span class="sd">        `cheby2` to give filter results. If `fs` is specified,</span>
<span class="sd">        this is in the same units, and `fs` must also be passed to `cheby2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cheby2 : Filter design using order and critical points</span>
<span class="sd">    buttord : Find order and critical points from passband and stopband spec</span>
<span class="sd">    cheb1ord, ellipord</span>
<span class="sd">    iirfilter : General filter design using order and critical frequencies</span>
<span class="sd">    iirdesign : General filter design using passband and stopband spec</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design a digital bandstop filter which rejects -60 dB from 0.2*(fs/2) to</span>
<span class="sd">    0.5*(fs/2), while staying within 3 dB below 0.1*(fs/2) or above</span>
<span class="sd">    0.6*(fs/2). Plot its frequency response, showing the passband and</span>
<span class="sd">    stopband constraints in gray.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60)</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.cheby2(N, 60, Wn, &#39;stop&#39;)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Chebyshev II bandstop filter fit to constraints&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Normalized frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], &#39;0.9&#39;, lw=0) # stop</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], &#39;0.9&#39;, lw=0) # pass</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], &#39;0.9&#39;, lw=0) # stop</span>
<span class="sd">    &gt;&gt;&gt; plt.axis([0.06, 1, -80, 3])</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">)</span>
    <span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">filter_type</span> <span class="o">=</span> <span class="n">_validate_wp_ws</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span> <span class="o">=</span> <span class="n">_pre_warp</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">nat</span><span class="p">,</span> <span class="n">passb</span> <span class="o">=</span> <span class="n">_find_nat_freq</span><span class="p">(</span><span class="n">stopb</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="s1">&#39;cheby&#39;</span><span class="p">)</span>

    <span class="n">GSTOP</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gstop</span><span class="p">))</span>
    <span class="n">GPASS</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">gpass</span><span class="p">))</span>
    <span class="n">v_pass_stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">GSTOP</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">GPASS</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)))</span>
    <span class="nb">ord</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">v_pass_stop</span> <span class="o">/</span> <span class="n">arccosh</span><span class="p">(</span><span class="n">nat</span><span class="p">)))</span>

    <span class="c1"># Find frequency where analog response is -gpass dB.</span>
    <span class="c1"># Then convert back from low-pass prototype to the original filter.</span>

    <span class="n">new_freq</span> <span class="o">=</span> <span class="n">cosh</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">ord</span> <span class="o">*</span> <span class="n">v_pass_stop</span><span class="p">)</span>
    <span class="n">new_freq</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">new_freq</span>

    <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">passb</span> <span class="o">/</span> <span class="n">new_freq</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">passb</span> <span class="o">*</span> <span class="n">new_freq</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">nat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_freq</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                  <span class="n">sqrt</span><span class="p">(</span><span class="n">new_freq</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">+</span>
                       <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">nat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">nat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">nat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">new_freq</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                  <span class="n">sqrt</span><span class="p">((</span><span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">new_freq</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                       <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">nat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">passb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">passb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">nat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">wn</span> <span class="o">=</span> <span class="n">_postprocess_wn</span><span class="p">(</span><span class="n">nat</span><span class="p">,</span> <span class="n">analog</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">wn</span>


<span class="n">_POW10_LOG10</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pow10m1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;10 ** x - 1 for x near 0&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="n">_POW10_LOG10</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ellipord</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Elliptic (Cauer) filter order selection.</span>

<span class="sd">    Return the order of the lowest order digital or analog elliptic filter</span>
<span class="sd">    that loses no more than `gpass` dB in the passband and has at least</span>
<span class="sd">    `gstop` dB attenuation in the stopband.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wp, ws : float</span>
<span class="sd">        Passband and stopband edge frequencies.</span>

<span class="sd">        For digital filters, these are in the same units as `fs`. By default,</span>
<span class="sd">        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1,</span>
<span class="sd">        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in</span>
<span class="sd">        half-cycles / sample.) For example:</span>

<span class="sd">            - Lowpass:   wp = 0.2,          ws = 0.3</span>
<span class="sd">            - Highpass:  wp = 0.3,          ws = 0.2</span>
<span class="sd">            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</span>
<span class="sd">            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</span>

<span class="sd">        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s).</span>
<span class="sd">    gpass : float</span>
<span class="sd">        The maximum loss in the passband (dB).</span>
<span class="sd">    gstop : float</span>
<span class="sd">        The minimum attenuation in the stopband (dB).</span>
<span class="sd">    analog : bool, optional</span>
<span class="sd">        When True, return an analog filter, otherwise a digital filter is</span>
<span class="sd">        returned.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ord : int</span>
<span class="sd">        The lowest order for an Elliptic (Cauer) filter that meets specs.</span>
<span class="sd">    wn : ndarray or float</span>
<span class="sd">        The Chebyshev natural frequency (the &quot;3dB frequency&quot;) for use with</span>
<span class="sd">        `ellip` to give filter results. If `fs` is specified,</span>
<span class="sd">        this is in the same units, and `fs` must also be passed to `ellip`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ellip : Filter design using order and critical points</span>
<span class="sd">    buttord : Find order and critical points from passband and stopband spec</span>
<span class="sd">    cheb1ord, cheb2ord</span>
<span class="sd">    iirfilter : General filter design using order and critical frequencies</span>
<span class="sd">    iirdesign : General filter design using passband and stopband spec</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design an analog highpass filter such that the passband is within 3 dB</span>
<span class="sd">    above 30 rad/s, while rejecting -60 dB at 10 rad/s. Plot its</span>
<span class="sd">    frequency response, showing the passband and stopband constraints in gray.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; N, Wn = signal.ellipord(30, 10, 3, 60, True)</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(N, 3, 60, Wn, &#39;high&#39;, True)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqs(b, a, np.logspace(0, 3, 500))</span>
<span class="sd">    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Elliptical highpass filter fit to constraints&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency [radians / second]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], &#39;0.9&#39;, lw=0) # stop</span>
<span class="sd">    &gt;&gt;&gt; plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], &#39;0.9&#39;, lw=0) # pass</span>
<span class="sd">    &gt;&gt;&gt; plt.axis([1, 300, -80, 3])</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_validate_gpass_gstop</span><span class="p">(</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">)</span>
    <span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">filter_type</span> <span class="o">=</span> <span class="n">_validate_wp_ws</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">passb</span><span class="p">,</span> <span class="n">stopb</span> <span class="o">=</span> <span class="n">_pre_warp</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">analog</span><span class="p">)</span>
    <span class="n">nat</span><span class="p">,</span> <span class="n">passb</span> <span class="o">=</span> <span class="n">_find_nat_freq</span><span class="p">(</span><span class="n">stopb</span><span class="p">,</span> <span class="n">passb</span><span class="p">,</span> <span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="s1">&#39;ellip&#39;</span><span class="p">)</span>

    <span class="n">arg1_sq</span> <span class="o">=</span> <span class="n">_pow10m1</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">gpass</span><span class="p">)</span> <span class="o">/</span> <span class="n">_pow10m1</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">gstop</span><span class="p">)</span>
    <span class="n">arg0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">nat</span>
    <span class="n">d0</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">(</span><span class="n">arg0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipkm1</span><span class="p">(</span><span class="n">arg0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">(</span><span class="n">arg1_sq</span><span class="p">),</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipkm1</span><span class="p">(</span><span class="n">arg1_sq</span><span class="p">)</span>
    <span class="nb">ord</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">d0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">d0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d1</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

    <span class="n">wn</span> <span class="o">=</span> <span class="n">_postprocess_wn</span><span class="p">(</span><span class="n">passb</span><span class="p">,</span> <span class="n">analog</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">wn</span>


<span class="k">def</span> <span class="nf">buttap</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return (z,p,k) for analog prototype of Nth-order Butterworth filter.</span>

<span class="sd">    The filter will have an angular (e.g., rad/s) cutoff frequency of 1.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    butter : Filter design function using this prototype</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filter order must be a nonnegative integer&quot;</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Middle value is 0 to ensure an exactly real pole</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">m</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">cheb1ap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</span>

<span class="sd">    The returned filter prototype has `rp` decibels of ripple in the passband.</span>

<span class="sd">    The filter&#39;s angular (e.g. rad/s) cutoff frequency is normalized to 1,</span>
<span class="sd">    defined as the point at which the gain first drops below ``-rp``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cheby1 : Filter design function using this prototype</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filter order must be a nonnegative integer&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Avoid divide-by-zero error</span>
        <span class="c1"># Even order filters have DC gain of -rp dB</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">rp</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># Ripple factor (epsilon)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">rp</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">arcsinh</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">eps</span><span class="p">)</span>

    <span class="c1"># Arrange poles in an ellipse on the left half of the S-plane</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">m</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">sinh</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">eps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">cheb2ap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter.</span>

<span class="sd">    The returned filter prototype has attenuation of at least ``rs`` decibels</span>
<span class="sd">    in the stopband.</span>

<span class="sd">    The filter&#39;s angular (e.g. rad/s) cutoff frequency is normalized to 1,</span>
<span class="sd">    defined as the point at which the attenuation first reaches ``rs``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cheby2 : Filter design function using this prototype</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filter order must be a nonnegative integer&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Avoid divide-by-zero warning</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="mi">1</span>

    <span class="c1"># Ripple factor (epsilon)</span>
    <span class="n">de</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">rs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">arcsinh</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">de</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">conjugate</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">N</span><span class="p">)))</span>

    <span class="c1"># Poles around the unit circle like Butterworth</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">))</span>
    <span class="c1"># Warp into Chebyshev II</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">sinh</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">cosh</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">p</span>

    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="n">EPSILON</span> <span class="o">=</span> <span class="mf">2e-16</span>

<span class="c1"># number of terms in solving degree equation</span>
<span class="n">_ELLIPDEG_MMAX</span> <span class="o">=</span> <span class="mi">7</span>


<span class="k">def</span> <span class="nf">_ellipdeg</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve degree equation using nomes</span>

<span class="sd">    Given n, m1, solve</span>
<span class="sd">       n * K(m) / K&#39;(m) = K1(m1) / K1&#39;(m1)</span>
<span class="sd">    for m</span>

<span class="sd">    See [1], Eq. (49)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Orfanidis, &quot;Lecture Notes on Elliptic Filter Design&quot;,</span>
<span class="sd">           https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K1</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
    <span class="n">K1p</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipkm1</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

    <span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">K1p</span> <span class="o">/</span> <span class="n">K1</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q1</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>

    <span class="n">mnum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">_ELLIPDEG_MMAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_ELLIPDEG_MMAX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span> <span class="o">**</span> <span class="p">(</span><span class="n">mnum</span> <span class="o">*</span> <span class="p">(</span><span class="n">mnum</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span> <span class="o">**</span> <span class="p">(</span><span class="n">mden</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span>


<span class="c1"># Maximum number of iterations in Landen transformation recursion</span>
<span class="c1"># sequence.  10 is conservative; unit tests pass with 4, Orfanidis</span>
<span class="c1"># (see _arc_jac_cn [1]) suggests 5.</span>
<span class="n">_ARC_JAC_SN_MAXITER</span> <span class="o">=</span> <span class="mi">10</span>


<span class="k">def</span> <span class="nf">_arc_jac_sn</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inverse Jacobian elliptic sn</span>

<span class="sd">    Solve for z in w = sn(z, m)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    w : complex scalar</span>
<span class="sd">        argument</span>

<span class="sd">    m : scalar</span>
<span class="sd">        modulus; in interval [0, 1]</span>


<span class="sd">    See [1], Eq. (56)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Orfanidis, &quot;Lecture Notes on Elliptic Filter Design&quot;,</span>
<span class="sd">           https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_complement</span><span class="p">(</span><span class="n">kx</span><span class="p">):</span>
        <span class="c1"># (1-k**2) ** 0.5; the expression below</span>
        <span class="c1"># works for small kx</span>
        <span class="k">return</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">kx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">kx</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">m</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

    <span class="n">ks</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">ks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">k_</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">k_p</span> <span class="o">=</span> <span class="n">_complement</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span>
        <span class="n">ks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k_p</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k_p</span><span class="p">))</span>
        <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">niter</span> <span class="o">&gt;</span> <span class="n">_ARC_JAC_SN_MAXITER</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Landen transformation not converging&#39;</span><span class="p">)</span>

    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">wns</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">kn</span><span class="p">,</span> <span class="n">knext</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ks</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">wn</span> <span class="o">=</span> <span class="n">wns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">wnext</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wn</span> <span class="o">/</span>
                 <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">knext</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">_complement</span><span class="p">(</span><span class="n">kn</span> <span class="o">*</span> <span class="n">wn</span><span class="p">))))</span>
        <span class="n">wns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wnext</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">wns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">K</span> <span class="o">*</span> <span class="n">u</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span> <span class="nf">_arc_jac_sc1</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Real inverse Jacobian sc, with complementary modulus</span>

<span class="sd">    Solve for z in w = sc(z, 1-m)</span>

<span class="sd">    w - real scalar</span>

<span class="sd">    m - modulus</span>

<span class="sd">    From [1], sc(z, m) = -i * sn(i * z, 1 - m)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    # noqa: E501</span>
<span class="sd">    .. [1] https://functions.wolfram.com/EllipticFunctions/JacobiSC/introductions/JacobiPQs/ShowAll.html,</span>
<span class="sd">       &quot;Representations through other Jacobi functions&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">zcomplex</span> <span class="o">=</span> <span class="n">_arc_jac_sn</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zcomplex</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-14</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">return</span> <span class="n">zcomplex</span><span class="o">.</span><span class="n">imag</span>


<span class="k">def</span> <span class="nf">ellipap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">rs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return (z,p,k) of Nth-order elliptic analog lowpass filter.</span>

<span class="sd">    The filter is a normalized prototype that has `rp` decibels of ripple</span>
<span class="sd">    in the passband and a stopband `rs` decibels down.</span>

<span class="sd">    The filter&#39;s angular (e.g., rad/s) cutoff frequency is normalized to 1,</span>
<span class="sd">    defined as the point at which the gain first drops below ``-rp``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ellip : Filter design function using this prototype</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lutova, Tosic, and Evans, &quot;Filter Design for Signal Processing&quot;,</span>
<span class="sd">           Chapters 5 and 12.</span>

<span class="sd">    .. [2] Orfanidis, &quot;Lecture Notes on Elliptic Filter Design&quot;,</span>
<span class="sd">           https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filter order must be a nonnegative integer&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Avoid divide-by-zero warning</span>
        <span class="c1"># Even order filters have DC gain of -rp dB</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">rp</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">_pow10m1</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">rp</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">k</span>

    <span class="n">eps_sq</span> <span class="o">=</span> <span class="n">_pow10m1</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">rp</span><span class="p">)</span>

    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eps_sq</span><span class="p">)</span>
    <span class="n">ck1_sq</span> <span class="o">=</span> <span class="n">eps_sq</span> <span class="o">/</span> <span class="n">_pow10m1</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">rs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ck1_sq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot design a filter with given rp and rs&quot;</span>
                         <span class="s2">&quot; specifications.&quot;</span><span class="p">)</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">(</span><span class="n">ck1_sq</span><span class="p">),</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipkm1</span><span class="p">(</span><span class="n">ck1_sq</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">_ellipdeg</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">ck1_sq</span><span class="p">)</span>

    <span class="n">capk</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipk</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">jj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">phi</span><span class="p">]</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipj</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">capk</span> <span class="o">/</span> <span class="n">N</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">jj</span><span class="p">))</span>
    <span class="n">snew</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EPSILON</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">snew</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">_arc_jac_sc1</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">eps</span><span class="p">,</span> <span class="n">ck1_sq</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">capk</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="n">cv</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">phi</span><span class="p">]</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">ellipj</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">sv</span> <span class="o">*</span> <span class="n">cv</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">dv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">sv</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">newp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EPSILON</span> <span class="o">*</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
                                                   <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
                              <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">newp</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>

    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eps_sq</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="c1"># TODO: Make this a real public function scipy.misc.ff</span>
<span class="k">def</span> <span class="nf">_falling_factorial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the factorial of `x` to the `n` falling.</span>

<span class="sd">    This is defined as:</span>

<span class="sd">    .. math::   x^\underline n = (x)_n = x (x-1) \cdots (x-n+1)</span>

<span class="sd">    This can more efficiently calculate ratios of factorials, since:</span>

<span class="sd">    n!/m! == falling_factorial(n, n-m)</span>

<span class="sd">    where n &gt;= m</span>

<span class="sd">    skipping the factors that cancel out</span>

<span class="sd">    the usual factorial n! == ff(n, n)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">*=</span> <span class="n">k</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_bessel_poly</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the coefficients of Bessel polynomial of degree `n`</span>

<span class="sd">    If `reverse` is true, a reverse Bessel polynomial is output.</span>

<span class="sd">    Output is a list of coefficients:</span>
<span class="sd">    [1]                   = 1</span>
<span class="sd">    [1,  1]               = 1*s   +  1</span>
<span class="sd">    [1,  3,  3]           = 1*s^2 +  3*s   +  3</span>
<span class="sd">    [1,  6, 15, 15]       = 1*s^3 +  6*s^2 + 15*s   +  15</span>
<span class="sd">    [1, 10, 45, 105, 105] = 1*s^4 + 10*s^3 + 45*s^2 + 105*s + 105</span>
<span class="sd">    etc.</span>

<span class="sd">    Output is a Python list of arbitrary precision long ints, so n is only</span>
<span class="sd">    limited by your hardware&#39;s memory.</span>

<span class="sd">    Sequence is http://oeis.org/A001498, and output can be confirmed to</span>
<span class="sd">    match http://oeis.org/A001498/b001498.txt :</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal._filter_design import _bessel_poly</span>
<span class="sd">    &gt;&gt;&gt; i = 0</span>
<span class="sd">    &gt;&gt;&gt; for n in range(51):</span>
<span class="sd">    ...     for x in _bessel_poly(n, reverse=True):</span>
<span class="sd">    ...         print(i, x)</span>
<span class="sd">    ...         i += 1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polynomial order must be a nonnegative integer&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># np.int32 doesn&#39;t work, for instance</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">_falling_factorial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span> <span class="o">//</span> <span class="n">den</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_campos_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return approximate zero locations of Bessel polynomials y_n(x) for order</span>
<span class="sd">    `n` using polynomial fit (Campos-Calderon 2011)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">])</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">b3</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">])</span> <span class="o">/</span> <span class="n">s</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">24</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span> <span class="o">/</span> <span class="n">s</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">s</span>
    <span class="n">b0</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">s</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">])</span> <span class="o">/</span> <span class="n">r</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="n">r</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">npp_polyval</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">y</span>


<span class="k">def</span> <span class="nf">_aberth</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a function `f`, its first derivative `fp`, and a set of initial</span>
<span class="sd">    guesses `x0`, simultaneously find the roots of the polynomial using the</span>
<span class="sd">    Aberth-Ehrlich method.</span>

<span class="sd">    ``len(x0)`` should equal the number of roots of `f`.</span>

<span class="sd">    (This is not a complete implementation of Bini&#39;s algorithm.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">fp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Newton&#39;s method</span>

        <span class="c1"># Model &quot;repulsion&quot; between zeros</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">beta</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">beta</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="n">k</span><span class="p">]))</span>

        <span class="n">x</span> <span class="o">+=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Root-finding calculation failed&#39;</span><span class="p">)</span>

        <span class="c1"># Mekwi: The iterative process can be stopped when |hn| has become</span>
        <span class="c1"># less than the largest error one is willing to permit in the root.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Zeros failed to converge&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_bessel_zeros</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find zeros of ordinary Bessel polynomial of order `N`, by root-finding of</span>
<span class="sd">    modified Bessel function of the second kind</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">([])</span>

    <span class="c1"># Generate starting points</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">_campos_zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Zeros are the same for exp(1/x)*K_{N+0.5}(1/x) and Nth-order ordinary</span>
    <span class="c1"># Bessel polynomial y_N(x)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">special</span><span class="o">.</span><span class="n">kve</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># First derivative of above</span>
    <span class="k">def</span> <span class="nf">fp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">kve</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span>
                <span class="n">special</span><span class="o">.</span><span class="n">kve</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">special</span><span class="o">.</span><span class="n">kve</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Starting points converge to true zeros</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_aberth</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

    <span class="c1"># Improve precision using Newton&#39;s method on each</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">)</span>

    <span class="c1"># Average complex conjugates to make them exactly symmetrical</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Zeros should sum to -1</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Generated zeros are inaccurate&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_norm_factor</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numerically find frequency shift to apply to delay-normalized filter such</span>
<span class="sd">    that -3 dB point is at 1 rad/sec.</span>

<span class="sd">    `p` is an array_like of polynomial poles</span>
<span class="sd">    `k` is a float gain</span>

<span class="sd">    First 10 values are listed in &quot;Bessel Scale Factors&quot; table,</span>
<span class="sd">    &quot;Bessel Filters Polynomials, Poles and Circuit Elements 2003, C. Bond.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">G</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gain of filter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">cutoff</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When gain = -3 dB, return 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">optimize</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">besselap</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return (z,p,k) for analog prototype of an Nth-order Bessel filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        The order of the filter.</span>
<span class="sd">    norm : {&#39;phase&#39;, &#39;delay&#39;, &#39;mag&#39;}, optional</span>
<span class="sd">        Frequency normalization:</span>

<span class="sd">        ``phase``</span>
<span class="sd">            The filter is normalized such that the phase response reaches its</span>
<span class="sd">            midpoint at an angular (e.g., rad/s) cutoff frequency of 1. This</span>
<span class="sd">            happens for both low-pass and high-pass filters, so this is the</span>
<span class="sd">            &quot;phase-matched&quot; case. [6]_</span>

<span class="sd">            The magnitude response asymptotes are the same as a Butterworth</span>
<span class="sd">            filter of the same order with a cutoff of `Wn`.</span>

<span class="sd">            This is the default, and matches MATLAB&#39;s implementation.</span>

<span class="sd">        ``delay``</span>
<span class="sd">            The filter is normalized such that the group delay in the passband</span>
<span class="sd">            is 1 (e.g., 1 second). This is the &quot;natural&quot; type obtained by</span>
<span class="sd">            solving Bessel polynomials</span>

<span class="sd">        ``mag``</span>
<span class="sd">            The filter is normalized such that the gain magnitude is -3 dB at</span>
<span class="sd">            angular frequency 1. This is called &quot;frequency normalization&quot; by</span>
<span class="sd">            Bond. [1]_</span>

<span class="sd">        .. versionadded:: 0.18.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Zeros of the transfer function. Is always an empty array.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles of the transfer function.</span>
<span class="sd">    k : scalar</span>
<span class="sd">        Gain of the transfer function. For phase-normalized, this is always 1.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bessel : Filter design function using this prototype</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To find the pole locations, approximate starting points are generated [2]_</span>
<span class="sd">    for the zeros of the ordinary Bessel polynomial [3]_, then the</span>
<span class="sd">    Aberth-Ehrlich method [4]_ [5]_ is used on the Kv(x) Bessel function to</span>
<span class="sd">    calculate more accurate zeros, and these locations are then inverted about</span>
<span class="sd">    the unit circle.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] C.R. Bond, &quot;Bessel Filter Constants&quot;,</span>
<span class="sd">           http://www.crbond.com/papers/bsf.pdf</span>
<span class="sd">    .. [2] Campos and Calderon, &quot;Approximate closed-form formulas for the</span>
<span class="sd">           zeros of the Bessel Polynomials&quot;, :arXiv:`1105.0957`.</span>
<span class="sd">    .. [3] Thomson, W.E., &quot;Delay Networks having Maximally Flat Frequency</span>
<span class="sd">           Characteristics&quot;, Proceedings of the Institution of Electrical</span>
<span class="sd">           Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.</span>
<span class="sd">    .. [4] Aberth, &quot;Iteration Methods for Finding all Zeros of a Polynomial</span>
<span class="sd">           Simultaneously&quot;, Mathematics of Computation, Vol. 27, No. 122,</span>
<span class="sd">           April 1973</span>
<span class="sd">    .. [5] Ehrlich, &quot;A modified Newton method for polynomials&quot;, Communications</span>
<span class="sd">           of the ACM, Vol. 10, Issue 2, pp. 107-108, Feb. 1967,</span>
<span class="sd">           :DOI:`10.1145/363067.363115`</span>
<span class="sd">    .. [6] Miller and Bohn, &quot;A Bessel Filter Crossover, and Its Relation to</span>
<span class="sd">           Others&quot;, RaneNote 147, 1998,</span>
<span class="sd">           https://www.ranecommercial.com/legacy/note147.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filter order must be a nonnegative integer&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># calculation below doesn&#39;t always fit in np.int64</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Find roots of reverse Bessel polynomial</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">_bessel_zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="n">a_last</span> <span class="o">=</span> <span class="n">_falling_factorial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="o">**</span><span class="n">N</span>

        <span class="c1"># Shift them to a different normalization if required</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;delay&#39;</span><span class="p">,</span> <span class="s1">&#39;mag&#39;</span><span class="p">):</span>
            <span class="c1"># Normalized for group delay of 1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">a_last</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
                <span class="c1"># -3 dB magnitude point is at 1 rad/sec</span>
                <span class="n">norm_factor</span> <span class="o">=</span> <span class="n">_norm_factor</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">/=</span> <span class="n">norm_factor</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">norm_factor</span><span class="o">**-</span><span class="n">N</span> <span class="o">*</span> <span class="n">a_last</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
            <span class="c1"># Phase-matched (1/2 max phase shift at 1 rad/sec)</span>
            <span class="c1"># Asymptotes are same as Butterworth filter</span>
            <span class="n">p</span> <span class="o">*=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">a_last</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;normalization not understood&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">asarray</span><span class="p">([]),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iirnotch</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Design second-order IIR notch digital filter.</span>

<span class="sd">    A notch filter is a band-stop filter with a narrow bandwidth</span>
<span class="sd">    (high quality factor). It rejects a narrow frequency band and</span>
<span class="sd">    leaves the rest of the spectrum little changed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    w0 : float</span>
<span class="sd">        Frequency to remove from a signal. If `fs` is specified, this is in</span>
<span class="sd">        the same units as `fs`. By default, it is a normalized scalar that must</span>
<span class="sd">        satisfy  ``0 &lt; w0 &lt; 1``, with ``w0 = 1`` corresponding to half of the</span>
<span class="sd">        sampling frequency.</span>
<span class="sd">    Q : float</span>
<span class="sd">        Quality factor. Dimensionless parameter that characterizes</span>
<span class="sd">        notch filter -3 dB bandwidth ``bw`` relative to its center</span>
<span class="sd">        frequency, ``Q = w0/bw``.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (``b``) and denominator (``a``) polynomials</span>
<span class="sd">        of the IIR filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    iirpeak</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sophocles J. Orfanidis, &quot;Introduction To Signal Processing&quot;,</span>
<span class="sd">           Prentice-Hall, 1996</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design and plot filter to remove the 60 Hz component from a</span>
<span class="sd">    signal sampled at 200 Hz, using a quality factor Q = 30</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; fs = 200.0  # Sample frequency (Hz)</span>
<span class="sd">    &gt;&gt;&gt; f0 = 60.0  # Frequency to be removed from signal (Hz)</span>
<span class="sd">    &gt;&gt;&gt; Q = 30.0  # Quality factor</span>
<span class="sd">    &gt;&gt;&gt; # Design notch filter</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.iirnotch(f0, Q, fs)</span>

<span class="sd">    &gt;&gt;&gt; # Frequency response</span>
<span class="sd">    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs)</span>
<span class="sd">    &gt;&gt;&gt; # Plot</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6))</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(abs(h)), color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_xlim([0, 100])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylim([-25, 10])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(freq, np.unwrap(np.angle(h))*180/np.pi, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlim([0, 100])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylim([-90, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_design_notch_peak_filter</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;notch&quot;</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iirpeak</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Design second-order IIR peak (resonant) digital filter.</span>

<span class="sd">    A peak filter is a band-pass filter with a narrow bandwidth</span>
<span class="sd">    (high quality factor). It rejects components outside a narrow</span>
<span class="sd">    frequency band.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    w0 : float</span>
<span class="sd">        Frequency to be retained in a signal. If `fs` is specified, this is in</span>
<span class="sd">        the same units as `fs`. By default, it is a normalized scalar that must</span>
<span class="sd">        satisfy  ``0 &lt; w0 &lt; 1``, with ``w0 = 1`` corresponding to half of the</span>
<span class="sd">        sampling frequency.</span>
<span class="sd">    Q : float</span>
<span class="sd">        Quality factor. Dimensionless parameter that characterizes</span>
<span class="sd">        peak filter -3 dB bandwidth ``bw`` relative to its center</span>
<span class="sd">        frequency, ``Q = w0/bw``.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (``b``) and denominator (``a``) polynomials</span>
<span class="sd">        of the IIR filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    iirnotch</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sophocles J. Orfanidis, &quot;Introduction To Signal Processing&quot;,</span>
<span class="sd">           Prentice-Hall, 1996</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design and plot filter to remove the frequencies other than the 300 Hz</span>
<span class="sd">    component from a signal sampled at 1000 Hz, using a quality factor Q = 30</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; fs = 1000.0  # Sample frequency (Hz)</span>
<span class="sd">    &gt;&gt;&gt; f0 = 300.0  # Frequency to be retained (Hz)</span>
<span class="sd">    &gt;&gt;&gt; Q = 30.0  # Quality factor</span>
<span class="sd">    &gt;&gt;&gt; # Design peak filter</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.iirpeak(f0, Q, fs)</span>

<span class="sd">    &gt;&gt;&gt; # Frequency response</span>
<span class="sd">    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs)</span>
<span class="sd">    &gt;&gt;&gt; # Plot</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6))</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(np.maximum(abs(h), 1e-5)), color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_xlim([0, 500])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylim([-50, 10])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(freq, np.unwrap(np.angle(h))*180/np.pi, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlim([0, 500])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylim([-90, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_design_notch_peak_filter</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;peak&quot;</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_design_notch_peak_filter</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">ftype</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Design notch or peak digital filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    w0 : float</span>
<span class="sd">        Normalized frequency to remove from a signal. If `fs` is specified,</span>
<span class="sd">        this is in the same units as `fs`. By default, it is a normalized</span>
<span class="sd">        scalar that must satisfy  ``0 &lt; w0 &lt; 1``, with ``w0 = 1``</span>
<span class="sd">        corresponding to half of the sampling frequency.</span>
<span class="sd">    Q : float</span>
<span class="sd">        Quality factor. Dimensionless parameter that characterizes</span>
<span class="sd">        notch filter -3 dB bandwidth ``bw`` relative to its center</span>
<span class="sd">        frequency, ``Q = w0/bw``.</span>
<span class="sd">    ftype : str</span>
<span class="sd">        The type of IIR filter to design:</span>

<span class="sd">            - notch filter : ``notch``</span>
<span class="sd">            - peak filter  : ``peak``</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the digital system.</span>

<span class="sd">        .. versionadded:: 1.2.0:</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (``b``) and denominator (``a``) polynomials</span>
<span class="sd">        of the IIR filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Guarantee that the inputs are floats</span>
    <span class="n">w0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">w0</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">w0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">w0</span><span class="o">/</span><span class="n">fs</span>

    <span class="c1"># Checks if w0 is within the range</span>
    <span class="k">if</span> <span class="n">w0</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">w0</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;w0 should be such that 0 &lt; w0 &lt; 1&quot;</span><span class="p">)</span>

    <span class="c1"># Get bandwidth</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="n">w0</span><span class="o">/</span><span class="n">Q</span>

    <span class="c1"># Normalize inputs</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="n">bw</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">w0</span> <span class="o">=</span> <span class="n">w0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># Compute -3dB attenuation</span>
    <span class="n">gb</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s2">&quot;notch&quot;</span><span class="p">:</span>
        <span class="c1"># Compute beta: formula 11.3.4 (p.575) from reference [1]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">gb</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="n">gb</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">bw</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span>
        <span class="c1"># Compute beta: formula 11.3.19 (p.579) from reference [1]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="n">gb</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">gb</span><span class="o">**</span><span class="mf">2.0</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">bw</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown ftype.&quot;</span><span class="p">)</span>

    <span class="c1"># Compute gain: formula 11.3.6 (p.575) from reference [1]</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">beta</span><span class="p">)</span>

    <span class="c1"># Compute numerator b and denominator a</span>
    <span class="c1"># formulas 11.3.7 (p.575) and 11.3.21 (p.579)</span>
    <span class="c1"># from reference [1]</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s2">&quot;notch&quot;</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">gain</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">gain</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">gain</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">gain</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">iircomb</span><span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;notch&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Design IIR notching or peaking digital comb filter.</span>

<span class="sd">    A notching comb filter consists of regularly-spaced band-stop filters with</span>
<span class="sd">    a narrow bandwidth (high quality factor). Each rejects a narrow frequency</span>
<span class="sd">    band and leaves the rest of the spectrum little changed.</span>

<span class="sd">    A peaking comb filter consists of regularly-spaced band-pass filters with</span>
<span class="sd">    a narrow bandwidth (high quality factor). Each rejects components outside</span>
<span class="sd">    a narrow frequency band.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    w0 : float</span>
<span class="sd">        The fundamental frequency of the comb filter (the spacing between its</span>
<span class="sd">        peaks). This must evenly divide the sampling frequency. If `fs` is</span>
<span class="sd">        specified, this is in the same units as `fs`. By default, it is</span>
<span class="sd">        a normalized scalar that must satisfy  ``0 &lt; w0 &lt; 1``, with</span>
<span class="sd">        ``w0 = 1`` corresponding to half of the sampling frequency.</span>
<span class="sd">    Q : float</span>
<span class="sd">        Quality factor. Dimensionless parameter that characterizes</span>
<span class="sd">        notch filter -3 dB bandwidth ``bw`` relative to its center</span>
<span class="sd">        frequency, ``Q = w0/bw``.</span>
<span class="sd">    ftype : {&#39;notch&#39;, &#39;peak&#39;}</span>
<span class="sd">        The type of comb filter generated by the function. If &#39;notch&#39;, then</span>
<span class="sd">        the Q factor applies to the notches. If &#39;peak&#39;, then the Q factor</span>
<span class="sd">        applies to the peaks.  Default is &#39;notch&#39;.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the signal. Default is 2.0.</span>
<span class="sd">    pass_zero : bool, optional</span>
<span class="sd">        If False (default), the notches (nulls) of the filter are centered on</span>
<span class="sd">        frequencies [0, w0, 2*w0, ...], and the peaks are centered on the</span>
<span class="sd">        midpoints [w0/2, 3*w0/2, 5*w0/2, ...].  If True, the peaks are centered</span>
<span class="sd">        on [0, w0, 2*w0, ...] (passing zero frequency) and vice versa.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (``b``) and denominator (``a``) polynomials</span>
<span class="sd">        of the IIR filter.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `w0` is less than or equal to 0 or greater than or equal to</span>
<span class="sd">        ``fs/2``, if `fs` is not divisible by `w0`, if `ftype`</span>
<span class="sd">        is not &#39;notch&#39; or &#39;peak&#39;</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    iirnotch</span>
<span class="sd">    iirpeak</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For implementation details, see [1]_. The TF implementation of the</span>
<span class="sd">    comb filter is numerically stable even at higher orders due to the</span>
<span class="sd">    use of a single repeated pole, which won&#39;t suffer from precision loss.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sophocles J. Orfanidis, &quot;Introduction To Signal Processing&quot;,</span>
<span class="sd">           Prentice-Hall, 1996, ch. 11, &quot;Digital Filter Design&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Design and plot notching comb filter at 20 Hz for a</span>
<span class="sd">    signal sampled at 200 Hz, using quality factor Q = 30</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; fs = 200.0  # Sample frequency (Hz)</span>
<span class="sd">    &gt;&gt;&gt; f0 = 20.0  # Frequency to be removed from signal (Hz)</span>
<span class="sd">    &gt;&gt;&gt; Q = 30.0  # Quality factor</span>
<span class="sd">    &gt;&gt;&gt; # Design notching comb filter</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.iircomb(f0, Q, ftype=&#39;notch&#39;, fs=fs)</span>

<span class="sd">    &gt;&gt;&gt; # Frequency response</span>
<span class="sd">    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs)</span>
<span class="sd">    &gt;&gt;&gt; response = abs(h)</span>
<span class="sd">    &gt;&gt;&gt; # To avoid divide by zero when graphing</span>
<span class="sd">    &gt;&gt;&gt; response[response == 0] = 1e-20</span>
<span class="sd">    &gt;&gt;&gt; # Plot</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(abs(response)), color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_xlim([0, 100])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylim([-30, 10])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(freq, (np.angle(h)*180/np.pi+180)%360 - 180, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlim([0, 100])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylim([-90, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Design and plot peaking comb filter at 250 Hz for a</span>
<span class="sd">    signal sampled at 1000 Hz, using quality factor Q = 30</span>

<span class="sd">    &gt;&gt;&gt; fs = 1000.0  # Sample frequency (Hz)</span>
<span class="sd">    &gt;&gt;&gt; f0 = 250.0  # Frequency to be retained (Hz)</span>
<span class="sd">    &gt;&gt;&gt; Q = 30.0  # Quality factor</span>
<span class="sd">    &gt;&gt;&gt; # Design peaking filter</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.iircomb(f0, Q, ftype=&#39;peak&#39;, fs=fs, pass_zero=True)</span>

<span class="sd">    &gt;&gt;&gt; # Frequency response</span>
<span class="sd">    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs)</span>
<span class="sd">    &gt;&gt;&gt; response = abs(h)</span>
<span class="sd">    &gt;&gt;&gt; # To avoid divide by zero when graphing</span>
<span class="sd">    &gt;&gt;&gt; response[response == 0] = 1e-20</span>
<span class="sd">    &gt;&gt;&gt; # Plot</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(np.maximum(abs(h), 1e-5)), color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color=&#39;blue&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_xlim([0, 500])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].set_ylim([-80, 10])</span>
<span class="sd">    &gt;&gt;&gt; ax[0].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].plot(freq, (np.angle(h)*180/np.pi+180)%360 - 180, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color=&#39;green&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_xlim([0, 500])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].set_ylim([-90, 90])</span>
<span class="sd">    &gt;&gt;&gt; ax[1].grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert w0, Q, and fs to float</span>
    <span class="n">w0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">w0</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

    <span class="c1"># Check for invalid cutoff frequency or filter type</span>
    <span class="n">ftype</span> <span class="o">=</span> <span class="n">ftype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">w0</span> <span class="o">&lt;</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;w0 must be between 0 and </span><span class="si">{</span><span class="n">fs</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; (nyquist), but given </span><span class="si">{</span><span class="n">w0</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;notch&#39;</span><span class="p">,</span> <span class="s1">&#39;peak&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ftype must be either notch or peak.&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the order of the filter</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">w0</span><span class="p">)</span>

    <span class="c1"># Check for cutoff frequency divisibility</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">w0</span> <span class="o">-</span> <span class="n">fs</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="mf">1e-14</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fs must be divisible by w0.&#39;</span><span class="p">)</span>

    <span class="c1"># Compute frequency in radians and filter bandwidth</span>
    <span class="c1"># Eq. 11.3.1 (p. 574) from reference [1]</span>
    <span class="n">w0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w0</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
    <span class="n">w_delta</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">/</span> <span class="n">Q</span>

    <span class="c1"># Define base gain values depending on notch or peak filter</span>
    <span class="c1"># Compute -3dB attenuation</span>
    <span class="c1"># Eqs. 11.4.1 and 11.4.2 (p. 582) from reference [1]</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;notch&#39;</span><span class="p">:</span>
        <span class="n">G0</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;peak&#39;</span><span class="p">:</span>
        <span class="n">G0</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">GB</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Compute beta</span>
    <span class="c1"># Eq. 11.5.3 (p. 591) from reference [1]</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">GB</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">G0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">G</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">GB</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">w_delta</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Compute filter coefficients</span>
    <span class="c1"># Eq 11.5.1 (p. 590) variables a, b, c from reference [1]</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">bx</span> <span class="o">=</span> <span class="p">(</span><span class="n">G0</span> <span class="o">+</span> <span class="n">G</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="p">(</span><span class="n">G0</span> <span class="o">-</span> <span class="n">G</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span>

    <span class="c1"># Last coefficients are negative to get peaking comb that passes zero or</span>
    <span class="c1"># notching comb that doesn&#39;t.</span>
    <span class="n">negative_coef</span> <span class="o">=</span> <span class="p">((</span><span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;peak&#39;</span> <span class="ow">and</span> <span class="n">pass_zero</span><span class="p">)</span> <span class="ow">or</span>
                     <span class="p">(</span><span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;notch&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pass_zero</span><span class="p">))</span>

    <span class="c1"># Compute numerator coefficients</span>
    <span class="c1"># Eq 11.5.1 (p. 590) or Eq 11.5.4 (p. 591) from reference [1]</span>
    <span class="c1"># b - cz^-N or b + cz^-N</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bx</span>
    <span class="k">if</span> <span class="n">negative_coef</span><span class="p">:</span>
        <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">cx</span>

    <span class="c1"># Compute denominator coefficients</span>
    <span class="c1"># Eq 11.5.1 (p. 590) or Eq 11.5.4 (p. 591) from reference [1]</span>
    <span class="c1"># 1 - az^-N or 1 + az^-N</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">negative_coef</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ax</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">ax</span>

    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_hz_to_erb</span><span class="p">(</span><span class="n">hz</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility for converting from frequency (Hz) to the</span>
<span class="sd">    Equivalent Rectangular Bandwidth (ERB) scale</span>
<span class="sd">    ERB = frequency / EarQ + minBW</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EarQ</span> <span class="o">=</span> <span class="mf">9.26449</span>
    <span class="n">minBW</span> <span class="o">=</span> <span class="mf">24.7</span>
    <span class="k">return</span> <span class="n">hz</span> <span class="o">/</span> <span class="n">EarQ</span> <span class="o">+</span> <span class="n">minBW</span>


<span class="k">def</span> <span class="nf">gammatone</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ftype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numtaps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gammatone filter design.</span>

<span class="sd">    This function computes the coefficients of an FIR or IIR gammatone</span>
<span class="sd">    digital filter [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freq : float</span>
<span class="sd">        Center frequency of the filter (expressed in the same units</span>
<span class="sd">        as `fs`).</span>
<span class="sd">    ftype : {&#39;fir&#39;, &#39;iir&#39;}</span>
<span class="sd">        The type of filter the function generates. If &#39;fir&#39;, the function</span>
<span class="sd">        will generate an Nth order FIR gammatone filter. If &#39;iir&#39;, the</span>
<span class="sd">        function will generate an 8th order digital IIR filter, modeled as</span>
<span class="sd">        as 4th order gammatone filter.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the filter. Only used when ``ftype=&#39;fir&#39;``.</span>
<span class="sd">        Default is 4 to model the human auditory system. Must be between</span>
<span class="sd">        0 and 24.</span>
<span class="sd">    numtaps : int, optional</span>
<span class="sd">        Length of the filter. Only used when ``ftype=&#39;fir&#39;``.</span>
<span class="sd">        Default is ``fs*0.015`` if `fs` is greater than 1000,</span>
<span class="sd">        15 if `fs` is less than or equal to 1000.</span>
<span class="sd">    fs : float, optional</span>
<span class="sd">        The sampling frequency of the signal. `freq` must be between</span>
<span class="sd">        0 and ``fs/2``. Default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b, a : ndarray, ndarray</span>
<span class="sd">        Numerator (``b``) and denominator (``a``) polynomials of the filter.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `freq` is less than or equal to 0 or greater than or equal to</span>
<span class="sd">        ``fs/2``, if `ftype` is not &#39;fir&#39; or &#39;iir&#39;, if `order` is less than</span>
<span class="sd">        or equal to 0 or greater than 24 when ``ftype=&#39;fir&#39;``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    firwin</span>
<span class="sd">    iirfilter</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Slaney, Malcolm, &quot;An Efficient Implementation of the</span>
<span class="sd">        Patterson-Holdsworth Auditory Filter Bank&quot;, Apple Computer</span>
<span class="sd">        Technical Report 35, 1993, pp.3-8, 34-39.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    16-sample 4th order FIR Gammatone filter centered at 440 Hz</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; signal.gammatone(440, &#39;fir&#39;, numtaps=16, fs=16000)</span>
<span class="sd">    (array([ 0.00000000e+00,  2.22196719e-07,  1.64942101e-06,  4.99298227e-06,</span>
<span class="sd">        1.01993969e-05,  1.63125770e-05,  2.14648940e-05,  2.29947263e-05,</span>
<span class="sd">        1.76776931e-05,  2.04980537e-06, -2.72062858e-05, -7.28455299e-05,</span>
<span class="sd">       -1.36651076e-04, -2.19066855e-04, -3.18905076e-04, -4.33156712e-04]),</span>
<span class="sd">       [1.0])</span>

<span class="sd">    IIR Gammatone filter centered at 440 Hz</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.gammatone(440, &#39;iir&#39;, fs=16000)</span>
<span class="sd">    &gt;&gt;&gt; w, h = signal.freqz(b, a)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(w / ((2 * np.pi) / 16000), 20 * np.log10(abs(h)))</span>
<span class="sd">    &gt;&gt;&gt; plt.xscale(&#39;log&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Gammatone filter frequency response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;Amplitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(which=&#39;both&#39;, axis=&#39;both&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axvline(440, color=&#39;green&#39;) # cutoff frequency</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Converts freq to float</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

    <span class="c1"># Set sampling rate if not passed</span>
    <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>

    <span class="c1"># Check for invalid cutoff frequency or filter type</span>
    <span class="n">ftype</span> <span class="o">=</span> <span class="n">ftype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">filter_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="s1">&#39;iir&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">freq</span> <span class="o">&lt;</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The frequency must be between 0 and </span><span class="si">{</span><span class="n">fs</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; (nyquist), but given </span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filter_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ftype must be either fir or iir.&#39;</span><span class="p">)</span>

    <span class="c1"># Calculate FIR gammatone filter</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;fir&#39;</span><span class="p">:</span>
        <span class="c1"># Set order and numtaps if not passed</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numtaps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">numtaps</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">*</span> <span class="mf">0.015</span><span class="p">),</span> <span class="mi">15</span><span class="p">)</span>
        <span class="n">numtaps</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">numtaps</span><span class="p">)</span>

        <span class="c1"># Check for invalid order</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid order: order must be &gt; 0 and &lt;= 24.&quot;</span><span class="p">)</span>

        <span class="c1"># Gammatone impulse response settings</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numtaps</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="mf">1.019</span> <span class="o">*</span> <span class="n">_hz_to_erb</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="c1"># Calculate the FIR gammatone filter</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>

        <span class="c1"># Scale the FIR filter so the frequency response is 1 at cutoff</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">bw</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">scale_factor</span> <span class="o">/=</span> <span class="n">float_factorial</span><span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">scale_factor</span> <span class="o">/=</span> <span class="n">fs</span>
        <span class="n">b</span> <span class="o">*=</span> <span class="n">scale_factor</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>

    <span class="c1"># Calculate IIR gammatone filter</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;iir&#39;</span><span class="p">:</span>
        <span class="c1"># Raise warning if order and/or numtaps is passed</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;order is not used for IIR gammatone filter.&#39;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numtaps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;numtaps is not used for IIR gammatone filter.&#39;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Gammatone impulse response settings</span>
        <span class="n">T</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">fs</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.019</span> <span class="o">*</span> <span class="n">_hz_to_erb</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">T</span>
        <span class="n">bwT</span> <span class="o">=</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span>

        <span class="c1"># Calculate the gain to normalize the volume at the center frequency</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">bwT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span> <span class="o">*</span> <span class="n">T</span>
        <span class="n">g3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
        <span class="n">g4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
        <span class="n">g5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">-</span> <span class="n">g4</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">*=</span> <span class="p">(</span><span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">+</span> <span class="n">g4</span><span class="p">))</span>
        <span class="n">g</span> <span class="o">*=</span> <span class="p">(</span><span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">-</span> <span class="n">g3</span><span class="p">))</span>
        <span class="n">g</span> <span class="o">*=</span> <span class="p">(</span><span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">+</span> <span class="n">g3</span><span class="p">))</span>
        <span class="n">g</span> <span class="o">/=</span> <span class="p">((</span><span class="o">-</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">bwT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">g5</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">g5</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bwT</span><span class="p">))</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="c1"># Create empty filter coefficient lists</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>

        <span class="c1"># Calculate the numerator coefficients</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">T</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">T</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">T</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span>

        <span class="c1"># Calculate the denominator coefficients</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">fr</span><span class="p">))</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">18</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fr</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">fr</span><span class="p">))</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">fr</span><span class="p">))</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span> <span class="o">*</span> <span class="n">bw</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="n">filter_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;butter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">buttap</span><span class="p">,</span> <span class="n">buttord</span><span class="p">],</span>
               <span class="s1">&#39;butterworth&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">buttap</span><span class="p">,</span> <span class="n">buttord</span><span class="p">],</span>

               <span class="s1">&#39;cauer&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ellipap</span><span class="p">,</span> <span class="n">ellipord</span><span class="p">],</span>
               <span class="s1">&#39;elliptic&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ellipap</span><span class="p">,</span> <span class="n">ellipord</span><span class="p">],</span>
               <span class="s1">&#39;ellip&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ellipap</span><span class="p">,</span> <span class="n">ellipord</span><span class="p">],</span>

               <span class="s1">&#39;bessel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">besselap</span><span class="p">],</span>
               <span class="s1">&#39;bessel_phase&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">besselap</span><span class="p">],</span>
               <span class="s1">&#39;bessel_delay&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">besselap</span><span class="p">],</span>
               <span class="s1">&#39;bessel_mag&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">besselap</span><span class="p">],</span>

               <span class="s1">&#39;cheby1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cheb1ap</span><span class="p">,</span> <span class="n">cheb1ord</span><span class="p">],</span>
               <span class="s1">&#39;chebyshev1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cheb1ap</span><span class="p">,</span> <span class="n">cheb1ord</span><span class="p">],</span>
               <span class="s1">&#39;chebyshevi&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cheb1ap</span><span class="p">,</span> <span class="n">cheb1ord</span><span class="p">],</span>

               <span class="s1">&#39;cheby2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cheb2ap</span><span class="p">,</span> <span class="n">cheb2ord</span><span class="p">],</span>
               <span class="s1">&#39;chebyshev2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cheb2ap</span><span class="p">,</span> <span class="n">cheb2ord</span><span class="p">],</span>
               <span class="s1">&#39;chebyshevii&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cheb2ap</span><span class="p">,</span> <span class="n">cheb2ord</span><span class="p">],</span>
               <span class="p">}</span>

<span class="n">band_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;band&#39;</span><span class="p">:</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;pass&#39;</span><span class="p">:</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;bp&#39;</span><span class="p">:</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">,</span>

             <span class="s1">&#39;bs&#39;</span><span class="p">:</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">,</span>
             <span class="s1">&#39;bandstop&#39;</span><span class="p">:</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">,</span>
             <span class="s1">&#39;bands&#39;</span><span class="p">:</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">,</span>

             <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;low&#39;</span><span class="p">:</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;lowpass&#39;</span><span class="p">:</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;lp&#39;</span><span class="p">:</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">,</span>

             <span class="s1">&#39;high&#39;</span><span class="p">:</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;highpass&#39;</span><span class="p">:</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;hp&#39;</span><span class="p">:</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span>
             <span class="p">}</span>

<span class="n">bessel_norms</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bessel&#39;</span><span class="p">:</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span>
                <span class="s1">&#39;bessel_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span>
                <span class="s1">&#39;bessel_delay&#39;</span><span class="p">:</span> <span class="s1">&#39;delay&#39;</span><span class="p">,</span>
                <span class="s1">&#39;bessel_mag&#39;</span><span class="p">:</span> <span class="s1">&#39;mag&#39;</span><span class="p">}</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2019, California Department of Water Resources.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>